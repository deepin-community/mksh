Please review changes against upstream code using SCM,
see the Vcs-* tags in debian/control for its location.

--- mksh-59c.orig/Build.sh
+++ mksh-59c/Build.sh
@@ -1,9 +1,9 @@
 #!/bin/sh
-srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.763 2020/09/04 21:01:37 tg Exp $'
+srcversion='$MirOS: src/bin/mksh/Build.sh,v 1.810 2021/10/11 22:23:01 tg Exp $'
 #-
 # Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 #		2011, 2012, 2013, 2014, 2015, 2016, 2017, 2019,
-#		2020
+#		2020, 2021
 #	mirabilos <m@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -29,6 +29,8 @@ srcversion='$MirOS: src/bin/mksh/Build.s
 LC_ALL=C; LANGUAGE=C
 export LC_ALL; unset LANGUAGE
 
+use_ach=x; unset use_ach
+
 case $ZSH_VERSION:$VERSION in
 :zsh*) ZSH_VERSION=2 ;;
 esac
@@ -44,6 +46,20 @@ if test -d /usr/xpg4/bin/. >/dev/null 2>
 	export PATH
 fi
 
+test_tool() {
+	x=`echo $2 | $3`
+	y=$?
+
+	test x"$y" = x"0" && test x"$x" = x"$4" && return
+	echo >&2 "E: your $1 does not work correctly!"
+	echo >&2 "N: 'echo $2 | $3' exited $y and returned '$x' instead of '$4'"
+	echo >&2 'N: install a better one and prepend e.g. /usr/local/bin to $PATH'
+	exit 1
+}
+test_tool grep foobarbaz 'grep bar' foobarbaz
+test_tool sed abc 'sed y/ac/AC/' AbC
+test_tool tr abc 'tr ac AC' AbC
+
 nl='
 '
 safeIFS='	'
@@ -223,6 +239,16 @@ fi
 
 echo "For the build logs, demonstrate that /dev/null and /dev/tty exist:"
 ls -l /dev/null /dev/tty
+cat <<EOF
+Flags on entry (plus HAVE_* which are not shown here):
+ CC        <$CC>
+ CFLAGS    <$CFLAGS>
+ CPPFLAGS  <$CPPFLAGS>
+ LDFLAGS   <$LDFLAGS>
+ LIBS      <$LIBS>
+ TARGET_OS <$TARGET_OS> TARGET_OSREV <$TARGET_OSREV>
+
+EOF
 
 v() {
 	$e "$*"
@@ -244,7 +270,7 @@ vq() {
 rmf() {
 	for _f in "$@"; do
 		case $_f in
-		*.1|*.faq|*.ico) ;;
+		lksh.1|mksh.1|mksh.faq|mksh.ico) ;;
 		*) rm -f "$_f" ;;
 		esac
 	done
@@ -326,6 +352,17 @@ ac_testinit() {
 	return 0
 }
 
+cat_h_blurb() {
+	echo '#ifdef MKSH_USE_AUTOCONF_H
+/* things that “should” have been on the command line */
+#include "autoconf.h"
+#undef MKSH_USE_AUTOCONF_H
+#endif
+
+'
+	cat
+}
+
 # pipe .c | ac_test[n] [!] label [!] checkif[!]0 [setlabelifcheckis[!]0] useroutput
 ac_testnnd() {
 	if test x"$1" = x"!"; then
@@ -335,8 +372,8 @@ ac_testnnd() {
 		fr=0
 	fi
 	ac_testinit "$@" || return 1
-	cat >conftest.c
-	vv ']' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN conftest.c $LIBS $ccpr"
+	cat_h_blurb >conftest.c
+	vv ']' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN conftest.c $LIBS $ccpr"
 	test $tcfn = no && test -f a.out && tcfn=a.out
 	test $tcfn = no && test -f a.exe && tcfn=a.exe
 	test $tcfn = no && test -f conftest.exe && tcfn=conftest.exe
@@ -384,6 +421,31 @@ EOF
 	test x"$fv" = x"1"
 }
 
+addtoach() {
+	if echo "$1" >>autoconf.h; then
+		echo ">>> $1"
+	else
+		echo >&2 "E: could not write autoconf.h"
+		exit 255
+	fi
+}
+
+# simple only (is IFS-split by shell)
+cpp_define() {
+	case $use_ach in
+	0)
+		add_cppflags "-D$1=$2"
+		;;
+	1)
+		addtoach "#define $1 $2"
+		;;
+	*)
+		echo >&2 "E: cpp_define() called too early!"
+		exit 255
+		;;
+	esac
+}
+
 add_cppflags() {
 	CPPFLAGS="$CPPFLAGS $*"
 }
@@ -392,7 +454,7 @@ ac_cppflags() {
 	test x"$1" = x"" || fu=$1
 	fv=$2
 	test x"$2" = x"" && eval fv=\$HAVE_$fu
-	add_cppflags -DHAVE_$fu=$fv
+	cpp_define HAVE_$fu $fv
 }
 
 ac_test() {
@@ -424,7 +486,7 @@ ac_flags() {
 		ac_testn can_$vn '' "$ft" <<-'EOF'
 			/* evil apo'stroph in comment test */
 			#include <unistd.h>
-			int main(void) { return (isatty(0)); }
+			int main(void) { int t[2]; return (isatty(pipe(t))); }
 		EOF
 		#'
 	fi
@@ -448,14 +510,17 @@ ac_header() {
 	do
 		case $i in
 		_time)
-			echo '#if HAVE_BOTH_TIME_H' >>x
+			echo '#if HAVE_BOTH_TIME_H && HAVE_SELECT_TIME_H' >>x
 			echo '#include <sys/time.h>' >>x
 			echo '#include <time.h>' >>x
-			echo '#elif HAVE_SYS_TIME_H' >>x
+			echo '#elif HAVE_SYS_TIME_H && HAVE_SELECT_TIME_H' >>x
 			echo '#include <sys/time.h>' >>x
 			echo '#elif HAVE_TIME_H' >>x
 			echo '#include <time.h>' >>x
 			echo '#endif' >>x
+			echo '#if HAVE_SYS_SELECT_H' >>x
+			echo '#include <sys/select.h>' >>x
+			echo '#endif' >>x
 			;;
 		*)
 			echo "#include <$i>" >>x
@@ -484,6 +549,7 @@ addsrcs() {
 	esac
 }
 
+# --- main ---
 
 curdir=`pwd` srcdir=`dirname "$0" 2>/dev/null`
 case x$srcdir in
@@ -499,14 +565,23 @@ x)
 	exit 1
 	;;
 esac
+srcdisp=`cd "$srcdir" && pwd` || srcdisp=
+test_n "$srcdisp" || srcdisp=$srcdir
+if test x"$srcdisp" = x"$curdir"; then
+	srcdisp=
+else
+	srcdisp=$srcdir/
+fi
 dstversion=`sed -n '/define MKSH_VERSION/s/^.*"\([^"]*\)".*$/\1/p' "$srcdir/sh.h"`
-add_cppflags -DMKSH_BUILDSH
+whatlong='The MirBSD Korn Shell (mksh)'
+whatshort=mksh
 
 e=echo
 r=0
 eq=0
 pm=0
 cm=normal
+Cg=
 optflags=-std-compile-opts
 check_categories=
 last=
@@ -530,6 +605,12 @@ do
 		optflags=$i
 		last=
 		;;
+	:-A)
+		rm -f autoconf.h
+		addtoach '/* work around NeXTstep bug */'
+		use_ach=1
+		add_cppflags -DMKSH_USE_AUTOCONF_H
+		;;
 	:-c)
 		last=c
 		;;
@@ -543,7 +624,7 @@ do
 	:-g)
 		# checker, debug, valgrind build
 		add_cppflags -DDEBUG
-		CFLAGS="$CFLAGS -g3 -fno-builtin"
+		Cg=YES
 		;;
 	:-j)
 		pm=1
@@ -577,7 +658,7 @@ do
 		;;
 	:-v)
 		echo "Build.sh $srcversion"
-		echo "for mksh $dstversion"
+		echo "for $whatlong $dstversion"
 		exit 0
 		;;
 	:*)
@@ -604,6 +685,8 @@ if test -d $tfn || test -d $tfn.exe; the
 	echo "$me: Error: ./$tfn is a directory!" >&2
 	exit 1
 fi
+test x"$use_ach" = x"1" || use_ach=0
+cpp_define MKSH_BUILDSH 1
 rmf a.exe* a.out* conftest.c conftest.exe* *core core.* ${tfn}* *.bc *.dbg \
     *.ll *.o *.gen *.cat1 Rebuild.sh lft no signames.inc test.sh x vv.out *.htm
 
@@ -614,18 +697,18 @@ if test $legacy = 0; then
 	check_categories="$check_categories shell:legacy-no int:32"
 else
 	check_categories="$check_categories shell:legacy-yes"
-	add_cppflags -DMKSH_LEGACY_MODE
+	cpp_define MKSH_LEGACY_MODE 1
 fi
 
 if $ebcdic; then
-	add_cppflags -DMKSH_EBCDIC
+	cpp_define MKSH_EBCDIC 1
 fi
 
 if test $textmode = 0; then
 	check_categories="$check_categories shell:textmode-no shell:binmode-yes"
 else
 	check_categories="$check_categories shell:textmode-yes shell:binmode-no"
-	add_cppflags -DMKSH_WITH_TEXTMODE
+	cpp_define MKSH_WITH_TEXTMODE 1
 fi
 
 if test x"$srcdir" = x"."; then
@@ -641,17 +724,30 @@ fi
 
 if test_z "$TARGET_OS"; then
 	x=`uname -s 2>/dev/null || uname`
-	test x"$x" = x"`uname -n 2>/dev/null`" || TARGET_OS=$x
+	case $x in
+	scosysv)
+		# SVR4 Unix with uname -s = uname -n, whitelist
+		TARGET_OS=$x
+		;;
+	syllable)
+		# other OS with uname -s = uname = uname -n, whitelist
+		TARGET_OS=$x
+		;;
+	*)
+		test x"$x" = x"`uname -n 2>/dev/null`" || TARGET_OS=$x
+		;;
+	esac
 fi
 if test_z "$TARGET_OS"; then
 	echo "$me: Set TARGET_OS, your uname is broken!" >&2
 	exit 1
 fi
+osnote=
 oswarn=
 ccpc=-Wc,
 ccpl=-Wl,
 tsts=
-ccpr='|| for _f in ${tcfn}*; do case $_f in *.1|*.faq|*.ico) ;; *) rm -f "$_f" ;; esac; done'
+ccpr='|| for _f in ${tcfn}*; do case $_f in lksh.1|mksh.1|mksh.faq|mksh.ico) ;; *) rm -f "$_f" ;; esac; done'
 
 # Evil hack
 if test x"$TARGET_OS" = x"Android"; then
@@ -665,7 +761,7 @@ if test x"$TARGET_OS" = x"Minix"; then
 WARNING: additional checks before running Build.sh required!
 You can avoid these by calling Build.sh correctly, see below.
 "
-	cat >conftest.c <<'EOF'
+	cat_h_blurb >conftest.c <<'EOF'
 #include <sys/types.h>
 const char *
 #ifdef _NETBSD_SOURCE
@@ -676,7 +772,7 @@ ct="Minix3"
 ;
 EOF
 	ct=unknown
-	vv ']' "${CC-cc} -E $CFLAGS $CPPFLAGS $NOWARN conftest.c | grep ct= | tr -d \\\\015 >x"
+	vv ']' "${CC-cc} -E $CFLAGS $Cg $CPPFLAGS $NOWARN conftest.c | grep ct= | tr -d \\\\015 >x"
 	sed 's/^/[ /' x
 	eval `cat x`
 	rmf x vv.out
@@ -709,17 +805,19 @@ NEXTSTEP)
 	    grep 'NeXT Mach [0-9][0-9.]*:' | \
 	    sed 's/^.*NeXT Mach \([0-9][0-9.]*\):.*$/\1/'`
 	;;
-QNX|SCO_SV)
+BeOS|QNX|SCO_SV)
 	test_n "$TARGET_OSREV" || TARGET_OSREV=`uname -r`
 	;;
 esac
 
+cmplrflgs=
+
 # Configuration depending on OS name
 case $TARGET_OS in
 386BSD)
 	: "${HAVE_CAN_OTWO=0}"
-	add_cppflags -DMKSH_NO_SIGSETJMP
-	add_cppflags -DMKSH_TYPEDEF_SIG_ATOMIC_T=int
+	cpp_define MKSH_NO_SIGSETJMP 1
+	cpp_define MKSH_TYPEDEF_SIG_ATOMIC_T int
 	;;
 A/UX)
 	add_cppflags -D_POSIX_SOURCE
@@ -733,30 +831,49 @@ AIX)
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 BeOS)
+	: "${CC=gcc}"
+	case $TARGET_OSREV in
+	[012345].*)
+		oswarn="; it has MAJOR issues"
+		test x"$TARGET_OSREV" = x"5.1" || \
+		    cpp_define MKSH_NO_SIGSUSPEND 1
+		;;
+	*)
+		oswarn="; it has minor issues"
+		;;
+	esac
 	case $KSH_VERSION in
 	*MIRBSD\ KSH*)
-		oswarn="; it has minor issues"
 		;;
 	*)
-		oswarn="; you must recompile mksh with"
-		oswarn="$oswarn${nl}itself in a second stage"
+		case $ZSH_VERSION in
+		*[0-9]*)
+			;;
+		*)
+			oswarn="; you must recompile mksh with"
+			oswarn="$oswarn${nl}itself in a second stage"
+			;;
+		esac
 		;;
 	esac
+	: "${MKSH_UNLIMITED=1}"
 	# BeOS has no real tty either
-	add_cppflags -DMKSH_UNEMPLOYED
-	add_cppflags -DMKSH_DISABLE_TTY_WARNING
+	cpp_define MKSH_UNEMPLOYED 1
+	cpp_define MKSH_DISABLE_TTY_WARNING 1
 	# BeOS doesn't have different UIDs and GIDs
-	add_cppflags -DMKSH__NO_SETEUGID
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
 	;;
 BSD/OS)
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 Coherent)
 	oswarn="; it has major issues"
-	add_cppflags -DMKSH__NO_SYMLINK
+	cpp_define MKSH__NO_SYMLINK 1
 	check_categories="$check_categories nosymlink"
-	add_cppflags -DMKSH__NO_SETEUGID
-	add_cppflags -DMKSH_DISABLE_TTY_WARNING
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
+	cpp_define MKSH_DISABLE_TTY_WARNING 1
 	;;
 CYGWIN*)
 	: "${HAVE_SETLOCALE_CTYPE=0}"
@@ -778,21 +895,22 @@ GNU)
 	*tendracc*) ;;
 	*) add_cppflags -D_GNU_SOURCE ;;
 	esac
-	add_cppflags -DSETUID_CAN_FAIL_WITH_EAGAIN
+	cpp_define SETUID_CAN_FAIL_WITH_EAGAIN 1
 	# define MKSH__NO_PATH_MAX to use Hurd-only functions
-	add_cppflags -DMKSH__NO_PATH_MAX
+	cpp_define MKSH__NO_PATH_MAX 1
 	;;
 GNU/kFreeBSD)
 	case $CC in
 	*tendracc*) ;;
 	*) add_cppflags -D_GNU_SOURCE ;;
 	esac
-	add_cppflags -DSETUID_CAN_FAIL_WITH_EAGAIN
+	cpp_define SETUID_CAN_FAIL_WITH_EAGAIN 1
 	;;
 Haiku)
-	add_cppflags -DMKSH_ASSUME_UTF8
+	cpp_define MKSH_ASSUME_UTF8 1
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=0
+	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 Harvey)
 	add_cppflags -D_POSIX_SOURCE
@@ -800,18 +918,21 @@ Harvey)
 	add_cppflags -D_BSD_EXTENSION
 	add_cppflags -D_SUSV2_SOURCE
 	add_cppflags -D_GNU_SOURCE
-	add_cppflags -DMKSH_ASSUME_UTF8
+	cpp_define MKSH_ASSUME_UTF8 1
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=0
-	add_cppflags -DMKSH__NO_SYMLINK
+	: "${HAVE_SETLOCALE_CTYPE=0}"
+	cpp_define MKSH__NO_SYMLINK 1
 	check_categories="$check_categories nosymlink"
-	add_cppflags -DMKSH_NO_CMDLINE_EDITING
-	add_cppflags -DMKSH__NO_SETEUGID
+	cpp_define MKSH_NO_CMDLINE_EDITING 1
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
 	oswarn=' and will currently not work'
-	add_cppflags -DMKSH_UNEMPLOYED
-	add_cppflags -DMKSH_NOPROSPECTOFWORK
+	cpp_define MKSH_UNEMPLOYED 1
+	cpp_define MKSH_NOPROSPECTOFWORK 1
 	# these taken from Harvey-OS github and need re-checking
-	add_cppflags -D_setjmp=setjmp -D_longjmp=longjmp
+	cpp_define _setjmp setjmp
+	cpp_define _longjmp longjmp
 	: "${HAVE_CAN_NO_EH_FRAME=0}"
 	: "${HAVE_CAN_FNOSTRICTALIASING=0}"
 	: "${HAVE_CAN_FSTACKPROTECTORSTRONG=0}"
@@ -829,13 +950,14 @@ IRIX*)
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 Jehanne)
-	add_cppflags -DMKSH_ASSUME_UTF8
+	cpp_define MKSH_ASSUME_UTF8 1
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=0
-	add_cppflags -DMKSH__NO_SYMLINK
+	: "${HAVE_SETLOCALE_CTYPE=0}"
+	cpp_define MKSH__NO_SYMLINK 1
 	check_categories="$check_categories nosymlink"
-	add_cppflags -DMKSH_NO_CMDLINE_EDITING
-	add_cppflags -DMKSH_DISABLE_REVOKE_WARNING
+	cpp_define MKSH_NO_CMDLINE_EDITING 1
+	cpp_define MKSH_DISABLE_REVOKE_WARNING 1
 	add_cppflags '-D_PATH_DEFPATH=\"/cmd\"'
 	add_cppflags '-DMKSH_DEFAULT_EXECSHELL=\"/cmd/mksh\"'
 	add_cppflags '-DMKSH_DEFAULT_PROFILEDIR=\"/cfg/mksh\"'
@@ -847,7 +969,7 @@ Linux)
 	*tendracc*) ;;
 	*) add_cppflags -D_GNU_SOURCE ;;
 	esac
-	add_cppflags -DSETUID_CAN_FAIL_WITH_EAGAIN
+	cpp_define SETUID_CAN_FAIL_WITH_EAGAIN 1
 	: "${HAVE_REVOKE=0}"
 	;;
 LynxOS)
@@ -861,22 +983,28 @@ midipix)
 MidnightBSD)
 	;;
 Minix-vmd)
-	add_cppflags -DMKSH__NO_SETEUGID
-	add_cppflags -DMKSH_UNEMPLOYED
 	add_cppflags -D_MINIX_SOURCE
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
+	cpp_define MKSH_UNEMPLOYED 1
 	oldish_ed=no-stderr-ed		# no /bin/ed, maybe see below
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 Minix3)
-	add_cppflags -DMKSH_UNEMPLOYED
 	add_cppflags -D_POSIX_SOURCE -D_POSIX_1_SOURCE=2 -D_MINIX
+	cpp_define MKSH_UNEMPLOYED 1
 	oldish_ed=no-stderr-ed		# /usr/bin/ed(!) is broken
 	: "${HAVE_SETLOCALE_CTYPE=0}${MKSH_UNLIMITED=1}" #XXX recheck ulimit
 	;;
+Minoca)
+	: "${CC=gcc}"
+	;;
 MirBSD)
+	# for testing HAVE_SIGACTION=0 builds only (but fulfills the contract)
+	cpp_define MKSH_USABLE_SIGNALFUNC bsd_signal
 	;;
 MSYS_*)
-	add_cppflags -DMKSH_ASSUME_UTF8=0
+	cpp_define MKSH_ASSUME_UTF8 0
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=1
 	# almost same as CYGWIN* (from RT|Chatzilla)
@@ -890,10 +1018,10 @@ NEXTSTEP)
 	add_cppflags -D_NEXT_SOURCE
 	add_cppflags -D_POSIX_SOURCE
 	: "${AWK=gawk}"
-	: "${CC=cc -posix}"
-	add_cppflags -DMKSH_NO_SIGSETJMP
+	: "${CC=cc -posix -traditional-cpp}"
+	cpp_define MKSH_NO_SIGSETJMP 1
 	# NeXTstep cannot get a controlling tty
-	add_cppflags -DMKSH_UNEMPLOYED
+	cpp_define MKSH_UNEMPLOYED 1
 	case $TARGET_OSREV in
 	4.2*)
 		# OpenStep 4.2 is broken by default
@@ -903,7 +1031,7 @@ NEXTSTEP)
 	;;
 Ninix3)
 	# similar to Minix3
-	add_cppflags -DMKSH_UNEMPLOYED
+	cpp_define MKSH_UNEMPLOYED 1
 	: "${MKSH_UNLIMITED=1}" #XXX recheck ulimit
 	# but no idea what else could be needed
 	oswarn="; it has unknown issues"
@@ -912,18 +1040,19 @@ OpenBSD)
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 OS/2)
-	add_cppflags -DMKSH_ASSUME_UTF8=0
+	cpp_define MKSH_ASSUME_UTF8 0
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=1
+	: "${HAVE_SETLOCALE_CTYPE=0}"
 	HAVE_TERMIOS_H=0
 	HAVE_MKNOD=0	# setmode() incompatible
 	check_categories="$check_categories nosymlink"
 	: "${CC=gcc}"
 	: "${SIZE=: size}"
 	SRCS="$SRCS os2.c"
-	add_cppflags -DMKSH_UNEMPLOYED
-	add_cppflags -DMKSH_NOPROSPECTOFWORK
-	add_cppflags -DMKSH_DOSPATH
+	cpp_define MKSH_UNEMPLOYED 1
+	cpp_define MKSH_NOPROSPECTOFWORK 1
+	cpp_define MKSH_DOSPATH 1
 	: "${MKSH_UNLIMITED=1}"
 	if test $textmode = 0; then
 		x='dis'
@@ -948,12 +1077,13 @@ the mksh-os2 porter.
 "
 	;;
 OS/390)
-	add_cppflags -DMKSH_ASSUME_UTF8=0
+	cpp_define MKSH_ASSUME_UTF8 0
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=1
+	: "${HAVE_SETLOCALE_CTYPE=0}"
 	: "${CC=xlc}"
 	: "${SIZE=: size}"
-	add_cppflags -DMKSH_FOR_Z_OS
+	cpp_define MKSH_FOR_Z_OS 1
 	add_cppflags -D_ALL_SOURCE
 	oswarn='; EBCDIC support is incomplete'
 	;;
@@ -970,17 +1100,19 @@ Plan9)
 	add_cppflags -D_LIMITS_EXTENSION
 	add_cppflags -D_BSD_EXTENSION
 	add_cppflags -D_SUSV2_SOURCE
-	add_cppflags -DMKSH_ASSUME_UTF8
+	cpp_define MKSH_ASSUME_UTF8 1
 	HAVE_ISSET_MKSH_ASSUME_UTF8=1
 	HAVE_ISOFF_MKSH_ASSUME_UTF8=0
-	add_cppflags -DMKSH__NO_SYMLINK
+	: "${HAVE_SETLOCALE_CTYPE=0}"
+	cpp_define MKSH__NO_SYMLINK 1
 	check_categories="$check_categories nosymlink"
-	add_cppflags -DMKSH_NO_CMDLINE_EDITING
-	add_cppflags -DMKSH__NO_SETEUGID
+	cpp_define MKSH_NO_CMDLINE_EDITING 1
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
 	oswarn=' and will currently not work'
-	add_cppflags -DMKSH_UNEMPLOYED
+	cpp_define MKSH_UNEMPLOYED 1
 	# this is for detecting kencc
-	add_cppflags -DMKSH_MAYBE_KENCC
+	cmplrflgs=-DMKSH_MAYBE_KENCC
 	;;
 PW32*)
 	HAVE_SIG_T=0	# incompatible
@@ -997,11 +1129,20 @@ QNX)
 	esac
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
+scosysv)
+	cmplrflgs=-DMKSH_MAYBE_QUICK_C
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
+	cpp_define MKSH_BROKEN_OFFSETOF 1
+	cpp_define MKSH_TYPEDEF_SSIZE_T int
+	cpp_define MKSH_UNEMPLOYED 1
+	: "${HAVE_SETLOCALE_CTYPE=0}${HAVE_TERMIOS_H=0}"
+	;;
 SCO_SV)
 	case $TARGET_OSREV in
 	3.2*)
 		# SCO OpenServer 5
-		add_cppflags -DMKSH_UNEMPLOYED
+		cpp_define MKSH_UNEMPLOYED 1
 		;;
 	5*)
 		# SCO OpenServer 6
@@ -1013,6 +1154,18 @@ SCO_SV)
 	esac
 	: "${HAVE_SYS_SIGLIST=0}${HAVE__SYS_SIGLIST=0}"
 	;;
+SerenityOS)
+	oswarn="; it has major issues"
+	cpp_define MKSH_NO_SIGSUSPEND 1
+	cpp_define MKSH_POLL_FOR_PAUSE 1
+	: "${MKSH_UNLIMITED=1}${HAVE_GETRUSAGE=0}"
+	cpp_define MKSH_UNEMPLOYED 1
+	cpp_define MKSH_DISABLE_TTY_WARNING 1
+	cpp_define MKSH_NO_SIGSETJMP 1
+	cpp_define _setjmp setjmp
+	cpp_define _longjmp longjmp
+	cpp_define MKSH_USABLE_SIGNALFUNC signal
+	;;
 skyos)
 	oswarn="; it has minor issues"
 	;;
@@ -1022,12 +1175,12 @@ SunOS)
 	;;
 syllable)
 	add_cppflags -D_GNU_SOURCE
-	add_cppflags -DMKSH_NO_SIGSUSPEND
-	oswarn=' and will currently not work'
+	cpp_define MKSH_NO_SIGSUSPEND 1
+	: "${MKSH_UNLIMITED=1}"
 	;;
 ULTRIX)
 	: "${CC=cc -YPOSIX}"
-	add_cppflags -DMKSH_TYPEDEF_SSIZE_T=int
+	cpp_define MKSH_TYPEDEF_SSIZE_T int
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
 UnixWare|UNIX_SV)
@@ -1042,19 +1195,38 @@ UWIN*)
 	oswarn="$oswarn${nl}platform itself is very flakey/unreliable"
 	: "${HAVE_SETLOCALE_CTYPE=0}"
 	;;
+XENIX)
+	# mostly when crosscompiling from scosysv
+	cmplrflgs=-DMKSH_MAYBE_QUICK_C
+	# this can barely do anything
+	cpp_define MKSH__NO_SETEUGID 1
+	: "${HAVE_SETRESUGID=0}"
+	cpp_define MKSH_NO_SIGSETJMP 1
+	cpp_define _setjmp setjmp
+	cpp_define _longjmp longjmp
+	cpp_define USE_REALLOC_MALLOC 0
+	cpp_define MKSH_BROKEN_OFFSETOF 1
+	cpp_define MKSH_TYPEDEF_SSIZE_T int
+	# per http://www.polarhome.com/service/man/?qf=signal&of=Xenix
+	cpp_define MKSH_USABLE_SIGNALFUNC signal
+	cpp_define MKSH_UNEMPLOYED 1
+	cpp_define MKSH_NOPROSPECTOFWORK 1
+	cpp_define MKSH__NO_SYMLINK 1
+	check_categories="$check_categories nosymlink"
+	: "${HAVE_SETLOCALE_CTYPE=0}"
+	# these are broken
+	HAVE_TERMIOS_H=0
+	;;
 _svr4)
 	# generic target for SVR4 Unix with uname -s = uname -n
 	# this duplicates the * target below
 	oswarn='; it may or may not work'
-	test_n "$TARGET_OSREV" || TARGET_OSREV=`uname -r`
 	;;
 *)
 	oswarn='; it may or may not work'
-	test_n "$TARGET_OSREV" || TARGET_OSREV=`uname -r`
 	;;
 esac
-
-: "${HAVE_MKNOD=0}"
+test_n "$TARGET_OSREV" || TARGET_OSREV=`uname -r`
 
 : "${AWK=awk}${CC=cc}${NROFF=nroff}${SIZE=size}"
 test 0 = $r && echo | $NROFF -v 2>&1 | grep GNU >/dev/null 2>&1 && \
@@ -1085,7 +1257,7 @@ OSF1)
 	vv '|' "uname -a >&2"
 	vv '|' "/usr/sbin/sizer -v >&2"
 	;;
-SCO_SV|UnixWare|UNIX_SV)
+scosysv|SCO_SV|UnixWare|UNIX_SV|XENIX)
 	vv '|' "uname -a >&2"
 	vv '|' "uname -X >&2"
 	;;
@@ -1094,13 +1266,18 @@ SCO_SV|UnixWare|UNIX_SV)
 	;;
 esac
 test_z "$oswarn" || echo >&2 "
-Warning: mksh has not yet been ported to or tested on your
-operating system '$TARGET_OS'$oswarn. If you can provide
-a shell account to the developer, this may improve; please
-drop us a success or failure notice or even send in diffs,
-at the very least, complete logs (Build.sh + test.sh) will help.
+Warning: $whatshort has not yet been ported to or tested on your
+operating system '$TARGET_OS'$oswarn."
+test_z "$osnote" || echo >&2 "
+Note: $whatshort is not fully ported to or tested yet on your
+operating system '$TARGET_OS'$osnote."
+test_z "$osnote$oswarn" || echo >&2 "
+If you can provide a shell account to the developer, this
+may improve; please drop us a success or failure notice or
+even send patches for the remaining issues, or, at the very
+least, complete logs (Build.sh + test.sh) will help.
 "
-$e "$bi$me: Building the MirBSD Korn Shell$ao $ui$dstversion$ao on $TARGET_OS ${TARGET_OSREV}..."
+$e "$bi$me: Building $whatlong$ao $ui$dstversion$ao on $TARGET_OS ${TARGET_OSREV}..."
 
 #
 # Start of mirtoconf checks
@@ -1117,7 +1294,7 @@ $e $bi$me: Scanning for functions... ple
 # - nwcc defines __GNUC__ too
 CPP="$CC -E"
 $e ... which compiler type seems to be used
-cat >conftest.c <<'EOF'
+cat_h_blurb >conftest.c <<'EOF'
 const char *
 #if defined(__ICC) || defined(__INTEL_COMPILER)
 ct="icc"
@@ -1177,6 +1354,8 @@ ct="ucode"
 ct="uslc"
 #elif defined(__LCC__)
 ct="lcc"
+#elif defined(MKSH_MAYBE_QUICK_C) && defined(_M_BITFIELDS)
+ct="quickc"
 #elif defined(MKSH_MAYBE_KENCC)
 /* and none of the above matches */
 ct="kencc"
@@ -1194,24 +1373,26 @@ et="unknown"
 EOF
 ct=untested
 et=untested
-vv ']' "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c | \
+vv ']' "$CPP $CFLAGS $CPPFLAGS $NOWARN $cmplrflgs conftest.c | \
     sed -n '/^ *[ce]t *= */s/^ *\([ce]t\) *= */\1=/p' | tr -d \\\\015 >x"
 sed 's/^/[ /' x
 eval `cat x`
 rmf x vv.out
-cat >conftest.c <<'EOF'
+cat_h_blurb >conftest.c <<'EOF'
 #include <unistd.h>
 int main(void) { return (isatty(0)); }
 EOF
+test_z "$Cg" || Cg=-g  # generic
 case $ct in
 ack)
 	# work around "the famous ACK const bug"
 	CPPFLAGS="-Dconst= $CPPFLAGS"
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
 	;;
 adsp)
 	echo >&2 'Warning: Analog Devices C++ compiler for Blackfin, TigerSHARC
     and SHARC (21000) DSPs detected. This compiler has not yet
-    been tested for compatibility with mksh. Continue at your
+    been tested for compatibility with this. Continue at your
     own risk, please report success/failure to the developers.'
 	;;
 bcc)
@@ -1221,7 +1402,7 @@ bcc)
 	;;
 clang)
 	# does not work with current "ccc" compiler driver
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -version"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -version"
 	# one of these two works, for now
 	vv '|' "${CLANG-clang} -version"
 	vv '|' "${CLANG-clang} --version"
@@ -1233,8 +1414,9 @@ clang)
 	: "${HAVE_STRING_POOLING=i1}"
 	;;
 dec)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V"
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -Wl,-V conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -Wl,-V conftest.c $LIBS"
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
 	;;
 dmc)
 	echo >&2 "Warning: Digital Mars Compiler detected. When running under"
@@ -1243,40 +1425,43 @@ dmc)
 	echo >&2 "    please report success/failure to the developers."
 	;;
 gcc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
-	vv '|' 'eval echo "\`$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -dumpmachine\`" \
-		 "gcc\`$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -dumpversion\`"'
+	test_z "$Cg" || Cg='-g3 -fno-builtin'
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
+	vv '|' 'eval echo "\`$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -dumpmachine\`" \
+		 "gcc\`$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -dumpversion\`"'
 	: "${HAVE_STRING_POOLING=i2}"
 	;;
 hpcc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
 	;;
 iar)
 	echo >&2 'Warning: IAR Systems (http://www.iar.com) compiler for embedded
     systems detected. This unsupported compiler has not yet
-    been tested for compatibility with mksh. Continue at your
+    been tested for compatibility with this. Continue at your
     own risk, please report success/failure to the developers.'
 	;;
 icc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V"
 	;;
 kencc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
 	;;
 lacc)
 	# no version information
 	;;
 lcc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
-	add_cppflags -D__inline__=__inline
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
+	cpp_define __inline__ __inline
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
 	;;
 metrowerks)
 	echo >&2 'Warning: Metrowerks C compiler detected. This has not yet
-    been tested for compatibility with mksh. Continue at your
+    been tested for compatibility with this. Continue at your
     own risk, please report success/failure to the developers.'
 	;;
 mipspro)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -version"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -version"
 	;;
 msc)
 	ccpr=		# errorlevels are not reliable
@@ -1298,41 +1483,46 @@ msc)
 	esac
 	;;
 neatcc)
-	add_cppflags -DMKSH_DONT_EMIT_IDSTRING
-	add_cppflags -DMKSH_NO_SIGSETJMP
-	add_cppflags -Dsig_atomic_t=int
+	cpp_define MKSH_DONT_EMIT_IDSTRING 1
+	cpp_define MKSH_NO_SIGSETJMP 1
+	cpp_define sig_atomic_t int
 	vv '|' "$CC"
 	;;
 nwcc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -version"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -version"
 	;;
 pcc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -v"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -v"
 	;;
 pgi)
 	echo >&2 'Warning: PGI detected. This unknown compiler has not yet
-    been tested for compatibility with mksh. Continue at your
+    been tested for compatibility with this. Continue at your
     own risk, please report success/failure to the developers.'
 	;;
+quickc)
+	# no version information
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
+	;;
 sdcc)
 	echo >&2 'Warning: sdcc (http://sdcc.sourceforge.net), the small devices
     C compiler for embedded systems detected. This has not yet
-    been tested for compatibility with mksh. Continue at your
+    been tested for compatibility with this. Continue at your
     own risk, please report success/failure to the developers.'
 	;;
 sunpro)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
 	;;
 tcc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -v"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -v"
 	;;
 tendra)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V 2>&1 | \
-	    grep -F -i -e version -e release"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V 2>&1 | \
+	    grep -i -e version -e release"
 	;;
 ucode)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V"
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -Wl,-V conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -V"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -Wl,-V conftest.c $LIBS"
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
 	;;
 uslc)
 	case $TARGET_OS:$TARGET_OSREV in
@@ -1342,22 +1532,23 @@ uslc)
 		: "${HAVE_CAN_OTWO=0}${HAVE_CAN_OPTIMISE=0}"
 		;;
 	esac
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
+	: "${HAVE_ATTRIBUTE_EXTENSION=0}"  # skip checking as we know it absent
 	;;
 watcom)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
 	;;
 xlc)
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -qversion"
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN $LIBS -qversion=verbose"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -qversion"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN $LIBS -qversion=verbose"
 	vv '|' "ld -V"
 	;;
 *)
 	test x"$ct" = x"untested" && $e "!!! detecting preprocessor failed"
 	ct=unknown
 	vv '|' "$CC --version"
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
-	vv '|' "$CC $CFLAGS $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -v conftest.c $LIBS"
+	vv '|' "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $NOWARN -V conftest.c $LIBS"
 	;;
 esac
 case $cm in
@@ -1368,6 +1559,9 @@ esac
 etd=" on $et"
 case $et in
 klibc)
+	cpp_define MKSH_NO_SIGSETJMP 1
+	cpp_define _setjmp setjmp
+	cpp_define _longjmp longjmp
 	: "${MKSH_UNLIMITED=1}"
 	;;
 unknown)
@@ -1453,6 +1647,8 @@ msc)
 	save_NOWARN="${ccpc}/w"
 	DOWARN="${ccpc}/WX"
 	;;
+quickc)
+	;;
 sunpro)
 	test x"$save_NOWARN" = x"" && save_NOWARN='-errwarn=%none'
 	ac_flags 0 errwarnnone "$save_NOWARN"
@@ -1505,7 +1701,7 @@ hpcc)
 	ac_flags 1 otwo +O2
 	phase=x
 	;;
-kencc|tcc|tendra)
+kencc|quickc|tcc|tendra)
 	# no special optimisation
 	;;
 sunpro)
@@ -1525,7 +1721,16 @@ xlc)
 	test 1 = $HAVE_CAN_OTHREE || ac_flags 1 otwo -O2
 	;;
 *)
-	ac_flags 1 otwo -O2
+	if test_n "$Cg"; then
+		ac_flags 1 ogee -Og
+		if test 1 = $HAVE_CAN_OGEE; then
+			HAVE_CAN_OTWO=1 # for below
+		else
+			ac_flags 1 otwo -O2
+		fi
+	else
+		ac_flags 1 otwo -O2
+	fi
 	test 1 = $HAVE_CAN_OTWO || ac_flags 1 optimise -O
 	;;
 esac
@@ -1551,13 +1756,13 @@ gcc)
 	# The following tests run with -Werror (gcc only) if possible
 	NOWARN=$DOWARN; phase=u
 	ac_flags 1 wnodeprecateddecls -Wno-deprecated-declarations
-	# mksh is not written in CFrustFrust!
+	# we do not even use CFrustFrust in MirBSD so don’t code in it…
 	ac_flags 1 no_eh_frame -fno-asynchronous-unwind-tables
 	ac_flags 1 fnostrictaliasing -fno-strict-aliasing
 	ac_flags 1 fstackprotectorstrong -fstack-protector-strong
 	test 1 = $HAVE_CAN_FSTACKPROTECTORSTRONG || \
 	    ac_flags 1 fstackprotectorall -fstack-protector-all
-	test $cm = dragonegg && case " $CC $CFLAGS $LDFLAGS " in
+	test $cm = dragonegg && case " $CC $CFLAGS $Cg $LDFLAGS " in
 	*\ -fplugin=*dragonegg*) ;;
 	*) ac_flags 1 fplugin_dragonegg -fplugin=dragonegg ;;
 	esac
@@ -1697,7 +1902,7 @@ test $ct = pcc && phase=u
 #
 # Compiler: check for stuff that only generates warnings
 #
-ac_test attribute_bounded '' 'for __attribute__((__bounded__))' <<-'EOF'
+ac_test attribute_bounded attribute_extension 0 'for __attribute__((__bounded__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	extern int thiswillneverbedefinedIhope(void);
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1718,7 +1923,7 @@ ac_test attribute_bounded '' 'for __attr
 	}
 	#endif
 EOF
-ac_test attribute_format '' 'for __attribute__((__format__))' <<-'EOF'
+ac_test attribute_format attribute_extension 0 'for __attribute__((__format__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	extern int thiswillneverbedefinedIhope(void);
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1733,7 +1938,7 @@ ac_test attribute_format '' 'for __attri
 	int main(int ac, char *av[]) { return (fprintf(stderr, "%s%d", *av, ac)); }
 	#endif
 EOF
-ac_test attribute_noreturn '' 'for __attribute__((__noreturn__))' <<-'EOF'
+ac_test attribute_noreturn attribute_extension 0 'for __attribute__((__noreturn__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	extern int thiswillneverbedefinedIhope(void);
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1746,7 +1951,7 @@ ac_test attribute_noreturn '' 'for __att
 	void fnord(void) { exit(0); }
 	#endif
 EOF
-ac_test attribute_pure '' 'for __attribute__((__pure__))' <<-'EOF'
+ac_test attribute_pure attribute_extension 0 'for __attribute__((__pure__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	extern int thiswillneverbedefinedIhope(void);
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1759,7 +1964,7 @@ ac_test attribute_pure '' 'for __attribu
 	int foo(const char *s) { return ((int)s[0]); }
 	#endif
 EOF
-ac_test attribute_unused '' 'for __attribute__((__unused__))' <<-'EOF'
+ac_test attribute_unused attribute_extension 0 'for __attribute__((__unused__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	extern int thiswillneverbedefinedIhope(void);
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1771,7 +1976,7 @@ ac_test attribute_unused '' 'for __attri
 	    __attribute__((__unused__))) { return (isatty(0)); }
 	#endif
 EOF
-ac_test attribute_used '' 'for __attribute__((__used__))' <<-'EOF'
+ac_test attribute_used attribute_extension 0 'for __attribute__((__used__))' <<-'EOF'
 	#if defined(__TenDRA__) || (defined(__GNUC__) && (__GNUC__ < 2))
 	extern int thiswillneverbedefinedIhope(void);
 	/* force a failure: TenDRA and gcc 1.42 have false positive here */
@@ -1833,15 +2038,23 @@ ac_test both_time_h '' 'whether <sys/tim
 	#include <sys/time.h>
 	#include <time.h>
 	#include <unistd.h>
-	int main(void) { struct tm tm; return ((int)sizeof(tm) + isatty(0)); }
+	int main(void) { struct timeval tv; return ((int)sizeof(tv) + isatty(0)); }
+EOF
+ac_header sys/select.h sys/types.h
+test "11" = "$HAVE_SYS_TIME_H$HAVE_SYS_SELECT_H" || HAVE_SELECT_TIME_H=1
+ac_test select_time_h '' 'whether <sys/time.h> and <sys/select.h> can both be included' <<-'EOF'
+	#include <sys/time.h>
+	#include <sys/select.h>
+	#include <unistd.h>
+	int main(void) { struct timeval tv; return ((int)sizeof(tv) + isatty(0)); }
 EOF
 ac_header sys/bsdtypes.h
 ac_header sys/file.h sys/types.h
 ac_header sys/mkdev.h sys/types.h
 ac_header sys/mman.h sys/types.h
 ac_header sys/param.h
+ac_header sys/ptem.h sys/types.h sys/stream.h
 ac_header sys/resource.h sys/types.h _time
-ac_header sys/select.h sys/types.h
 ac_header sys/sysmacros.h
 ac_header bstring.h
 ac_header grp.h sys/types.h
@@ -1892,16 +2105,6 @@ ac_test can_ucbints '!' can_inttypes 1 "
 	#include <stddef.h>
 	int main(int ac, char *av[]) { return ((u_int32_t)(size_t)*av + (int32_t)ac); }
 EOF
-ac_test can_int8type '!' stdint_h 1 "for standard 8-bit integer type" <<-'EOF'
-	#include <sys/types.h>
-	#include <stddef.h>
-	int main(int ac, char *av[]) { return ((uint8_t)(size_t)av[ac]); }
-EOF
-ac_test can_ucbint8 '!' can_int8type 1 "for UCB 8-bit integer type" <<-'EOF'
-	#include <sys/types.h>
-	#include <stddef.h>
-	int main(int ac, char *av[]) { return ((u_int8_t)(size_t)av[ac]); }
-EOF
 
 # only testn: added later below
 ac_testn sig_t <<-'EOF'
@@ -1920,7 +2123,7 @@ ac_testn sighandler_t '!' sig_t 0 <<-'EO
 	int main(void) { return (foo == (sighandler_t)0); }
 EOF
 if test 1 = $HAVE_SIGHANDLER_T; then
-	add_cppflags -Dsig_t=sighandler_t
+	cpp_define sig_t sighandler_t
 	HAVE_SIG_T=1
 fi
 
@@ -1932,11 +2135,11 @@ ac_testn __sighandler_t '!' sig_t 0 <<-'
 	int main(void) { return (foo == (__sighandler_t)0); }
 EOF
 if test 1 = $HAVE___SIGHANDLER_T; then
-	add_cppflags -Dsig_t=__sighandler_t
+	cpp_define sig_t __sighandler_t
 	HAVE_SIG_T=1
 fi
 
-test 1 = $HAVE_SIG_T || add_cppflags -Dsig_t=nosig_t
+test 1 = $HAVE_SIG_T || cpp_define sig_t nosig_t
 ac_cppflags SIG_T
 
 #
@@ -1961,26 +2164,26 @@ else
 EOF
 	case $cm in
 	llvm)
-		v "$CC $CFLAGS $CPPFLAGS $NOWARN -emit-llvm -c conftest.c" || fv=0
+		v "$CC $CFLAGS $Cg $CPPFLAGS $NOWARN -emit-llvm -c conftest.c" || fv=0
 		rmf $tfn.s
 		test $fv = 0 || v "llvm-link -o - conftest.o | opt $optflags | llc -o $tfn.s" || fv=0
-		test $fv = 0 || v "$CC $CFLAGS $LDFLAGS -o $tcfn $tfn.s $LIBS $ccpr"
+		test $fv = 0 || v "$CC $CFLAGS $Cg $LDFLAGS -o $tcfn $tfn.s $LIBS $ccpr"
 		;;
 	dragonegg)
-		v "$CC $CFLAGS $CPPFLAGS $NOWARN -S -flto conftest.c" || fv=0
+		v "$CC $CFLAGS $Cg $CPPFLAGS $NOWARN -S -flto conftest.c" || fv=0
 		test $fv = 0 || v "mv conftest.s conftest.ll"
 		test $fv = 0 || v "llvm-as conftest.ll" || fv=0
 		rmf $tfn.s
 		test $fv = 0 || v "llvm-link -o - conftest.bc | opt $optflags | llc -o $tfn.s" || fv=0
-		test $fv = 0 || v "$CC $CFLAGS $LDFLAGS -o $tcfn $tfn.s $LIBS $ccpr"
+		test $fv = 0 || v "$CC $CFLAGS $Cg $LDFLAGS -o $tcfn $tfn.s $LIBS $ccpr"
 		;;
 	combine)
-		v "$CC $CFLAGS $CPPFLAGS $LDFLAGS -fwhole-program --combine $NOWARN -o $tcfn conftest.c $LIBS $ccpr"
+		v "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS -fwhole-program --combine $NOWARN -o $tcfn conftest.c $LIBS $ccpr"
 		;;
 	lto|normal)
 		cm=normal
-		v "$CC $CFLAGS $CPPFLAGS $NOWARN -c conftest.c" || fv=0
-		test $fv = 0 || v "$CC $CFLAGS $LDFLAGS -o $tcfn conftest.o $LIBS $ccpr"
+		v "$CC $CFLAGS $Cg $CPPFLAGS $NOWARN -c conftest.c" || fv=0
+		test $fv = 0 || v "$CC $CFLAGS $Cg $LDFLAGS -o $tcfn conftest.o $LIBS $ccpr"
 		;;
 	esac
 	test -f $tcfn || fv=0
@@ -2006,8 +2209,8 @@ ac_testn _sys_errlist '!' sys_errlist 0
 	int main(void) { return (*_sys_errlist[_sys_nerr - 1] + isatty(0)); }
 EOF
 if test 1 = "$HAVE__SYS_ERRLIST"; then
-	add_cppflags -Dsys_nerr=_sys_nerr
-	add_cppflags -Dsys_errlist=_sys_errlist
+	cpp_define sys_nerr _sys_nerr
+	cpp_define sys_errlist _sys_errlist
 	HAVE_SYS_ERRLIST=1
 fi
 ac_cppflags SYS_ERRLIST
@@ -2026,7 +2229,7 @@ for what in name list; do
 	EOF
 	eval uwhat_v=\$HAVE__SYS_SIG$uwhat
 	if test 1 = "$uwhat_v"; then
-		add_cppflags -Dsys_sig$what=_sys_sig$what
+		cpp_define sys_sig$what _sys_sig$what
 		eval HAVE_SYS_SIG$uwhat=1
 	fi
 	ac_cppflags SYS_SIG$uwhat
@@ -2069,14 +2272,17 @@ EOF
 
 ac_test rlim_t rlimit 0 <<-'EOF'
 	#include <sys/types.h>
-	#if HAVE_BOTH_TIME_H
+	#if HAVE_BOTH_TIME_H && HAVE_SELECT_TIME_H
 	#include <sys/time.h>
 	#include <time.h>
-	#elif HAVE_SYS_TIME_H
+	#elif HAVE_SYS_TIME_H && HAVE_SELECT_TIME_H
 	#include <sys/time.h>
 	#elif HAVE_TIME_H
 	#include <time.h>
 	#endif
+	#if HAVE_SYS_SELECT_H
+	#include <sys/select.h>
+	#endif
 	#if HAVE_SYS_RESOURCE_H
 	#include <sys/resource.h>
 	#endif
@@ -2122,6 +2328,7 @@ ac_test memmove <<-'EOF'
 	}
 EOF
 
+: "${HAVE_MKNOD=0}"
 ac_test mknod '' 'if to use mknod(), makedev() and friends' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
@@ -2158,6 +2365,13 @@ ac_test nice <<-'EOF'
 	int main(void) { return (nice(4)); }
 EOF
 
+ac_test rename <<-'EOF'
+	#include <fcntl.h>
+	#include <stdio.h>
+	#include <unistd.h>
+	int main(int ac, char *av[]) { return (rename(*av, av[ac - 1])); }
+EOF
+
 ac_test revoke <<-'EOF'
 	#include <sys/types.h>
 	#if HAVE_LIBUTIL_H
@@ -2181,20 +2395,20 @@ EOF
 
 ac_test select <<-'EOF'
 	#include <sys/types.h>
-	#if HAVE_BOTH_TIME_H
+	#if HAVE_BOTH_TIME_H && HAVE_SELECT_TIME_H
 	#include <sys/time.h>
 	#include <time.h>
-	#elif HAVE_SYS_TIME_H
+	#elif HAVE_SYS_TIME_H && HAVE_SELECT_TIME_H
 	#include <sys/time.h>
 	#elif HAVE_TIME_H
 	#include <time.h>
 	#endif
-	#if HAVE_SYS_BSDTYPES_H
-	#include <sys/bsdtypes.h>
-	#endif
 	#if HAVE_SYS_SELECT_H
 	#include <sys/select.h>
 	#endif
+	#if HAVE_SYS_BSDTYPES_H
+	#include <sys/bsdtypes.h>
+	#endif
 	#if HAVE_BSTRING_H
 	#include <bstring.h>
 	#endif
@@ -2227,6 +2441,23 @@ ac_test setgroups setresugid 0 <<-'EOF'
 	int main(void) { gid_t gid = 0; return (setgroups(0, &gid)); }
 EOF
 
+ac_test sigaction <<-'EOF'
+	#define MKSH_INCLUDES_ONLY
+	#include "sh.h"
+	int main(int ac, char *av[]) {
+		struct sigaction sa, osa;
+		ssize_t n;
+
+		memset(&sa, 0, sizeof(sa));
+		sigemptyset(&sa.sa_mask);
+		sa.sa_handler = SIG_IGN;
+		sigaction(ac, &sa, &osa);
+		n = write(1, *av, strlen(*av));
+		sigaction(ac, &osa, NULL);
+		return ((size_t)n != strlen(*av));
+	}
+EOF
+
 if test x"$et" = x"klibc"; then
 
 	ac_testn __rt_sigsuspend '' 'whether klibc uses RT signals' <<-'EOF'
@@ -2255,7 +2486,7 @@ EOF
 
 	if test "000" = "$HAVE___RT_SIGSUSPEND$HAVE___SIGSUSPEND_S$HAVE___SIGSUSPEND_XXS"; then
 		# no usable sigsuspend(), use pause() *ugh*
-		add_cppflags -DMKSH_NO_SIGSUSPEND
+		cpp_define MKSH_NO_SIGSUSPEND 1
 	fi
 fi
 
@@ -2276,6 +2507,11 @@ ac_test strlcpy <<-'EOF'
 	    (size_t)ac)); }
 EOF
 
+ac_test strstr <<-'EOF'
+	#include <string.h>
+	int main(int ac, char *av[]) { return (!strstr(av[ac - 1], "meow")); }
+EOF
+
 #
 # check headers for declarations
 #
@@ -2303,16 +2539,30 @@ ac_test sys_siglist_decl sys_siglist 0 '
 	int main(void) { return (sys_siglist[0][0] + isatty(0)); }
 EOF
 
-ac_test st_mtim '' 'for struct stat.st_mtim.tv_nsec' <<-'EOF'
+ac_testn st_mtimensec '' 'for struct stat.st_mtimensec' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
-	int main(void) { struct stat sb; return (sizeof(sb.st_mtim.tv_nsec)); }
+	int main(void) { struct stat sb; return (sizeof(sb.st_mtimensec)); }
 EOF
-ac_test st_mtimensec '!' st_mtim 0 'for struct stat.st_mtimensec' <<-'EOF'
+ac_testn st_mtimespec '!' st_mtimensec 0 'for struct stat.st_mtimespec.tv_nsec' <<-'EOF'
 	#define MKSH_INCLUDES_ONLY
 	#include "sh.h"
-	int main(void) { struct stat sb; return (sizeof(sb.st_mtimensec)); }
+	int main(void) { struct stat sb; return (sizeof(sb.st_mtimespec.tv_nsec)); }
 EOF
+if test 1 = "$HAVE_ST_MTIMESPEC"; then
+	cpp_define st_mtimensec st_mtimespec.tv_nsec
+	HAVE_ST_MTIMENSEC=1
+fi
+ac_testn st_mtim '!' st_mtimensec 0 'for struct stat.st_mtim.tv_nsec' <<-'EOF'
+	#define MKSH_INCLUDES_ONLY
+	#include "sh.h"
+	int main(void) { struct stat sb; return (sizeof(sb.st_mtim.tv_nsec)); }
+EOF
+if test 1 = "$HAVE_ST_MTIM"; then
+	cpp_define st_mtimensec st_mtim.tv_nsec
+	HAVE_ST_MTIMENSEC=1
+fi
+ac_cppflags ST_MTIMENSEC
 
 #
 # other checks
@@ -2370,7 +2620,7 @@ fi
 test 0 = $HAVE_SYS_SIGNAME && if ac_testinit cpp_dd '' \
     'checking if the C Preprocessor supports -dD'; then
 	echo '#define foo bar' >conftest.c
-	vv ']' "$CPP $CFLAGS $CPPFLAGS $NOWARN -dD conftest.c >x"
+	vv ']' "$CPP $CFLAGS $Cg $CPPFLAGS $NOWARN -dD conftest.c >x"
 	grep '#define foo bar' x >/dev/null 2>&1 && fv=1
 	rmf conftest.c x vv.out
 	ac_testdone
@@ -2413,9 +2663,9 @@ if test 0 = $HAVE_SYS_SIGNAME; then
 #endif
 int
 mksh_cfg= cfg_NSIG
-;' >conftest.c
+;' | cat_h_blurb >conftest.c
 	# GNU sed 2.03 segfaults when optimising this to sed -n
-	NSIG=`vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
+	NSIG=`vq "$CPP $CFLAGS $Cg $CPPFLAGS $NOWARN conftest.c" | \
 	    grep -v '^#' | \
 	    sed '/mksh_cfg.*= *$/{
 		N
@@ -2437,7 +2687,7 @@ mksh_cfg= cfg_NSIG
 	sigs="$sigs XCPU XFSZ INFO WINCH EMT IO DIL LOST PWR SAK CLD IOT STKFLT"
 	sigs="$sigs ABND DCE DUMP IOERR TRACE DANGER THCONT THSTOP RESV UNUSED"
 	test 1 = $HAVE_CPP_DD && test $NSIG -gt 1 && sigs="$sigs "`vq \
-	    "$CPP $CFLAGS $CPPFLAGS $NOWARN -dD conftest.c" | \
+	    "$CPP $CFLAGS $Cg $CPPFLAGS $NOWARN -dD conftest.c" | \
 	    grep '[	 ]SIG[A-Z0-9][A-Z0-9]*[	 ]' | \
 	    sed 's/^.*[	 ]SIG\([A-Z0-9][A-Z0-9]*\)[	 ].*$/\1/' | sort`
 	test $NSIG -gt 1 || sigs=
@@ -2451,7 +2701,7 @@ mksh_cfg= cfg_NSIG
 		echo mksh_cfg= SIG$name >>conftest.c
 		echo ';' >>conftest.c
 		# GNU sed 2.03 croaks on optimising this, too
-		vq "$CPP $CFLAGS $CPPFLAGS $NOWARN conftest.c" | \
+		vq "$CPP $CFLAGS $Cg $CPPFLAGS $NOWARN conftest.c" | \
 		    grep -v '^#' | \
 		    sed '/mksh_cfg.*= *$/{
 			N
@@ -2475,13 +2725,13 @@ mksh_cfg= cfg_NSIG
 fi
 
 if test 1 = "$MKSH_UNLIMITED"; then
-	add_cppflags -DMKSH_UNLIMITED
+	cpp_define MKSH_UNLIMITED 1
 else
 	MKSH_UNLIMITED=0
 fi
 
 if test 1 = "$USE_PRINTF_BUILTIN"; then
-	add_cppflags -DMKSH_PRINTF_BUILTIN
+	cpp_define MKSH_PRINTF_BUILTIN 1
 else
 	USE_PRINTF_BUILTIN=0
 fi
@@ -2491,7 +2741,7 @@ addsrcs USE_PRINTF_BUILTIN printf.c
 addsrcs '!' MKSH_UNLIMITED ulimit.c
 
 test 1 = "$HAVE_CAN_VERB" && CFLAGS="$CFLAGS -verbose"
-add_cppflags -DMKSH_BUILD_R=593
+cpp_define MKSH_BUILD_R 599
 
 $e $bi$me: Finished configuration testing, now producing output.$ao
 
@@ -2500,16 +2750,16 @@ objs=
 sp=
 case $tcfn in
 a.exe|conftest.exe)
-	mkshexe=$tfn.exe
-	add_cppflags -DMKSH_EXE_EXT
+	buildoutput=$tfn.exe
+	cpp_define MKSH_EXE_EXT 1
 	;;
 *)
-	mkshexe=$tfn
+	buildoutput=$tfn
 	;;
 esac
 case $curdir in
-*\ *)	mkshshebang="#!./$mkshexe" ;;
-*)	mkshshebang="#!$curdir/$mkshexe" ;;
+*\ *)	mkshshebang="#!./$buildoutput" ;;
+*)	mkshshebang="#!$curdir/$buildoutput" ;;
 esac
 cat >test.sh <<-EOF
 	$mkshshebang
@@ -2519,7 +2769,7 @@ cat >test.sh <<-EOF
 	*) exit 1 ;;
 	esac
 	set -A check_categories -- $check_categories
-	pflag='$curdir/$mkshexe'
+	pflag='$curdir/$buildoutput'
 	sflag='$srcdir/check.t'
 	usee=0 useU=0 Pflag=0 Sflag=0 uset=0 vflag=1 xflag=0
 	while getopts "C:e:fPp:QSs:t:U:v" ch; do case \$ch {
@@ -2574,7 +2824,7 @@ cat >test.sh <<-EOF
 		args[\${#args[*]}]=\$TMPDIR
 	fi
 	print Testing mksh for conformance:
-	grep -F -e 'KSH R' -e Mir''OS: "\$sflag" | sed '/KSH/s/^./&           /'
+	grep -e 'KSH R' -e Mir''OS: "\$sflag" | sed '/KSH/s/^./&           /'
 	print "This shell is actually:\\n\\t\$KSH_VERSION"
 	print 'test.sh built for mksh $dstversion'
 	cstr='\$os = defined \$^O ? \$^O : "unknown";'
@@ -2634,7 +2884,7 @@ for file in $SRCS; do
 	op=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1./'`
 	test -f $file || file=$srcdir/$file
 	files="$files$sp$file"
-	echo "$CC $CFLAGS $CPPFLAGS $emitbc $file || exit 1" >>Rebuild.sh
+	echo "$CC $CFLAGS $Cg $CPPFLAGS $emitbc $file || exit 1" >>Rebuild.sh
 	if test $cm = dragonegg; then
 		echo "mv ${op}s ${op}ll" >>Rebuild.sh
 		echo "llvm-as ${op}ll || exit 1" >>Rebuild.sh
@@ -2654,8 +2904,8 @@ dragonegg|llvm)
 	lobjs=$objs
 	;;
 esac
-echo tcfn=$mkshexe >>Rebuild.sh
-echo "$CC $CFLAGS $LDFLAGS -o \$tcfn $lobjs $LIBS $ccpr" >>Rebuild.sh
+echo tcfn=$buildoutput >>Rebuild.sh
+echo "$CC $CFLAGS $Cg $LDFLAGS -o \$tcfn $lobjs $LIBS $ccpr" >>Rebuild.sh
 echo "test -f \$tcfn || exit 1; $SIZE \$tcfn" >>Rebuild.sh
 if test $cm = makefile; then
 	extras='emacsfn.h exprtok.h rlimits.opt sh.h sh_flags.opt ulimits.opt var_spec.h'
@@ -2668,9 +2918,9 @@ if test $cm = makefile; then
 			srcfile=$srcdir/$file; BUILDSH_RUN_GENOPT=1; . $srcdir/Build.sh"
 	done
 	cat >Makefrag.inc <<EOF
-# Makefile fragment for building mksh $dstversion
+# Makefile fragment for building $whatlong $dstversion
 
-PROG=		$mkshexe
+PROG=		$buildoutput
 MAN=		mksh.1
 SRCS=		$SRCS
 SRCS_FP=	$files
@@ -2680,7 +2930,7 @@ NONSRCS_INST=	dot.mkshrc \$(MAN)
 NONSRCS_NOINST=	Build.sh Makefile Rebuild.sh check.pl check.t test.sh
 CC=		$CC
 CPPFLAGS=	$CPPFLAGS
-CFLAGS=		$CFLAGS
+CFLAGS=		$CFLAGS $Cg
 LDFLAGS=	$LDFLAGS
 LIBS=		$LIBS
 
@@ -2714,17 +2964,17 @@ for file in $optfiles; do
 	do_genopt "$srcdir/$file" || exit 1
 done
 if test $cm = combine; then
-	objs="-o $mkshexe"
+	objs="-o $buildoutput"
 	for file in $SRCS; do
 		test -f $file || file=$srcdir/$file
 		objs="$objs $file"
 	done
 	emitbc="-fwhole-program --combine"
-	v "$CC $CFLAGS $CPPFLAGS $LDFLAGS $emitbc $objs $LIBS $ccpr"
+	v "$CC $CFLAGS $Cg $CPPFLAGS $LDFLAGS $emitbc $objs $LIBS $ccpr"
 elif test 1 = $pm; then
 	for file in $SRCS; do
 		test -f $file || file=$srcdir/$file
-		v "$CC $CFLAGS $CPPFLAGS $emitbc $file" &
+		v "$CC $CFLAGS $Cg $CPPFLAGS $emitbc $file" &
 	done
 	wait
 else
@@ -2732,7 +2982,7 @@ else
 		test $cm = dragonegg && \
 		    op=`echo x"$file" | sed 's/^x\(.*\)\.c$/\1./'`
 		test -f $file || file=$srcdir/$file
-		v "$CC $CFLAGS $CPPFLAGS $emitbc $file" || exit 1
+		v "$CC $CFLAGS $Cg $CPPFLAGS $emitbc $file" || exit 1
 		if test $cm = dragonegg; then
 			v "mv ${op}s ${op}ll"
 			v "llvm-as ${op}ll" || exit 1
@@ -2745,8 +2995,8 @@ dragonegg|llvm)
 	v "llvm-link -o - $objs | opt $optflags | llc -o $tfn.s"
 	;;
 esac
-tcfn=$mkshexe
-test $cm = combine || v "$CC $CFLAGS $LDFLAGS -o $tcfn $lobjs $LIBS $ccpr"
+tcfn=$buildoutput
+test $cm = combine || v "$CC $CFLAGS $Cg $LDFLAGS -o $tcfn $lobjs $LIBS $ccpr"
 test -f $tcfn || exit 1
 test 1 = $r || v "$NROFF -mdoc <'$srcdir/lksh.1' >lksh.cat1" || rmf lksh.cat1
 test 1 = $r || v "$NROFF -mdoc <'$srcdir/mksh.1' >mksh.cat1" || rmf mksh.cat1
@@ -2760,7 +3010,7 @@ $e Installing the shell:
 $e "# $i -c -s -o root -g bin -m 555 $tfn /bin/$tfn"
 if test $legacy = 0; then
 	$e "# grep -x /bin/$tfn /etc/shells >/dev/null || echo /bin/$tfn >>/etc/shells"
-	$e "# $i -c -o root -g bin -m 444 dot.mkshrc /usr/share/doc/mksh/examples/"
+	$e "# $i -c -o root -g bin -m 444 ${srcdisp}dot.mkshrc /usr/share/doc/mksh/examples/"
 fi
 $e
 $e Installing the manual:
@@ -2777,12 +3027,12 @@ if test -f mksh.cat1; then
 	    "/usr/share/man/cat1/mksh.0"
 	$e or
 fi
-$e "# $i -c -o root -g bin -m 444 lksh.1 mksh.1 /usr/share/man/man1/"
+$e "# $i -c -o root -g bin -m 444 ${srcdisp}lksh.1 ${srcdisp}mksh.1 /usr/share/man/man1/"
 $e
 $e Run the regression test suite: ./test.sh
-$e Please also read the sample file dot.mkshrc and the fine manual.
+$e Please also read the sample file ${srcdisp}dot.mkshrc and the fine manual.
 test -f FAQ.htm || \
-    $e Run FAQ2HTML.sh and place FAQ.htm into a suitable location as well.
+    $e Run ${srcdisp}FAQ2HTML.sh and place FAQ.htm into a suitable location as well.
 exit 0
 
 : <<'EOD'
@@ -2802,7 +3052,7 @@ LIBS				default empty; added after sourc
 NOWARN				-Wno-error or similar
 NROFF				default: nroff
 TARGET_OS			default: $(uname -s || uname)
-TARGET_OSREV			[QNX] default: $(uname -r)
+TARGET_OSREV			default: $(uname -r) [only needed on some OS]
 
 ==== feature selectors ====
 MKSH_UNLIMITED			1 to omit ulimit builtin completely
@@ -2819,6 +3069,7 @@ KSH_VERSIONNAME_VENDOR_EXT	when patching
 MKSHRC_PATH			"~/.mkshrc" (do not change)
 MKSH_A4PB			force use of arc4random_pushb
 MKSH_ASSUME_UTF8		(0=disabled, 1=enabled; default: unset)
+				note will vanish with full locale tracking!
 MKSH_BINSHPOSIX			if */sh or */-sh, enable set -o posix
 MKSH_BINSHREDUCED		if */sh or */-sh, enable set -o sh
 MKSH_CLS_STRING			KSH_ESC_STRING "[;H" KSH_ESC_STRING "[J"
--- mksh-59c.orig/FAQ2HTML.sh
+++ mksh-59c/FAQ2HTML.sh
@@ -1,5 +1,5 @@
 #!/bin/sh
-rcsid='$MirOS: src/bin/mksh/FAQ2HTML.sh,v 1.2 2020/10/31 04:17:36 tg Exp $'
+rcsid='$MirOS: src/bin/mksh/FAQ2HTML.sh,v 1.4 2021/07/27 02:36:55 tg Exp $'
 #-
 # Copyright © 2020
 #	mirabilos <m@mirbsd.org>
@@ -25,16 +25,16 @@ LC_ALL=C; LANGUAGE=C
 export LC_ALL; unset LANGUAGE
 nl='
 '
-srcdir=$(dirname "$0")
+srcdir=`dirname "$0" 2>/dev/null`
 
 p=--posix
 sed $p -e q </dev/null >/dev/null 2>&1 || p=
 
 v=$1
 if test -z "$v"; then
-	v=$(sed $p -n '/^#define MKSH_VERSION "\(.*\)"$/s//\1/p' "$srcdir"/sh.h)
+	v=`sed $p -n '/^#define MKSH_VERSION "\(.*\)"$/s//\1/p' "$srcdir"/sh.h`
 fi
-src_id=$(sed $p -n '/^RCSID: /s///p' "$srcdir"/mksh.faq)
+src_id=`sed $p -n '/^RCSID: /s///p' "$srcdir"/mksh.faq`
 # sanity check
 case $src_id in
 *"$nl"*)
@@ -109,7 +109,7 @@ cat <<EOF
  }
  /*]]>*/--></style>
 </head><body>
-<p>Note: Links marked like <a href="irc://chat.freenode.net/!/bin/mksh">this
+<p>Note: Links marked like <a href="irc://irc.mirbsd.org/!/bin/mksh">this
  one to the mksh IRC channel</a> connect to external resources.</p>
 <p>⚠ <b>Notice:</b> the website will have <a
  href="http://www.mirbsd.org/mksh-faq.htm">the latest version of the
--- mksh-59c.orig/check.pl
+++ mksh-59c/check.pl
@@ -1,8 +1,8 @@
-# $MirOS: src/bin/mksh/check.pl,v 1.51 2020/06/22 17:10:59 tg Exp $
+# $MirOS: src/bin/mksh/check.pl,v 1.55 2021/10/03 22:45:34 tg Exp $
 # $OpenBSD: th,v 1.1 2013/12/02 20:39:44 millert Exp $
 #-
 # Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
-#		2012, 2013, 2014, 2015, 2017
+#		2012, 2013, 2014, 2015, 2017, 2021
 #	mirabilos <m@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -40,6 +40,19 @@
 #	is expected to produce "hi*" (no trailing newline) on standard output,
 #	"+ echo hi*\n+false\n" on standard error, and an exit code of 1.
 #
+# The test-program is invoked with a new environment vector by default which
+# is composed of the following parameters from the inherited environ if set:
+#	HOME, LD_LIBRARY_PATH, LOCPATH, LOGNAME,
+#	PATH, PERLIO, SHELL, UNIXMODE, UNIXROOT, USER
+# Additionally, some parameters are set as follows (without the quotes):
+#	CYGWIN to "nodosfilewarning"
+#	ENV to "/nonexistant"
+#	LANG to "C"
+#	__perlname to $^X (perlexe)
+# Any -e option arguments are added, or, if no equals sign is given, removed.
+# Each test's env-setup (see below) is processed in the same way affecting
+# the environment of that test. Finally, in the per-test environ, __progname
+# is set to the -p argument or (if -P) its first word.
 #
 # Format of test files:
 # - blank lines and lines starting with # are ignored
@@ -65,22 +78,12 @@
 #	perl-cleanup		m	Value is a perl script which is executed
 #					just after the test is run. Try to
 #					avoid using this...
-#	env-setup		M	Value is a list of NAME=VALUE elements
-#					which are put in the environment before
-#					the test is run. If the =VALUE is
-#					missing, NAME is removed from the
-#					environment. Programs are run with
-#					the following minimal environment:
-#					    HOME, LD_LIBRARY_PATH, LOCPATH,
-#					    LOGNAME, PATH, SHELL, UNIXMODE,
-#					    UNIXROOT, USER
-#					(values taken from the environment of
-#					the test harness).
-#					CYGWIN is set to nodosfilewarning.
-#					ENV is set to /nonexistant.
-#					__progname is set to the -p argument.
-#					__perlname is set to $^X (perlexe).
-#					@utflocale@ is substituted from -U.
+#	env-setup		M	Value is a list of elements that are
+#					removed from the per-test environment
+#					(if no equals sign present) or added
+#					to it if of the NAME=VALUE form, after
+#					substituting @utflocale@ for -U option.
+#					For more about test environ see above.
 #	file-setup		mps	Used to create files, directories
 #					and symlinks. First word is either
 #					file, dir or symlink; second word is
@@ -198,7 +201,7 @@ Usage: $prog [-Pv] [-C cat] [-e e=v] [-p
 		scanned for test files (which end in .t).
 	-T dir	Use dir instead of /tmp to hold temporary files
 	-t t	Use t as default time limit for tests (default is unlimited)
-	-U lcl	Use lcl as UTF-8 locale (e.g. C.UTF-8) instead of the default
+	-U lcl	Specify UTF-8 locale (e.g. en_US.UTF-8) instead of the default
 	-v	Verbose mode: print reason test failed.
 	name	specifies the name of the test(s) to run; if none are
 		specified, all tests are run.
@@ -259,7 +262,7 @@ $verbose = defined $opt_v && $opt_v;
 $is_ebcdic = defined $opt_E && $opt_E;
 $test_set = $opt_s;
 $temp_base = $opt_T || "/tmp";
-$utflocale = $opt_U || (($os eq "hpux") ? "en_US.utf8" : "en_US.UTF-8");
+$utflocale = $opt_U || (($os eq "hpux") ? "en_US.utf8" : ($os eq "darwin") ? "UTF-8" : "C.UTF-8");
 if (defined $opt_t) {
     die "$prog: bad -t argument (should be number > 0): $opt_t\n"
 	if $opt_t !~ /^\d+$/ || $opt_t <= 0;
@@ -297,23 +300,26 @@ foreach $env (('HOME', 'LD_LIBRARY_PATH'
 }
 $new_env{'CYGWIN'} = 'nodosfilewarning';
 $new_env{'ENV'} = '/nonexistant';
+$new_env{'LANG'} = 'C';
 
-if (($os eq 'VMS') || ($Config{perlpath} =~ m/$Config{_exe}$/i)) {
-	$new_env{'__perlname'} = $Config{perlpath};
-} else {
-	$new_env{'__perlname'} = $Config{perlpath} . $Config{_exe};
+$pn = $Config{perlpath};
+if ($pn ne '' and $os ne 'VMS' and $pn !~ m/$Config{_exe}$/i) {
+	$pn .= $Config{_exe};
+}
+if (($pn eq '' or ! -f $pn or ! -x $pn) and -f $^X and -x $^X) {
+	$pn = $^X;
 }
-$new_env{'__perlname'} = $^X if ($new_env{'__perlname'} eq '') and -f $^X and -x $^X;
-if ($new_env{'__perlname'} eq '') {
-	foreach $pathelt (split /:/,$ENV{'PATH'}) {
+if ($pn eq '' or ! -f $pn or ! -x $pn) {
+	foreach $pathelt (split /:/, $ENV{'PATH'}) {
 		chomp($pathelt = `pwd`) if $pathelt eq '';
 		my $x = $pathelt . '/' . $^X;
 		next unless -f $x and -x $x;
-		$new_env{'__perlname'} = $x;
+		$pn = $x;
 		last;
 	}
 }
-$new_env{'__perlname'} = $^X if ($new_env{'__perlname'} eq '');
+$pn = $^X if ($pn eq '');
+$new_env{'__perlname'} = $pn;
 
 if (defined $opt_e) {
     # XXX need a way to allow many -e arguments...
--- mksh-59c.orig/check.t
+++ mksh-59c/check.t
@@ -1,9 +1,9 @@
-# $MirOS: src/bin/mksh/check.t,v 1.853 2020/10/31 03:53:03 tg Exp $
+# $MirOS: src/bin/mksh/check.t,v 1.883 2021/10/10 21:33:50 tg Exp $
 # -*- mode: sh -*-
 #-
 # Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
 #	      2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
-#	      2019, 2020
+#	      2019, 2020, 2021
 #	mirabilos <m@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -31,7 +31,7 @@
 # (2013/12/02 20:39:44) http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/regress/bin/ksh/?sortby=date
 
 expected-stdout:
-	KSH R59 2020/10/31
+	KSH R59 2021/10/15
 description:
 	Check base version of full shell
 stdin:
@@ -136,8 +136,36 @@ stdin:
 	print '#!'"$__progname"'\necho tf' >lq
 	chmod +x lq
 	./lq
+	echo = $?
 expected-stdout:
 	tf
+	= 0
+---
+name: selftest-exec-perl
+description:
+	Ensure we can run perl scriptlets in tests as well
+stdin:
+	print '#!'"$__perlname"'\nprint 3x"3"."\\n";' >lq
+	chmod +x lq
+	./lq
+	echo = $?
+expected-stdout:
+	333
+	= 0
+---
+name: selftest-exec-a
+description:
+	Ensure using 'exec -a' to change argv[0] works
+file-setup: file 644 "pass"
+	print -r -- "fail, args:"
+	i=-1
+	for x in "$0" "$@"; do
+		print -r -- "$((++i))<$x>"
+	done
+stdin:
+	exec -a -print "$__progname" pass '\u20AC'
+expected-stdout:
+	pass €
 ---
 name: selftest-env
 description:
@@ -150,9 +178,8 @@ name: selftest-direct-builtin-call
 description:
 	Check that direct builtin calls work
 stdin:
-	ln -s "$__progname" cat || cp "$__progname" cat
-	ln -s "$__progname" echo || cp "$__progname" echo
-	./echo -c 'echo  foo' | ./cat -u
+	ln -s "$__progname" echo 2>/dev/null || cp "$__progname" echo
+	./echo -c 'echo  foo'
 expected-stdout:
 	-c echo  foo
 ---
@@ -176,6 +203,25 @@ stdin:
 expected-stdout:
 	;
 ---
+name: selftest-tools
+description:
+	Check that relevant tools work as expected. If not, e.g. on SerenityOS,
+	install better tools from ports and prepend /usr/local/bin to $PATH.
+stdin:
+	echo foobarbaz | grep bar
+	echo = $?
+	echo abc | sed y/ac/AC/
+	echo = $?
+	echo abc | tr ac AC
+	echo = $?
+expected-stdout:
+	foobarbaz
+	= 0
+	AbC
+	= 0
+	AbC
+	= 0
+---
 name: selftest-tty-absent
 description:
 	Check that a controlling tty is not present as regress:no-ctty was used
@@ -1402,10 +1448,10 @@ name: cd-pe
 description:
 	Check package for cd -Pe
 need-pass: no
-# the mv command fails on Cygwin and z/OS
+# the mv command fails on Cygwin, LynxOS 3.0, z/OS
 # Hurd aborts the testsuite (permission denied)
 # QNX does not find subdir to cd into
-category: !os:cygwin,!os:gnu,!os:midipix,!os:msys,!os:nto,!os:os390,!nosymlink
+category: !os:cygwin,!os:gnu,!os:lynxos,!os:midipix,!os:msys,!os:nto,!os:os390,!nosymlink
 file-setup: file 644 "x"
 	mkdir noread noread/target noread/target/subdir
 	ln -s noread link
@@ -2012,7 +2058,7 @@ expected-stdout:
 name: eglob-bad-1
 description:
 	Check that globbing isn't done when glob has syntax error
-category: !os:cygwin,!os:midipix,!os:msys,!os:os2
+category: !os:cygwin,!os:lynxos,!os:midipix,!os:msys,!os:os2
 file-setup: file 644 "@(a[b|)c]foo"
 stdin:
 	echo @(a[b|)c]*
@@ -3073,7 +3119,7 @@ description:
 	Check high-bit7 separators work
 stdin:
 	u=ä
-	tr a-z A-Z <<-…
+	tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ <<-…
 		m${u}h
 	…
 	echo ok
@@ -4144,7 +4190,7 @@ description:
 category: stdout-ed
 need-ctty: yes
 need-pass: no
-arguments: !-i!
+arguments: !-ie!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
 	PS1=X
@@ -4168,7 +4214,7 @@ description:
 category: stdout-ed
 need-ctty: yes
 need-pass: no
-arguments: !-i!
+arguments: !-ie!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
 	PS1=X
@@ -4200,7 +4246,7 @@ description:
 category: stdout-ed
 need-ctty: yes
 need-pass: no
-arguments: !-i!
+arguments: !-ie!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
 	PS1=X
@@ -4233,7 +4279,7 @@ description:
 category: !no-stderr-ed
 need-ctty: yes
 need-pass: no
-arguments: !-i!
+arguments: !-ie!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
 	PS1=X
@@ -4255,7 +4301,7 @@ description:
 category: !no-stderr-ed
 need-ctty: yes
 need-pass: no
-arguments: !-i!
+arguments: !-ie!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
 	PS1=X
@@ -4284,7 +4330,7 @@ description:
 category: !no-stderr-ed
 need-ctty: yes
 need-pass: no
-arguments: !-i!
+arguments: !-ie!
 env-setup: !ENV=./Env!HISTFILE=hist.file!
 file-setup: file 644 "Env"
 	PS1=X
@@ -4786,7 +4832,7 @@ description:
 	'emulate sh' zsh has extra fields in
 	- a5ins (IFS_NWS unquoted $*)
 	- b5ins, matching mksh’s
-	!!WARNING!! more to come: http://austingroupbugs.net/view.php?id=888
+	!!WARNING!! more to come: https://www.austingroupbugs.net/view.php?id=888
 stdin:
 	"$__progname" -c 'pfb() { for s_arg in "$@"; do print -r -- "[$s_arg]"; done; }; pfn() { for s_arg in "$@"; do print -r -- "<$s_arg>"; done; };
 		IFS=; set -- "" 2 ""; pfb $*; x=$*; pfn "$x"'
@@ -4936,7 +4982,7 @@ expected-stdout:
 ---
 name: IFS-subst-8
 description:
-	http://austingroupbugs.net/view.php?id=221
+	https://www.austingroupbugs.net/view.php?id=221
 stdin:
 	n() { echo "$#"; }; n "${foo-$@}"
 expected-stdout:
@@ -4996,7 +5042,7 @@ expected-stdout:
 ---
 name: IFS-arith-1
 description:
-	http://austingroupbugs.net/view.php?id=832
+	https://www.austingroupbugs.net/view.php?id=832
 stdin:
 	${ZSH_VERSION+false} || emulate sh
 	${BASH_VERSION+set -o posix}
@@ -5264,48 +5310,47 @@ description:
 	Check behaviour for base two to 36, and that 37 degrades to 10
 stdin:
 	i=1
-	while (( ++i <= 37 )); do
-		eval 'echo '$i':$(('$i'#10)).'
+	while (( ++i <= 36 )); do
+		eval 'echo '$i':$(('$i'#100)).'
 	done
-	echo 37:$($__progname -c 'echo $((37#10))').$?:
+	echo 37:$($__progname -c 'echo $((37#100))').$?:
 expected-stdout:
-	2:2.
-	3:3.
-	4:4.
-	5:5.
-	6:6.
-	7:7.
-	8:8.
-	9:9.
-	10:10.
-	11:11.
-	12:12.
-	13:13.
-	14:14.
-	15:15.
-	16:16.
-	17:17.
-	18:18.
-	19:19.
-	20:20.
-	21:21.
-	22:22.
-	23:23.
-	24:24.
-	25:25.
-	26:26.
-	27:27.
-	28:28.
-	29:29.
-	30:30.
-	31:31.
-	32:32.
-	33:33.
-	34:34.
-	35:35.
-	36:36.
-	37:10.
-	37:10.0:
+	2:4.
+	3:9.
+	4:16.
+	5:25.
+	6:36.
+	7:49.
+	8:64.
+	9:81.
+	10:100.
+	11:121.
+	12:144.
+	13:169.
+	14:196.
+	15:225.
+	16:256.
+	17:289.
+	18:324.
+	19:361.
+	20:400.
+	21:441.
+	22:484.
+	23:529.
+	24:576.
+	25:625.
+	26:676.
+	27:729.
+	28:784.
+	29:841.
+	30:900.
+	31:961.
+	32:1024.
+	33:1089.
+	34:1156.
+	35:1225.
+	36:1296.
+	37:100.0:
 ---
 name: integer-base-check-numeric-to-1
 description:
@@ -5565,6 +5610,20 @@ expected-stdout:
 	= 1
 	trap 2 executed
 ---
+name: uncatchable-trap
+description:
+	Ensure trying to trap SIGKILL is a nop (POSIX says undefined)
+stdin:
+	trap 'echo sighit $? .' KILL EXIT
+	"$__perlname" -e 'print $=.$/;'
+	echo meow $? .
+	(exit 7)
+expected-exit: 7
+expected-stdout:
+	60
+	meow 0 .
+	sighit 7 .
+---
 name: read-IFS-1
 description:
 	Simple test, default IFS
@@ -6173,6 +6232,8 @@ expected-stdout:
 name: regression-33
 description:
 	Does umask print a leading 0 when umask is 3 digits?
+# prints 0600…
+category: !os:skyos
 stdin:
 	# on MiNT, the first umask call seems to fail
 	umask 022
@@ -6184,7 +6245,7 @@ expected-stdout:
 ---
 name: regression-35
 description:
-	Temporay files used for here-docs in functions get trashed after
+	Temporary files used for heredocs in functions get trashed after
 	the function is parsed (before it is executed)
 stdin:
 	f1() {
@@ -6228,8 +6289,8 @@ description:
 	Machines with broken times() (reported by <sjg@void.zen.oz.au>)
 	time does not report correct real time
 stdin:
-	time sleep 1
-expected-stderr-pattern: !/^\s*0\.0[\s\d]+real|^\s*real[\s]+0+\.0/
+	time -p sleep 1
+expected-stderr-pattern: /^real +(?![0.]*$)[0-9]+(?:\.[0-9]+)?$/m
 ---
 name: regression-38
 description:
@@ -6728,7 +6789,7 @@ stdin:
 		echo FNORD-7
 		typeset -
 		echo FNORD-8
-	} | fgrep FNORD
+	} | grep FNORD
 	fnord=(42 23)
 	typeset -p fnord
 	echo FNORD-9
@@ -6799,19 +6860,6 @@ stdin:
 		time
 	}
 ---
-name: regression-65
-description:
-	check for a regression with sleep builtin and signal mask
-category: !nojsig
-time-limit: 5
-stdin:
-	sleep 1
-	echo blub |&
-	while read -p line; do :; done
-	echo ok
-expected-stdout:
-	ok
----
 name: regression-66
 description:
 	Check that quoting is sane
@@ -6971,7 +7019,7 @@ expected-stderr-pattern:
 ---
 name: readonly-1
 description:
-	http://austingroupbugs.net/view.php?id=367 for export
+	https://www.austingroupbugs.net/view.php?id=367 for export
 stdin:
 	"$__progname" -c 'readonly foo; export foo=a; echo $?' || echo aborted, $?
 expected-stdout:
@@ -6990,7 +7038,7 @@ expected-stdout:
 ---
 name: readonly-2b
 description:
-	http://austingroupbugs.net/view.php?id=367 for getopts
+	https://www.austingroupbugs.net/view.php?id=367 for getopts
 stdin:
 	"$__progname" -c 'readonly c; set -- -a b; getopts a c; echo $? $c .' || echo aborted, $?
 expected-stdout:
@@ -7000,7 +7048,7 @@ expected-stderr-pattern:
 ---
 name: readonly-3
 description:
-	http://austingroupbugs.net/view.php?id=367 for read
+	https://www.austingroupbugs.net/view.php?id=367 for read
 stdin:
 	echo x | "$__progname" -c 'read s; echo $? $s .' || echo aborted, $?
 	echo y | "$__progname" -c 'readonly s; read s; echo $? $s .' || echo aborted, $?
@@ -7130,7 +7178,7 @@ expected-stdout:
 ---
 name: xxx-exec-environment-1
 description:
-	Check to see if exec sets it's environment correctly
+	Check to see if exec sets its environment correctly
 stdin:
 	print '#!'"$__progname"'\nunset RANDOM\nexport | while IFS= read -r' \
 	    'RANDOM; do eval '\''print -r -- "$RANDOM=$'\''"$RANDOM"'\'\"\'\; \
@@ -7162,47 +7210,73 @@ expected-stdout:
 	y1-
 	x-3- z-
 ---
-name: exec-modern-korn-shell
+name: exec-execs
+description:
+	Ensure that exec never returns
+need-ctty: yes
+env-setup: !ENV=./envf!
+file-setup: file 644 "envf"
+	PS1=X
+arguments: !-i!
+stdin:
+	oldPATH=$PATH
+	PATH=$PWD
+	exec bla
+	PATH=$oldPATH
+	echo fail
+expected-stderr-pattern:
+	/X+.*: bla: (?:inaccessible or )?not found\n/
+expected-exit: 127
+---
+name: exec-modern
 description:
 	Check that exec can execute any command that makes it
 	through syntax and parser
 stdin:
-	print '#!'"$__progname"'\necho tf' >lq
-	chmod +x lq
+	echo '#!'"$__progname" >f
+	echo 'echo >&3 FAIL' >>f
+	echo '#!'"$__progname" >lq
+	echo 'echo tf' >>lq
+	chmod +x lq f
 	PATH=$PWD
-	exec 2>&1
-	foo() { print two; }
-	print =1
-	(exec print one)
-	print =2
-	(exec foo)
-	print =3
-	(exec ls)
-	print =4
-	(exec lq)
+	exec 3>&2 2>&1
+	foo() { echo two; }
+	echo =1
+	(exec echo one; ./f)
+	echo =2
+	(exec foo; ./f)
+	echo =3
+	(exec ls; ./f)
+	echo =4
+	(exec lq; ./f)
 expected-stdout-pattern:
-	/=1\none\n=2\ntwo\n=3\n.*: ls: inaccessible or not found\n=4\ntf\n/
+	/=1\none\n=2\ntwo\n=3\n.*: ls: (?:inaccessible or )?not found\n=4\ntf\n/
 ---
 name: exec-ksh88
 description:
 	Check that exec only executes after a PATH search
+	(POSIX Issue 8 uses utility ipv command for the synopsis)
+	cf. https://www.austingroupbugs.net/view.php?id=1157
 arguments: !-o!posix!
 stdin:
-	print '#!'"$__progname"'\necho tf' >lq
-	chmod +x lq
+	echo '#!'"$__progname" >f
+	echo 'echo >&3 FAIL' >>f
+	echo '#!'"$__progname" >lq
+	echo 'echo tf' >>lq
+	chmod +x lq f
 	PATH=$PWD
-	exec 2>&1
-	foo() { print two; }
-	print =1
-	(exec print one)
-	print =2
-	(exec foo)
-	print =3
-	(exec ls)
-	print =4
-	(exec lq)
+	exec 3>&2 2>&1
+	foo() { echo two; }
+	echo =1
+	(exec echo one; ./f)
+	echo =2
+	(exec foo; ./f)
+	echo =3
+	(exec ls; ./f)
+	echo =4
+	(exec lq; ./f)
 expected-stdout-pattern:
-	/=1\n.*: print: inaccessible or not found\n=2\n.*: foo: inaccessible or not found\n=3\n.*: ls: inaccessible or not found\n=4\ntf\n/
+	/=1\n.*: echo: (?:inaccessible or )?not found\n=2\n.*: foo: (?:inaccessible or )?not found\n=3\n.*: ls: (?:inaccessible or )?not found\n=4\ntf\n/
 ---
 name: xxx-what-do-you-call-this-1
 stdin:
@@ -7339,7 +7413,7 @@ need-ctty: yes
 arguments: !-i!
 stdin:
 	exec echo hi
-	echo still herre
+	echo still here
 expected-stdout:
 	hi
 expected-stderr-pattern: /.*/
@@ -7827,25 +7901,35 @@ expected-stdout:
 ---
 name: exit-enoent-1
 description:
-	SUSv4 says that the shell should exit with 126/127 in some situations
+	SUSv4 says that the shell should exit with 127 in some situations
 stdin:
-	i=0
 	(echo; echo :) >x
-	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
-	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
+	"$__progname" ./x >/dev/null 2>&1; r=$?; echo 0 $r .
 	echo exit 42 >x
-	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
-	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
+	"$__progname" ./x >/dev/null 2>&1; r=$?; echo 42 $r .
 	rm -f x
-	"$__progname" ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
-	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo $((i++)) $r .
+	"$__progname" ./x >/dev/null 2>&1; r=$?; echo notexist $r .
 expected-stdout:
 	0 0 .
-	1 126 .
-	2 42 .
-	3 126 .
-	4 127 .
-	5 127 .
+	42 42 .
+	notexist 127 .
+---
+name: exit-enoent-2
+description:
+	SUSv4 says that the shell should exit with 126 in some situations
+# fails because x permissions handled wrong
+category: !os:skyos
+stdin:
+	(echo; echo :) >x
+	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo 0 $r .
+	echo exit 42 >x
+	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo 42 $r .
+	rm -f x
+	"$__progname" -c ./x >/dev/null 2>&1; r=$?; echo notexist $r .
+expected-stdout:
+	0 126 .
+	42 126 .
+	notexist 127 .
 ---
 name: exit-eval-1
 description:
@@ -7884,6 +7968,80 @@ expected-stdout:
 	G 12
 	H 0
 ---
+name: exit-stdout-1
+description:
+	cf. https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=990265, Austin ML
+# SIGPIPE seems hosed on BeOS and SkyOS
+category: !os:beos,!os:skyos
+stdin:
+	if test -c /dev/full && test -w /dev/full; then
+		if pwd >/dev/full 2>e; then
+			cat e
+			echo fail
+		else
+			echo pass
+		fi
+	else
+		echo skip
+	fi
+	case " $(echo $( (set -o posix) >/dev/null 2>&1 && set -o posix >/dev/null 2>&1; kill -l)) " in
+	(*' PIPE '*)
+		:>s
+		{ trap '' PIPE; sleep 1; pwd 2>e; echo $? >s; } | :
+		case x$(cat s) in
+		(x)
+			cat e
+			echo fail else ;;
+		(x0)
+			cat e
+			echo fail 0 ;;
+		(*)
+			echo pass ;;
+		esac
+		;;
+	(*)
+		echo skip ;;
+	esac
+expected-stdout-pattern:
+	/^(pass|skip)\n(pass|skip)\n$/
+---
+name: exit-stdout-2
+description:
+	same, except for external utility / direct builtin call
+category: !os:beos,!os:skyos
+stdin:
+	ln -s "$__progname" pwd 2>/dev/null || cp "$__progname" pwd
+	if test -c /dev/full && test -w /dev/full; then
+		if ./pwd >/dev/full 2>e; then
+			cat e
+			echo fail
+		else
+			echo pass
+		fi
+	else
+		echo skip
+	fi
+	case " $(echo $( (set -o posix) >/dev/null 2>&1 && set -o posix >/dev/null 2>&1; kill -l)) " in
+	(*' PIPE '*)
+		:>s
+		{ trap '' PIPE; sleep 1; ./pwd 2>e; echo $? >s; } | :
+		case x$(cat s) in
+		(x)
+			cat e
+			echo fail else ;;
+		(x0)
+			cat e
+			echo fail 0 ;;
+		(*)
+			echo pass ;;
+		esac
+		;;
+	(*)
+		echo skip ;;
+	esac
+expected-stdout-pattern:
+	/^(pass|skip)\n(pass|skip)\n$/
+---
 name: exit-trap-1
 description:
 	Check that "exit" with no arguments behaves SUSv4 conformant.
@@ -8474,7 +8632,7 @@ stdin:
 	[[ -o !sh ]] && echo nosh
 	[[ -o braceexpand ]] && echo brex
 	[[ -o !braceexpand ]] && echo nobrex
-	[[ $(exec -a -set "$__progname" -o) = *login+(' ')on* ]]; echo $?
+	:
 expected-stdout:
 	nosh
 	brex
@@ -8487,6 +8645,15 @@ expected-stdout:
 	a b c
 	sh
 	brex
+---
+name: sh-mode-1-exec-a
+description:
+	Was part of sh-mode-1 but exclude where selftest-exec-a fails
+	or better fix that
+category: !os:beos
+stdin:
+	[[ $(exec -a -set "$__progname" -o) = *login+(' ')on* ]]; echo $?
+expected-stdout:
 	0
 ---
 name: sh-mode-2a
@@ -8495,7 +8662,7 @@ description:
 category: !binsh
 stdin:
 	for shell in {,-}{,r}{,k,mk}sh {,-}{,R}{,K,MK}SH.EXE; do
-		ln -s "$__progname" ./$shell || cp "$__progname" ./$shell
+		ln -s "$__progname" ./$shell 2>/dev/null || cp "$__progname" ./$shell
 		print -- $shell $(./$shell +l -c '
 			[[ -o sh || -o posix ]] && echo sh
 			[[ -o !sh && -o !posix ]] && echo nosh
@@ -8534,7 +8701,7 @@ description:
 category: binsh
 stdin:
 	for shell in {,-}{,r}{,k,mk}sh {,-}{,R}{,K,MK}SH.EXE; do
-		ln -s "$__progname" ./$shell || cp "$__progname" ./$shell
+		ln -s "$__progname" ./$shell 2>/dev/null || cp "$__progname" ./$shell
 		print -- $shell $(./$shell +l -c '
 			[[ -o sh || -o posix ]] && echo sh
 			[[ -o !sh && -o !posix ]] && echo nosh
@@ -8641,8 +8808,8 @@ stdin:
 	(echo x; exit 12) | (cat; exit 23) | (cat; exit 42)
 	echo 5 $? , $PIPESTATUS , ${PIPESTATUS[0]} , ${PIPESTATUS[1]} , ${PIPESTATUS[2]} , ${PIPESTATUS[3]} .
 	echo 6 ${PIPESTATUS[0]} .
-	set | fgrep PIPESTATUS
-	echo 8 $(set | fgrep PIPESTATUS) .
+	set | grep PIPESTATUS
+	echo 8 $(set | grep PIPESTATUS) .
 expected-stdout:
 	1 0 .
 	2 0 .
@@ -8794,9 +8961,7 @@ expected-stdout:
 ---
 name: utf8bom-1
 description:
-	Check that the UTF-8 Byte Order Mark is ignored as the first
-	multibyte character of the shell input (with -c, from standard
-	input, as file, or as eval argument), but nowhere else
+	Check that the UTF-8 Byte Order Mark is not ignored any more
 # breaks on Mac OSX (HFS+ non-standard UTF-8 canonical decomposition)
 category: !os:darwin,!shell:ebcdic-yes
 stdin:
@@ -8823,33 +8988,33 @@ stdin:
 	rm -rf foo
 expected-stdout:
 	got 4 files
-	ohne
+	mit
 	=
-	ohne
+	mit
 	ohne
 	mit
 	ohne
 	=
-	ohne
+	mit
 	ohne
 	mit
 	ohne
 	=
-	ohne
+	mit
 	ohne
 	mit
 	ohne
 	=
-	ohne
+	mit
 	ohne
 	mit
 	ohne
 	=
-	﻿: ohne
+	﻿: mit
 ---
 name: utf8bom-2
 description:
-	Check that we can execute BOM-shebangs (failures not fatal)
+	Check that we cannot any more execute BOM-shebangs (failures not fatal)
 	XXX if the OS can already execute them, we lose
 	note: cygwin execve(2) doesn't return to us with ENOEXEC, we lose
 	note: Ultrix perl5 t4 returns 65280 (exit-code 255) and no text
@@ -8868,17 +9033,17 @@ stdin:
 	./t2
 	./t3
 	./t4
+	echo .
 expected-stdout:
 	1 a=/nonexistant{FOO}
-	2 a=/nonexistant{FOO}
 	3 a=BAR
-	4 a=BAR
+	.
 expected-stderr-pattern:
-	/(Unrecognized character .... ignored at \..t4 line 1)*/
+	/t2: not executable: magic EFBB.*\n.*t4: not executable: magic EFBB/
 ---
 name: utf8opt-1
 description:
-	Check that the utf8-mode flag is not set at non-interactive startup
+	Check that the utf8-mode flag *is* set at non-interactive startup
 env-setup: !PS1=!PS2=!LC_CTYPE=@utflocale@!
 stdin:
 	if [[ $- = *U* ]]; then
@@ -8887,7 +9052,7 @@ stdin:
 		echo is not set
 	fi
 expected-stdout:
-	is not set
+	is set
 ---
 name: utf8opt-2
 description:
@@ -9909,7 +10074,6 @@ expected-stdout:
 name: varexpand-special-quote
 description:
 	Check special ${var@Q} expansion for quoted strings
-category: !shell:faux-ebcdic
 stdin:
 	set +U
 	i=x
@@ -9921,36 +10085,46 @@ stdin:
 	print -r -- "s=\"$s\""
 	eval "$s"
 	typeset -p u v w
+	set -o asis
+	typeset -p w
+	set -U
+	typeset -p w
 expected-stdout:
 	<i=x j=a b k=c
 	de€f>
-	s="u=x v='a b' w=$'c\nd\240e\u20ACf'"
+	s="u=x v='a b' w=$'c\nde\202f'"
 	typeset u=x
 	typeset v='a b'
-	typeset w=$'c\nd\240e\u20ACf'
+	typeset w=$'c\nde\202f'
+	typeset w=$'c\nde€f'
+	typeset w=$'c\nd\240e€f'
 ---
-name: varexpand-special-quote-faux-EBCDIC
+name: varexpand-special-caret
 description:
-	Check special ${var@Q} expansion for quoted strings
-category: shell:faux-ebcdic
+	Check special ${var@^} expansion for quoted strings
 stdin:
-	set +U
-	i=x
-	j=a\ b
-	k=$'c
-	d\xA0''e€f'
-	print -r -- "<i=$i j=$j k=$k>"
-	s="u=${i@Q} v=${j@Q} w=${k@Q}"
-	print -r -- "s=\"$s\""
-	eval "$s"
-	typeset -p u v w
-expected-stdout:
-	<i=x j=a b k=c
-	de€f>
-	s="u=x v='a b' w=$'c\nde\u20ACf'"
-	typeset u=x
-	typeset v='a b'
-	typeset w=$'c\nde\u20ACf'
+	if (( 1#1 == 49 )); then
+		CSI=$'\x9B'	# ISO-8859-1
+	else
+		CSI=$'\x3B'	# EBCDIC
+	fi
+	s=$'a\cbc d\te f\c?g h'$CSI$'0mi j\u009B''0mk l^m\n'
+	set +U +o asis
+	# this works because check.t is iconv’d to EBCDIC copying to OS/390
+	print -r -- "raw <$s> ."
+	print -r -- "Ai <${s@^}> ."
+	set -o asis
+	print -r -- "Aa <${s@^}> ."
+	set -U +o asis
+	print -r -- "Ui <${s@^}> ."
+	set -o asis
+	print -r -- "Ua <${s@^}> ."
+expected-stdout:
+	raw <ac d	e fg h0mi j0mk l^m\n> .
+	Ai <a^Bc d^Ie f^?g h^![0mi j^![0mk l\^m\\n> .
+	Aa <a^Bc d^Ie f^?g h0mi j0mk l\^m\\n> .
+	Ui <a^Bc d^Ie f^?g h\x9B0mi j^+[0mk l\^m\\n> .
+	Ua <a^Bc d^Ie f^?g h\x9B0mi j^+[0mk l\^m\\n> .
 ---
 name: varexpand-null-1
 description:
@@ -10027,7 +10201,6 @@ expected-stdout:
 name: varexpand-funny-chars
 description:
 	Check some characters
-	XXX \uEF80 is asymmetric, possibly buggy so we don’t check this
 stdin:
 	x=$'<\x00>'; typeset -p x
 	x=$'<\x01>'; typeset -p x
@@ -10709,11 +10882,14 @@ stdin:
 			lpos=0
 			while (( lpos < ${#line} )); do
 				wc=1#${line:(lpos++):1}
+				let hv=wc
 				if (( (wc < 32) || \
 				    ((wc > 126) && (wc < 160)) )); then
 					dch=.
-				elif (( (wc & 0xFF80) == 0xEF80 )); then
+				elif (( (wc & ~0x7F) == 0xEF80 )); then
 					dch=�
+					# OPTU-8 value mapping, to keep test
+					#(( hv = 0xEF80 | (hv & 0x7F) ))
 				else
 					dch=${wc#1#}
 				fi
@@ -10725,7 +10901,6 @@ stdin:
 					print -n "${pos#16#}  "
 					dasc=' |'
 				fi
-				let hv=wc
 				print -n "${hv#16#} "
 				(( (pos++ & 7) == 3 )) && \
 				    print -n -- '- '
@@ -10876,8 +11051,10 @@ stdin:
 				if (( (hv < 32) || \
 				    ((hv > 126) && (hv < 160)) )); then
 					dch=.
-				elif (( (hv & 0xFF80) == 0xEF80 )); then
+				elif (( (hv & ~0x7F) == 0xEF80 )); then
 					dch=�
+					# OPTU-8 value mapping, to keep test
+					#(( hv = 0xEF80 | (hv & 0x7F) ))
 				else
 					dch=${line[i-1]#1#}
 				fi
@@ -11490,6 +11667,8 @@ name: fd-cloexec-1
 description:
 	Verify that file descriptors > 2 are private for Korn shells
 	AT&T ksh93 does this still, which means we must keep it as well
+# broken on Xenix and BeOS
+category: !os:beos,!os:sco_xenix
 stdin:
 	cat >cld <<-EOF
 		#!$__perlname
@@ -11507,6 +11686,7 @@ name: fd-cloexec-2
 description:
 	Verify that file descriptors > 2 are not private for POSIX shells
 	See Debian Bug #154540, Closes: #499139
+category: !os:beos,!os:sco_xenix
 stdin:
 	cat >cld <<-EOF
 		#!$__perlname
@@ -11514,11 +11694,16 @@ stdin:
 		syswrite(FH, "Fowl\\n", 5) or die "E: write \$!";
 	EOF
 	chmod +x cld
+	./cld 9>&2
+	echo >&2 =
 	test -n "$POSH_VERSION" || set -o posix
 	exec 9>&1
 	./cld
 expected-stdout:
 	Fowl
+expected-stderr:
+	Fowl
+	=
 ---
 name: fd-cloexec-3
 description:
@@ -12728,7 +12913,6 @@ expected-stdout:
 name: funsub-2
 description:
 	You can now reliably use local and return in funsubs
-	(not exit though)
 stdin:
 	x=q; e=1; x=${ echo a; e=2; echo x$e;}; echo 1:y$x,$e,$?.
 	x=q; e=1; x=${ echo a; typeset e=2; echo x$e;}; echo 2:y$x,$e,$?.
@@ -12738,6 +12922,32 @@ expected-stdout:
 	2:ya x2,1,0.
 	3:ya,1,3.
 ---
+name: funsub-3
+description:
+	… not exit though, like in ksh93
+stdin:
+	function foo {
+		if [[ $1 = 2 ]]; then
+			print -u2 ERR
+			exit 42
+		fi
+		print -r -- "<$1>"
+	}
+	for i in 1 2 3; do
+		print $i ${ foo $i;} || {
+			print SUB=$?
+			exit 1
+		}
+	done
+	print END=$?
+expected-stdout:
+	1 <1>
+	2
+	3 <3>
+	END=0
+expected-stderr:
+	ERR
+---
 name: valsub-1
 description:
 	Check that "value substitutions" work as advertised
@@ -12770,6 +12980,30 @@ expected-stdout:
 	typeset t=$'foo\n\n'
 	this used to segfault.
 ---
+name: valsub-2
+description:
+	Can use exit here, in contrast to funsubs
+stdin:
+	function foo {
+		if [[ $1 = 2 ]]; then
+			print -u2 ERR
+			exit 42
+		fi
+		REPLY="<$1>"
+	}
+	for i in 1 2 3; do
+		print $i ${|foo $i;} || {
+			print SUB=$?
+			exit 1
+		}
+	done
+	print END=$?
+expected-exit: 42
+expected-stdout:
+	1 <1>
+expected-stderr:
+	ERR
+---
 name: event-subst-3
 description:
 	Check that '!' substitution in noninteractive mode is ignored
@@ -13218,6 +13452,44 @@ expected-stdout:
 	2=\x7Cfoo-e \x4B
 	3=\x7Cfoo-e \x4B
 ---
+name: env-intvars
+description:
+	Check that importing integers fails except for numbers
+stdin:
+	print '#!'"$__perlname"'\n($k, $v) = split(/=/, shift(@ARGV),' \
+	    '2);\n$ENV{$k} = $v;\nexec { $ARGV[0] } @ARGV or die $!;' \
+	    >env; chmod +x env; PATH=.$PATHSEP$PATH
+	unset foo bar
+	print 1 $foo , $(typeset -p bar) .
+	print 2 $(foo=123 "$__progname" -c 'integer foo; print -- $foo' 2>&1) , \
+	    $(env 'bar[123]=baz' "$__progname" -c 'typeset -p bar') .
+	print 3 $(foo='abc[$(echo >&2 fowled)0]' "$__progname" -c 'integer foo; print -- $foo' 2>&1) , \
+	    $(env 'bar[$(echo >&2 fowled)0]=baz' "$__progname" -c 'typeset -p bar') .
+	print 4 $(foo=0123 "$__progname" +o posix -c 'integer foo; print -- $foo' 2>&1) , \
+	    $(env 'bar[0123]=baz' "$__progname" +o posix -c 'typeset -p bar') .
+	# ksh93 does not do this:
+	print 5 $(foo=0123 "$__progname" -o posix -c 'integer foo; print -- $foo' 2>&1) .
+	# at import time FPOSIX is not yet set
+	print 6 $(foo=0x123 "$__progname" -c 'integer foo; print -- $foo' 2>&1) , \
+	    $(env 'bar[0x123]=baz' "$__progname" -c 'typeset -p bar') .
+	print 7 $(foo=12#123 "$__progname" -c 'integer foo; print -- $foo' 2>&1) , \
+	    $(env 'bar[12#123]=baz' "$__progname" -c 'typeset -p bar') .
+	print 8 $(foo=1+1 "$__progname" -c 'integer foo; print -- $foo' 2>&1) , \
+	    $(env 'bar[1+1]=baz' "$__progname" -c 'typeset -p bar') .
+	print 9 $(a=1 b=2 c=a "$__progname" -c 'typeset -p c; c=b; typeset -p c; integer c; typeset -p c') .
+	print 0 $(a=1 b=2 c=a "$__progname" -c 'typeset -p c;      typeset -p c; integer c; typeset -p c') .
+expected-stdout:
+	1 , .
+	2 123 , set -A bar typeset -x bar[123]=baz .
+	3 0 , .
+	4 123 , set -A bar typeset -x bar[123]=baz .
+	5 8#123 .
+	6 16#123 , set -A bar typeset -x bar[291]=baz .
+	7 12#123 , set -A bar typeset -x bar[171]=baz .
+	8 0 , .
+	9 typeset -x c=a typeset -x c=b typeset -i -x c=2 .
+	0 typeset -x c=a typeset -x c=a typeset -i -x c=0 .
+---
 name: utilities-getopts-1
 description:
 	getopts sets OPTIND correctly for unparsed option
@@ -13730,7 +14002,7 @@ name: duffs-device
 description:
 	Check that the compiler did not optimise-break them
 	(lex.c has got a similar one in SHEREDELIM)
-category: !shell:faux-ebcdic,!shell:ebcdic-yes
+category: !shell:ebcdic-yes
 stdin:
 	set +U
 	s=
@@ -13740,8 +14012,14 @@ stdin:
 	done
 	s+=$'\xC2\xA0\xE2\x82\xAC\xEF\xBF\xBD\xEF\xBF\xBE\xEF\xBF\xBF\xF0\x90\x80\x80.'
 	typeset -p s
+	set -o asis
+	typeset -p s
+	set -U
+	typeset -p s
 expected-stdout:
-	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377\u00A0\u20AC\uFFFD\357\277\276\357\277\277\360\220\200\200.'
+	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237 \202�￾￿\220\200\200.'
+	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177 €�￾￿𐀀.'
+	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377 €�\357\277\276\357\277\277\360\220\200\200.'
 ---
 name: duffs-device-ebcdic
 description:
@@ -13759,22 +14037,6 @@ stdin:
 expected-stdout:
 	typeset s=$'\001\002\003\004\t\006\007\010\011\012\v\f\r\016\017\020\021\022\023\024\n\b\027\030\031\032\033\034\035\036\037\040\041\042\043\044\045\046\E\050\051\052\053\054\055\056\a\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077 .<(+|&!$*);^-/Ѧ,%_>?`:#@\175="abcdefghijklmnopqrƤ~stuvwxyz[ޮݨ]{ABCDEFGHI}JKLMNOPQR\\STUVWXYZ0123456789\377'
 ---
-name: duffs-device-faux-EBCDIC
-description:
-	Check that the compiler did not optimise-break them
-category: shell:faux-ebcdic
-stdin:
-	set +U
-	s=
-	typeset -i1 i=0
-	while (( ++i < 256 )); do
-		s+=${i#1#}
-	done
-	s+=$'\xC2\xA0\xE2\x82\xAC\xEF\xBF\xBD\xEF\xBF\xBE\xEF\xBF\xBF\xF0\x90\x80\x80.'
-	typeset -p s
-expected-stdout:
-	typeset s=$'\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023\024\025\026\027\030\031\032\E\034\035\036\037 !"#$%&\047()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\u00A0\u20AC\uFFFD￾￿\220\200\200.'
----
 name: stateptr-underflow
 description:
 	This check overflows an Xrestpos stored in a short in R40
--- mksh-59c.orig/dot.mkshrc
+++ mksh-59c/dot.mkshrc
@@ -1,9 +1,9 @@
 # $Id$
-# $MirOS: src/bin/mksh/dot.mkshrc,v 1.128 2020/04/13 18:39:03 tg Exp $
+# $MirOS: src/bin/mksh/dot.mkshrc,v 1.136 2021/01/24 20:38:30 tg Exp $
 #-
 # Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010,
 #		2011, 2012, 2013, 2014, 2015, 2016, 2017, 2019,
-#		2020
+#		2020, 2021
 #	mirabilos <m@mirbsd.org>
 #
 # Provided that these terms and disclaimer and all copyright notices
@@ -38,24 +38,51 @@ function setenv {
 	fi
 }
 
+# internal helper function to cat all arguments if necessary
+function _dot_mkshrc_wrapped_cat {
+	\\builtin typeset fn=$1
+	\\builtin shift
+
+	if [[ $# = 0 || $#,$1 = 1,- ]]; then
+		"$fn"
+	else
+		\cat "$@" | "$fn"
+	fi
+}
+function _dot_mkshrc_cat_for_readN {
+	\\builtin typeset fn=$1
+	\\builtin shift
+
+	if (( $# )); then
+		\\builtin print -nr -- "$*" | "$fn"
+	elif [[ -t 0 ]]; then
+		\cat | "$fn"
+	else
+		"$fn"
+	fi
+}
+
 # pager (not control character safe)
-smores() (
-	\\builtin set +m
-	\\builtin cat "$@" |&
-	\\builtin trap "rv=\$?; \\\\builtin kill $! >/dev/null 2>&1; \\\\builtin exit \$rv" EXIT
-	while IFS= \\builtin read -pr line; do
+function smores {
+	\_dot_mkshrc_wrapped_cat _dot_mkshrc_smores "$@"
+}
+function _dot_mkshrc_smores {
+	\\builtin set +e
+	\\builtin typeset line llen curlin=0 x
+
+	while IFS= \\builtin read -r line; do
 		llen=${%line}
-		(( llen == -1 )) && llen=${#line}
+		(( llen != -1 )) || llen=${#line}
 		(( llen = llen ? (llen + COLUMNS - 1) / COLUMNS : 1 ))
 		if (( (curlin += llen) >= LINES )); then
 			\\builtin print -nr -- $'\e[7m--more--\e[0m'
-			\\builtin read -u1 || \\builtin exit $?
-			[[ $REPLY = [Qq]* ]] && \\builtin exit 0
+			\\builtin read -u1 x || \\builtin return $?
+			[[ $x != [Qq]* ]] || \\builtin return 0
 			curlin=$llen
 		fi
 		\\builtin print -r -- "$line"
 	done
-)
+}
 
 # customise your favourite editor here; the first one found is used
 for EDITOR in "${EDITOR:-}" jupp jstar mcedit ed vi; do
@@ -82,10 +109,10 @@ fi
 
 # prompts
 PS4='[$EPOCHREALTIME] '; PS1='#'; (( USER_ID )) && PS1='$'; PS1=$'\001\r''${|
-	\\builtin typeset e=$?
+	\\builtin typeset e=$? hn=${HOSTNAME:-nil}
 
-	(( e )) && REPLY+="$e|"
-	REPLY+=${USER}@${HOSTNAME%%.*}:
+	(( !!e )) || REPLY+="$e|"
+	REPLY+=${USER:-?}@${hn%%.*}:
 
 	\\builtin typeset d=${PWD:-?}/ p=~; [[ $p = ?(*/) ]] || d=${d/#$p\//\~/}
 	d=${d%/}; \\builtin typeset m=${%d} n p=...; (( m > 0 )) || m=${#d}
@@ -104,12 +131,13 @@ if \\builtin command -v hd >/dev/null; t
 	\:
 elif \\builtin command -v hexdump >/dev/null; then
 	function hd {
-		hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
+		\hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
 		    -e '"  |" "%_p"' -e '"|\n"' "$@"
 	}
 else
 	function hd {
-		\\builtin cat "$@" | hd_mksh
+		# cannot use _dot_mkshrc_wrapped_cat as hd_mksh sets stdin raw
+		\cat "$@" | \hd_mksh
 	}
 fi
 
@@ -118,7 +146,7 @@ function hd_mksh {
 	\\builtin typeset -Uui16 -Z11 pos=0
 	\\builtin typeset -Uui16 -Z5 hv=2147483647
 	\\builtin typeset dasc dn line i
-	\\builtin set +U
+	\\builtin set +Ue
 
 	while \\builtin read -arn 512 line; do
 		\\builtin typeset -i1 'line[*]'
@@ -219,6 +247,7 @@ function cd_csh {
 	\cd "$t"
 }
 function dirs {
+	\\builtin set +e
 	\\builtin typeset d dwidth
 	\\builtin typeset -i fl=0 fv=0 fn=0 cpos=0
 
@@ -343,9 +372,17 @@ function pushd {
 
 # base64 encoder and decoder, RFC compliant, NUL safe, not EBCDIC safe
 function Lb64decode {
-	\\builtin set +U
-	\\builtin typeset c s="$*" t
-	[[ -n $s ]] || { s=$(\\builtin cat; \\builtin print x); s=${s%x}; }
+	\\builtin set +Ue
+	\\builtin typeset c s t
+	if (( $# )); then
+		s="$*"
+	elif [[ -t 0 ]]; then
+		s=$(\cat || \\builtin exit $?; \\builtin print x) || \
+		    \\builtin return $?
+		s=${s%x}
+	else
+		\\builtin read -rN-1 s || \\builtin return $?
+	fi
 	\\builtin typeset -i i=0 j=0 n=${#s} p=0 v x
 	\\builtin typeset -i16 o
 
@@ -371,22 +408,20 @@ function Lb64decode {
 		}
 		t+=\\x${o#16#}
 		(( ++j & 4095 )) && \\builtin continue
-		\\builtin print -n $t
+		\\builtin print -n -- "$t"
 		t=
 	done
-	\\builtin print -n $t
+	\\builtin print -n -- "$t"
 }
 function Lb64encode {
-	\\builtin set +U
+	\_dot_mkshrc_cat_for_readN _dot_mkshrc_b64encode "$@"
+}
+function _dot_mkshrc_b64encode {
+	\\builtin set +Ue
 	\\builtin typeset c s t table
 	\\builtin set -A table -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
 	    a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /
-	if (( $# )); then
-		\\builtin read -raN-1 s <<<"$*"
-		\\builtin unset s[${#s[*]}-1]
-	else
-		\\builtin read -raN-1 s
-	fi
+	\\builtin read -raN-1 s || \\builtin return $?
 	\\builtin typeset -i i=0 n=${#s[*]} v
 
 	while (( i < n )); do
@@ -403,10 +438,11 @@ function Lb64encode {
 			t+===
 		fi
 		if (( ${#t} == 76 || i >= n )); then
-			\\builtin print -r $t
+			\\builtin print -r -- "$t"
 			t=
 		fi
 	done
+	\:
 }
 
 # Better Avalanche for the Jenkins Hash
@@ -415,22 +451,22 @@ function Lbafh_init {
 	Lbafh_v=0
 }
 function Lbafh_add {
-	\\builtin set +U
+	\_dot_mkshrc_cat_for_readN _dot_mkshrc_bafh_add "$@"
+}
+function _dot_mkshrc_bafh_add {
+	\\builtin set +Ue
 	\\builtin typeset s
-	if (( $# )); then
-		\\builtin read -raN-1 s <<<"$*"
-		\\builtin unset s[${#s[*]}-1]
-	else
-		\\builtin read -raN-1 s
-	fi
+	\\builtin read -raN-1 s || \\builtin return $?
 	\\builtin typeset -i i=0 n=${#s[*]}
 
 	while (( i < n )); do
 		((# Lbafh_v = (Lbafh_v + s[i++] + 1) * 1025 ))
 		((# Lbafh_v ^= Lbafh_v >> 6 ))
 	done
+	\:
 }
 function Lbafh_finish {
+	\\builtin set +e
 	\\builtin typeset -Ui t
 
 	((# t = (((Lbafh_v >> 7) & 0x01010101) * 0x1B) ^ \
@@ -443,11 +479,20 @@ function Lbafh_finish {
 # strip comments (and leading/trailing whitespace if IFS is set) from
 # any file(s) given as argument, or stdin if none, and spew to stdout
 function Lstripcom {
+	\_dot_mkshrc_wrapped_cat _dot_mkshrc_stripcom "$@"
+}
+function _dot_mkshrc_stripcom {
+	\\builtin typeset line x
 	\\builtin set -o noglob
-	\\builtin cat "$@" | while \\builtin read _line; do
-		_line=${_line%%#*}
-		[[ -n $_line ]] && \\builtin print -r -- $_line
+	while \\builtin read -r line; do
+		while [[ $line = *\\ && $line != *'#'* ]] && \
+		    \\builtin read -r x; do
+			line=${line%\\}$x
+		done
+		line=${line%%#*}
+		[[ -z $line ]] || \\builtin print -r -- $line
 	done
+	\:
 }
 
 # toggle built-in aliases and utilities, and aliases and functions from mkshrc
@@ -479,7 +524,6 @@ function enable {
 	i_func[nfunc++]=break
 	# \\builtin cannot, by design, be overridden
 	i_func[nfunc++]=builtin
-	i_func[nfunc++]=cat
 	i_func[nfunc++]=cd
 	i_func[nfunc++]=chdir
 	i_func[nfunc++]=command
@@ -522,8 +566,6 @@ function enable {
 	i_func[nfunc++]=bind
 	i_func[nfunc++]=mknod
 	i_func[nfunc++]=printf
-	i_func[nfunc++]=sleep
-	i_func[nfunc++]=domainname
 	i_func[nfunc++]=extproc
 
 	# accumulate aliases from dot.mkshrc, in definition order
@@ -585,7 +627,7 @@ function enable {
 		(*)
 			\\builtin print -ru2 enable: usage: \
 			    "enable [-adnps] [-f filename] [name ...]"
-			return 2
+			\\builtin return 2
 			;;
 		}
 	done
--- mksh-59c.orig/edit.c
+++ mksh-59c/edit.c
@@ -6,7 +6,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
- *		 2019, 2020
+ *		 2019, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -29,7 +29,7 @@
 
 #ifndef MKSH_NO_CMDLINE_EDITING
 
-__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.357 2020/10/31 05:02:17 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/edit.c,v 1.392 2021/10/16 01:28:05 tg Exp $");
 
 /*
  * in later versions we might use libtermcap for this, but since external
@@ -58,14 +58,8 @@ static struct {
 } edchars;
 
 #define isched(x,e) ((unsigned short)(unsigned char)(x) == (e))
-#define isedchar(x) (!((x) & ~0xFF))
-#ifndef _POSIX_VDISABLE
-#define toedchar(x) ((unsigned short)(unsigned char)(x))
-#else
-#define toedchar(x) (((_POSIX_VDISABLE != -1) && ((x) == _POSIX_VDISABLE)) ? \
-			((unsigned short)EDCHAR_DISABLED) : \
-			((unsigned short)(unsigned char)(x)))
-#endif
+#define isedchar(x) (!((x) & ~0xFFU))
+#define toedchar(x) ((unsigned short)KSH_ISVDIS(x, EDCHAR_DISABLED))
 
 /* x_cf_glob() flags */
 #define XCF_COMMAND	BIT(0)	/* Do command completion */
@@ -74,6 +68,7 @@ static struct {
 #define XCF_COMMAND_FILE (XCF_COMMAND | XCF_FILE)
 #define XCF_IS_COMMAND	BIT(3)	/* return flag: is command */
 #define XCF_IS_NOSPACE	BIT(4)	/* return flag: do not append a space */
+#define XCF_IS_HOMEDIR	BIT(5)	/* return flag: tilde needs slash */
 
 static char editmode;
 static int xx_cols;			/* for Emacs mode */
@@ -81,7 +76,7 @@ static int modified;			/* buffer has bee
 static char *holdbufp;			/* place to hold last edit buffer */
 
 /* 0=dumb 1=tmux (for now) */
-static uint8_t x_term_mode;
+static kby x_term_mode;
 
 static void x_adjust(void);
 static int x_getc(void);
@@ -92,17 +87,21 @@ static int x_do_comment(char *, ssize_t,
 static void x_print_expansions(int, char * const *, bool);
 static int x_cf_glob(int *, const char *, int, int, int *, int *, char ***);
 static size_t x_longest_prefix(int, char * const *);
-static void x_glob_hlp_add_qchar(char *);
+static char *x_glob_hlp_add_qchar(char *);
 static char *x_glob_hlp_tilde_and_rem_qchar(char *, bool);
 static size_t x_basename(const char *, const char *);
 static void x_free_words(int, char **);
 static int x_escape(const char *, size_t, int (*)(const char *, size_t));
-static int x_emacs(char *);
+static ssize_t x_emacs(char *);
+#ifdef DF
+static void x_emacs_DF(const char *);
+#endif
 static void x_init_prompt(bool);
 #if !MKSH_S_NOVI
-static int x_vi(char *);
+static ssize_t x_vi(char *);
 #endif
 static void x_intr(int, int) MKSH_A_NORETURN;
+static void x_clrtoeol(int, bool);
 
 #define x_flush()	shf_flush(shl_out)
 #if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
@@ -125,10 +124,10 @@ static int x_e_getmbc(char *);
 /*
  * read an edited command line
  */
-int
+char *
 x_read(char *buf)
 {
-	int i;
+	ssize_t i;
 
 	x_mode(true);
 	modified = 1;
@@ -143,7 +142,12 @@ x_read(char *buf)
 		i = -1;
 	editmode = 0;
 	x_mode(false);
-	return (i);
+	if (i < 0) {
+		/* pdksh had no error handling here, just return null */
+		return (buf);
+	}
+	buf += i;
+	return (buf);
 }
 
 /* tty I/O */
@@ -245,10 +249,12 @@ x_do_comment(char *buf, ssize_t bsize, s
 static void
 x_print_expansions(int nwords, char * const *words, bool is_command)
 {
-	bool use_copy = false;
-	size_t prefix_len;
-	XPtrV l = { NULL, 0, 0 };
+	int i;
+	char **w;
+	size_t prefix_len = 0;
+	bool prefix_trim = false;
 	struct columnise_opts co;
+	struct shf S;
 
 	/*
 	 * Check if all matches are in the same directory (in this
@@ -256,8 +262,6 @@ x_print_expansions(int nwords, char * co
 	 */
 	if (!is_command &&
 	    (prefix_len = x_longest_prefix(nwords, words)) > 0) {
-		int i;
-
 		/* Special case for 1 match (prefix is whole word) */
 		if (nwords == 1)
 			prefix_len = x_basename(words[0], NULL);
@@ -271,14 +275,23 @@ x_print_expansions(int nwords, char * co
 			while (prefix_len > 0 &&
 			    !mksh_cdirsep(words[0][prefix_len - 1]))
 				prefix_len--;
-			use_copy = true;
-			XPinit(l, nwords + 1);
-			for (i = 0; i < nwords; i++)
-				XPput(l, words[i] + prefix_len);
-			XPput(l, NULL);
+			prefix_trim = true;
 		}
 	}
 	/*
+	 * Escape words, trimming prefix_len if needed
+	 */
+	if (!prefix_trim)
+		prefix_len = 0;
+	w = alloc2((kui)nwords + 1U, sizeof(char *), ATEMP);
+	for (i = 0; i < nwords; ++i) {
+		shf_sopen(NULL, 0, SHF_WR | SHF_DYNAMIC, &S);
+		uprntmbs(words[i] + prefix_len, false, &S);
+		w[i] = shf_sclose(&S);
+	}
+	w[nwords] = NULL;
+
+	/*
 	 * Enumerate expansions
 	 */
 	x_putc('\r');
@@ -287,50 +300,45 @@ x_print_expansions(int nwords, char * co
 	co.linesep = '\n';
 	co.do_last = true;
 	co.prefcol = false;
-	pr_list(&co, use_copy ? (char **)XPptrv(l) : words);
-
-	if (use_copy)
-		/* not x_free_words() */
-		XPfree(l);
+	pr_list(&co, w);
+	x_free_words(nwords, w);
 }
 
 /*
  * Convert backslash-escaped string to QCHAR-escaped
- * string useful for globbing; loses QCHAR unless it
- * can squeeze in, eg. by previous loss of backslash
+ * string useful for globbing
  */
-static void
+static char *
 x_glob_hlp_add_qchar(char *cp)
 {
-	char ch, *dp = cp;
+	char ch, *dp;
 	bool escaping = false;
+	XString xs;
+	size_t n;
+
+	if (memchr(cp, QCHAR, (n = strlen(cp)))) {
+		Xinit(xs, dp, n, ATEMP);
+	} else {
+		xs.len = n + 1;
+		xs.areap = NULL; /* won’t be used */
+		xs.beg = dp = cp;
+		xs.end = xs.beg + xs.len;
+	}
 
 	while ((ch = *cp++)) {
 		if (ch == '\\' && !escaping) {
 			escaping = true;
 			continue;
 		}
-		if (escaping || (ch == QCHAR && (cp - dp) > 1)) {
-			/*
-			 * empirically made list of chars to escape
-			 * for globbing as well as QCHAR itself
-			 */
-			switch (ord(ch)) {
-			case QCHAR:
-			case ORD('$'):
-			case ORD('*'):
-			case ORD('?'):
-			case ORD('['):
-			case ORD('\\'):
-			case ORD('`'):
-				*dp++ = QCHAR;
-				break;
-			}
-			escaping = false;
-		}
+		/* coverity[var_deref_model : SUPPRESS] */
+		XcheckN(xs, dp, 2);
+		if ((escaping && ctype(ch, C_EDGLB)) || ch == QCHAR)
+			*dp++ = QCHAR;
+		escaping = false;
 		*dp++ = ch;
 	}
 	*dp = '\0';
+	return (Xstring(xs, dp));
 }
 
 /*
@@ -349,7 +357,7 @@ x_glob_hlp_tilde_and_rem_qchar(char *s,
 	 * and if so, discern "~foo/bar" and "~/baz" from "~blah";
 	 * if we have a directory part (the former), try to expand
 	 */
-	if (*s == '~' && (cp = /* not sdirsep */ strchr(s, '/')) != NULL) {
+	if (*s == '~' && (cp = /* not sdirsep */ ucstrchr(s, '/')) != NULL) {
 		/* ok, so split into "~foo"/"bar" or "~"/"baz" */
 		*cp++ = 0;
 		/* try to expand the tilde */
@@ -366,8 +374,12 @@ x_glob_hlp_tilde_and_rem_qchar(char *s,
 	}
 
 	/* ... convert it from backslash-escaped via QCHAR-escaped... */
-	if (magic_flag)
-		x_glob_hlp_add_qchar(s);
+	if (magic_flag) {
+		cp = x_glob_hlp_add_qchar(s);
+		if (cp != s)
+			afree(s, ATEMP);
+		s = cp;
+	}
 	/* ... to unescaped, for comparison with the matches */
 	cp = dp = s;
 
@@ -390,25 +402,26 @@ x_glob_hlp_tilde_and_rem_qchar(char *s,
 static int
 x_file_glob(int *flagsp, char *toglob, char ***wordsp)
 {
-	char **words, *cp;
+	char **words, *cp, *qglob;
 	int nwords;
 	XPtrV w;
 	struct source *s, *sold;
 
 	/* remove all escaping backward slashes */
-	x_glob_hlp_add_qchar(toglob);
+	qglob = x_glob_hlp_add_qchar(toglob);
 
 	/*
 	 * Convert "foo*" (toglob) to an array of strings (words)
 	 */
 	sold = source;
 	s = pushs(SWSTR, ATEMP);
-	s->start = s->str = toglob;
+	s->start = s->str = qglob;
 	source = s;
 	if (yylex(ONEWORD | LQCHAR) != LWORD) {
 		source = sold;
 		internal_warningf(Tfg_badsubst);
-		return (0);
+		nwords = 0;
+		goto out;
 	}
 	source = sold;
 	afree(s, ATEMP);
@@ -425,15 +438,17 @@ x_file_glob(int *flagsp, char *toglob, c
 	}
 	expand(yylval.cp, &w, nwords);
 	XPput(w, NULL);
-	words = (char **)XPclose(w);
+	nwords = 0;
+	while (XPptrv(w)[nwords])
+		++nwords;
+	/* XPclose(w) except for nwords plus a trailing NULL for pr_list */
+	words = aresize2(XPptrv(w), (kui)nwords + 1U, sizeof(void *), ATEMP);
 
-	for (nwords = 0; words[nwords]; nwords++)
-		;
 	if (nwords == 1) {
 		struct stat statb;
 
 		/* Expand any tilde and drop all QCHAR for comparison */
-		toglob = x_glob_hlp_tilde_and_rem_qchar(toglob, false);
+		qglob = x_glob_hlp_tilde_and_rem_qchar(qglob, false);
 
 		/*
 		 * Check if globbing failed (returned glob pattern),
@@ -443,7 +458,7 @@ x_file_glob(int *flagsp, char *toglob, c
 		 * to glob something which evaluated to an empty
 		 * string (e.g., "$FOO" when there is no FOO, etc).
 		 */
-		if ((strcmp(words[0], toglob) == 0 &&
+		if ((strcmp(words[0], qglob) == 0 &&
 		    stat(words[0], &statb) < 0) ||
 		    words[0][0] == '\0') {
 			x_free_words(nwords, words);
@@ -455,6 +470,9 @@ x_file_glob(int *flagsp, char *toglob, c
 	if ((*wordsp = nwords ? words : NULL) == NULL && words != NULL)
 		x_free_words(nwords, words);
 
+ out:
+	if (qglob != toglob)
+		afree(qglob, ATEMP);
 	return (nwords);
 }
 
@@ -670,7 +688,7 @@ x_cf_glob(int *flagsp, const char *buf,
 
 		if (*toglob == '~' && /* not vdirsep */ !vstrchr(toglob, '/')) {
 			/* neither for '~foo' (but '~foo/bar') */
-			*flagsp |= XCF_IS_NOSPACE;
+			*flagsp |= XCF_IS_HOMEDIR;
 			goto dont_add_glob;
 		}
 
@@ -886,9 +904,63 @@ x_escape(const char *s, size_t len, int
 	return (rval);
 }
 
-
 /* +++ emacs editing mode +++ */
 
+/*-
+ * The input buffer "buf" is pointed to by "xbuf" and its end is
+ * pointed to by "xend".  The current position in "xbuf" and end of
+ * the edit line are pointed to by "xcp" and "xep" respectively.
+ * "xbp" points to the start of a display window within "xbuf", and
+ * "xlp" points to the last visible character on screen, if valid;
+ * "xdp" points to the end of x_displen, adding one-column bytes if
+ * necessary when the input line is shorter.
+ *
+ * [A] starting position
+ *
+ *      buf
+ * |<--------- $COLUMNS -------->|
+ *      |<---- x_displen ------->|
+ *  PS1 |
+ *      +=====+=========+........+.............................+
+ *      |\     \        |\        \                             \
+ *   xbuf xbp   xcp   xlp xep      xdp                           xend
+ *
+ * [B] larger input line
+ *
+ *      buf
+ * |<--------- $COLUMNS -------->|
+ *      |<---- x_displen ------->|
+ *  PS1 |
+ *      +===========+============+---------------------+.......+
+ *      |\          \             \                     \       \
+ *   xbuf xbp        xcp           xlp=xdp               xep     xend
+ *
+ * [C] scrolled
+ *
+ *      buf
+ *      |       |<--------- $COLUMNS -------->|
+ *      |       |<--------- x_displen ------->|
+ *      |
+ *      +-------+==============+==============+--------+.......+
+ *      |        \              \              \        \       \
+ *   xbuf         xbp            xcp            xlp=xdp  xep     xend
+ *
+ * In the above -------- represents the current edit line while
+ * ===== represents that portion which is visible on the screen;
+ * ....... is unused space in buf. Note that initially xbp == xbuf
+ * and PS1 is displayed. PS1 uses some of the screen width and thus
+ * "x_displen" is less than $COLUMNS.
+ *
+ * Any time that "xcp" moves outside the region bounded by "xbp"
+ * and "xbp" + "x_displen", the function x_adjust() is called to
+ * relocate "xbp" appropriately and redraw the line.
+ *
+ * Excessive I/O is avoided where possible.  x_goto() for instance
+ * calculates whether the destination is outside the visible
+ * region, and if so simply adjusts "xcp" and calls x_adjust()
+ * directly.  Normally though x_adjust() is called from x_putc().
+ */
+
 static	Area	aedit;
 #define	AEDIT	&aedit		/* area for kill ring and macro defns */
 
@@ -913,9 +985,6 @@ struct x_defbindings {
 #define	XF_NOBIND	2	/* not allowed to bind to function */
 #define	XF_PREFIX	4	/* function sets prefix */
 
-#define X_NTABS		4			/* normal, meta1, meta2, pc */
-#define X_TABSZ		256			/* size of keydef tables etc */
-
 /*-
  * Arguments for do_complete()
  * 0 = enumerate	M-=	complete as much as possible and then list
@@ -937,17 +1006,19 @@ static char *xcp;		/* current position *
 static char *xep;		/* current end */
 static char *xbp;		/* start of visible portion of input buffer */
 static char *xlp;		/* last char visible on screen */
+static char *xdp;		/* xbuf + x_displen except multibyte-aware */
 static bool x_adj_ok;
 /*
  * we use x_adj_done so that functions can tell
  * whether x_adjust() has been called while they are active.
  */
-static int x_adj_done;		/* is incremented by x_adjust() */
+static kby x_adj_done;		/* is incremented by x_adjust() */
 
 static int x_displen;
 static int x_arg;		/* general purpose arg */
 static bool x_arg_defaulted;	/* x_arg not explicitly set; defaulted to 1 */
 
+/* indicates both xlp and xdp are valid (x_goto needs the latter) */
 static bool xlp_valid;		/* lastvis pointer was recalculated */
 
 static char **x_histp;		/* history position */
@@ -956,18 +1027,16 @@ static char **x_histncp;	/* saved x_hist
 static char **x_histmcp;	/* saved x_histp for " */
 static char *xmp;		/* mark pointer */
 static unsigned char x_last_command;
-static unsigned char (*x_tab)[X_TABSZ];	/* key definition */
+static kby x_curprefix;
+static kby *x_btab;		/* bitmap of keys bound by the user */
+static kby *x_ktab;		/* key definitions */
 #ifndef MKSH_SMALL
-static char *(*x_atab)[X_TABSZ];	/* macro definitions */
+static char **x_mtab;		/* macro definitions */
+static char *macroptr;		/* bind key macro active? */
 #endif
-static unsigned char x_bound[(X_TABSZ * X_NTABS + 7) / 8];
 #define KILLSIZE	20
 static char *killstack[KILLSIZE];
 static int killsp, killtp;
-static int x_curprefix;
-#ifndef MKSH_SMALL
-static char *macroptr;		/* bind key macro active? */
-#endif
 #if !MKSH_S_NOVI
 static int winwidth;		/* width of window */
 static char *wbuf[2];		/* window buffers */
@@ -980,17 +1049,22 @@ static int pwidth;		/* width of prompt *
 static int prompt_trunc;	/* how much of prompt to truncate or -1 */
 static int x_col;		/* current column on line */
 
-static int x_ins(const char *);
+/* normal, prefix1, prefix2, IBM PC, ^V (literal) */
+#define X_NTABS			4U
+#define X_NOTAB			0xFFU
+/* array indicēs; x_btab is inlined, bitmap at only two places */
+#define X_xTABidx(pfx,key)	((KBI(pfx) << 8) | KBI(key))
+#define X_KTAB(pfx,key)		x_ktab[X_xTABidx((pfx), (key))]
+#define X_MTAB(pfx,key)		x_mtab[X_xTABidx((pfx), (key))]
+
+static int x_ins(const void *);
 static void x_delete(size_t, bool);
-static size_t x_bword(void);
-static size_t x_fword(bool);
+static void x_bword(uint32_t, bool);
+static void x_fword(uint32_t, bool);
 static void x_goto(char *);
-static char *x_bs0(char *, char *) MKSH_A_PURE;
 static void x_bs3(char **);
-static int x_size2(char *, char **);
-static void x_zots(char *);
-static void x_zotc3(char **);
-static void x_vi_zotc(int);
+static void x_uescs(char *);
+static void x_uescmb(char **);
 static void x_load_hist(char **);
 static int x_search(const char *, int, int);
 #ifndef MKSH_SMALL
@@ -999,14 +1073,13 @@ static int x_search_dir(int);
 static int x_match(const char *, const char *);
 static void x_redraw(int);
 static void x_push(size_t);
-static void x_bind_showone(int, int);
+static void x_bind_showone(kui, kui);
 static void x_e_ungetc(int);
 static int x_e_getc(void);
-static void x_e_putc2(int);
-static void x_e_putc3(const char **);
+static void x_e_putb(int);
 static void x_e_puts(const char *);
 #ifndef MKSH_SMALL
-static int x_fold_case(int);
+static int x_fold_case(int, uint32_t);
 #endif
 static char *x_lastcp(void);
 static void x_lastpos(void);
@@ -1042,6 +1115,12 @@ static struct x_defbindings const x_defb
 	{ XFUNC_mv_bword,		1,	'b'	},
 	{ XFUNC_mv_fword,		1,	'f'	},
 	{ XFUNC_del_fword,		1,	'd'	},
+#ifndef MKSH_SMALL
+	{ XFUNC_del_bbigword,		1,	'H'	},
+	{ XFUNC_mv_bbigword,		1,	'B'	},
+	{ XFUNC_mv_fbigword,		1,	'F'	},
+	{ XFUNC_del_fbigword,		1,	'D'	},
+#endif
 	{ XFUNC_mv_back,		0,  CTRL_B	},
 	{ XFUNC_mv_forw,		0,  CTRL_F	},
 	{ XFUNC_search_char_forw,	0,  CTRL_BC	},
@@ -1079,7 +1158,7 @@ static struct x_defbindings const x_defb
 	{ XFUNC_list_comm,		2,	'?'	},
 	{ XFUNC_list_file,		2,  CTRL_Y	},
 	{ XFUNC_set_mark,		1,	' '	},
-	{ XFUNC_kill_region,		0,  CTRL_W	},
+	{ XFUNC_kill_region,		1,  CTRL_W	},
 	{ XFUNC_xchg_point_mark,	2,  CTRL_X	},
 	{ XFUNC_literal,		0,  CTRL_V	},
 	{ XFUNC_version,		1,  CTRL_V	},
@@ -1096,11 +1175,11 @@ static struct x_defbindings const x_defb
 	{ XFUNC_set_arg,		1,	'8'	},
 	{ XFUNC_set_arg,		1,	'9'	},
 #ifndef MKSH_SMALL
-	{ XFUNC_fold_upper,		1,	'U'	},
+	{ XFUNC_foldb_upper,		1,	'U'	},
 	{ XFUNC_fold_upper,		1,	'u'	},
-	{ XFUNC_fold_lower,		1,	'L'	},
+	{ XFUNC_foldb_lower,		1,	'L'	},
 	{ XFUNC_fold_lower,		1,	'l'	},
-	{ XFUNC_fold_capitalise,	1,	'C'	},
+	{ XFUNC_foldb_capitalise,	1,	'C'	},
 	{ XFUNC_fold_capitalise,	1,	'c'	},
 #endif
 	/*
@@ -1158,7 +1237,7 @@ x_nb2nc(size_t nb)
 	size_t nc = 0;
 
 	for (cp = xcp; cp < (xcp + nb); ++nc)
-		cp += utf_ptradj(cp);
+		cp += ez_mbtoc(NULL, cp);
 	return (nc);
 }
 
@@ -1175,39 +1254,45 @@ x_modified(void)
 #ifdef MKSH_SMALL
 #define XFUNC_VALUE(f) (f)
 #else
-#define XFUNC_VALUE(f) (f & 0x7F)
+#define XFUNC_VALUE(f) (f & 0x7FU)
 #endif
 
 static int
-x_e_getmbc(char *sbuf)
+x_e_getmbc(char *buf)
 {
-	int c, pos = 0;
-	unsigned char *buf = (unsigned char *)sbuf;
+	int c, pos;
+	kby f;
 
-	memset(buf, 0, 4);
-	buf[pos++] = c = x_e_getc();
-	if (c == -1)
+	if ((c = x_e_getc()) == -1)
 		return (-1);
-	if (UTFMODE) {
-		if ((rtt2asc(buf[0]) >= (unsigned char)0xC2) &&
-		    (rtt2asc(buf[0]) < (unsigned char)0xF0)) {
-			c = x_e_getc();
-			if (c == -1)
-				return (-1);
-			if ((rtt2asc(c) & 0xC0) != 0x80) {
-				x_e_ungetc(c);
-				return (1);
-			}
-			buf[pos++] = c;
+	buf[0] = c;
+	if (!UTFMODE) {
+		buf[1] = '\0';
+		return (1);
+	}
+
+	pos = 1;
+	f = rtt2asc(c);
+	if (f >= 0xC2U && f < 0xF0U) {
+		if ((c = x_e_getc()) == -1)
+			return (-1);
+		if ((rtt2asc(c) & 0xC0U) != 0x80U) {
+			x_e_ungetc(c);
+			goto out;
 		}
-		if ((rtt2asc(buf[0]) >= (unsigned char)0xE0) &&
-		    (rtt2asc(buf[0]) < (unsigned char)0xF0)) {
-			/* XXX x_e_ungetc is one-octet only */
-			buf[pos++] = c = x_e_getc();
-			if (c == -1)
+		buf[pos++] = c;
+		if (f >= 0xE0U) {
+			if ((c = x_e_getc()) == -1)
 				return (-1);
+			/* XXX x_e_ungetc is one-octet only */
+			if ((rtt2asc(c) & 0xC0U) != 0x80U)
+				x_e_ungetc(c);
+			else
+				buf[pos++] = c;
 		}
 	}
+ out:
+	buf[pos] = '\0';
 	return (pos);
 }
 
@@ -1228,11 +1313,11 @@ x_init_prompt(bool doprint)
 		prompt_trunc = -1;
 		pwidth = 0;
 		if (doprint)
-			x_e_putc2('\n');
+			x_e_putb('\n');
 	}
 }
 
-static int
+static ssize_t
 x_emacs(char *buf)
 {
 	int c, i;
@@ -1242,14 +1327,17 @@ x_emacs(char *buf)
 	xend = buf + LINE;
 	xlp = xcp = xep = buf;
 	*xcp = 0;
-	xlp_valid = true;
 	xmp = NULL;
 	x_curprefix = 0;
 	x_histmcp = x_histp = histptr + 1;
 	x_last_command = XFUNC_error;
 
+	xx_cols = x_cols;
+	x_adj_ok = false;
 	x_init_prompt(true);
-	x_displen = (xx_cols = x_cols) - 2 - (x_col = pwidth);
+	x_displen = xx_cols - 2 - (x_col = pwidth);
+	xdp = xbp + x_displen;
+	xlp_valid = true;
 	x_adj_done = 0;
 	x_adj_ok = true;
 
@@ -1266,10 +1354,10 @@ x_emacs(char *buf)
 	while (/* CONSTCOND */ 1) {
 		x_flush();
 		if ((c = x_e_getc()) < 0)
-			return (0);
+			return (-1);
 
-		f = x_curprefix == -1 ? XFUNC_insert :
-		    x_tab[x_curprefix][c];
+		f = x_curprefix == X_NOTAB ? XFUNC_insert :
+		    X_KTAB(x_curprefix, c);
 #ifndef MKSH_SMALL
 		if (f & 0x80) {
 			f &= 0x7F;
@@ -1287,7 +1375,7 @@ x_emacs(char *buf)
 			x_arg = 1;
 			x_arg_defaulted = true;
 		}
-		i = c | (x_curprefix << 8);
+		i = (int)X_xTABidx(x_curprefix, c);
 		x_curprefix = 0;
 		switch ((*x_ftab[f].xf_func)(i)) {
 		case KSTD:
@@ -1295,8 +1383,7 @@ x_emacs(char *buf)
 				x_last_command = f;
 			break;
 		case KEOL:
-			i = xep - xbuf;
-			return (i);
+			return (xep - xbuf);
 		case KINTR:
 			/* special case for interrupt */
 			x_intr(SIGINT, c);
@@ -1309,57 +1396,55 @@ x_emacs(char *buf)
 static int
 x_insert(int c)
 {
-	static int left, pos, save_arg;
-	static char str[4];
+	static kby str[5], state;
+	static int save_arg;
+	kby b;
 
 	/*
 	 * Should allow tab and control chars.
 	 */
 	if (c == 0) {
- invmbs:
-		left = 0;
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
+		state = 0;
 		return (KSTD);
 	}
-	if (UTFMODE) {
-		if (((rtt2asc(c) & 0xC0) == 0x80) && left) {
-			str[pos++] = c;
-			if (!--left) {
-				str[pos] = '\0';
-				x_arg = save_arg;
-				while (x_arg--)
-					x_ins(str);
-			}
-			return (KSTD);
-		}
-		if (left) {
-			if (x_curprefix == -1) {
-				/* flush invalid multibyte */
-				str[pos] = '\0';
-				while (save_arg--)
-					x_ins(str);
-			}
-		}
-		if ((c >= 0xC2) && (c < 0xE0))
-			left = 1;
-		else if ((c >= 0xE0) && (c < 0xF0))
-			left = 2;
-		else if (c > 0x7F)
-			goto invmbs;
-		else
-			left = 0;
-		if (left) {
-			save_arg = x_arg;
-			pos = 1;
-			str[0] = c;
-			return (KSTD);
-		}
+	if (!UTFMODE) {
+ sbc:
+		str[0] = c;
+		str[1] = '\0';
+ mbc:
+		while (x_arg--)
+			x_ins(str);
+		state = 0;
+		return (KSTD);
 	}
-	left = 0;
+	b = rtt2asc(c);
+	if (state) {
+		/* this a continuation octet? */
+		if ((b & 0xC0U) == 0x80U) {
+			/* states: 1, 5, 6 */
+			str[state & 3] = c;
+			++state;
+			/* states: 2, 6, 7 */
+			if (state == 6)
+				/* another octet needed */
+				return (KSTD);
+			/* finishing up this multibyte character */
+			str[state & 3] = '\0';
+			x_arg = save_arg;
+			goto mbc;
+		}
+		/* flush invalid multibyte octets */
+		str[state & 3] = '\0';
+		while (save_arg--)
+			x_ins(str);
+		/* begin a new multibyte character */
+	}
+	if (b < 0xC2U || b >= 0xF0)
+		goto sbc;
+	state = b < 0xE0U ? 1 : 5;
 	str[0] = c;
-	str[1] = '\0';
-	while (x_arg--)
-		x_ins(str);
+	save_arg = x_arg;
 	return (KSTD);
 }
 
@@ -1367,7 +1452,7 @@ x_insert(int c)
 static int
 x_ins_string(int c)
 {
-	macroptr = x_atab[c >> 8][c & 255];
+	macroptr = x_mtab[KUI(c)];
 	/*
 	 * we no longer need to bother checking if macroptr is
 	 * not NULL but first char is NUL; x_e_getc() does it
@@ -1380,7 +1465,7 @@ static int
 x_do_ins(const char *cp, size_t len)
 {
 	if (xep + len >= xend) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (-1);
 	}
 	memmove(xcp + len, xcp, xep - xcp + 1);
@@ -1392,21 +1477,21 @@ x_do_ins(const char *cp, size_t len)
 }
 
 static int
-x_ins(const char *s)
+x_ins(const void *s)
 {
 	char *cp = xcp;
-	int adj = x_adj_done;
+	kby adj = x_adj_done;
 
 	if (x_do_ins(s, strlen(s)) < 0)
 		return (-1);
 	/*
-	 * x_zots() may result in a call to x_adjust()
-	 * we want xcp to reflect the new position.
+	 * x_uescs() may result in a call to x_adjust()
+	 * we want xcp to reflect the new position
 	 */
 	xlp_valid = false;
 	x_lastcp();
 	x_adj_ok = tobool(xcp >= xlp);
-	x_zots(cp);
+	x_uescs(cp);
 	if (adj == x_adj_done)
 		/* x_adjust() has not been called */
 		x_lastpos();
@@ -1420,7 +1505,7 @@ x_del_back(int c MKSH_A_UNUSED)
 	ssize_t i = 0;
 
 	if (xcp == xbuf) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	do {
@@ -1438,7 +1523,7 @@ x_del_char(int c MKSH_A_UNUSED)
 
 	cp = xcp;
 	while (i < (size_t)x_arg) {
-		utf_ptradjx(cp, cp2);
+		cp2 = cp + ez_mbtoc(NULL, cp);
 		if (cp2 > xep)
 			break;
 		cp = cp2;
@@ -1446,7 +1531,7 @@ x_del_char(int c MKSH_A_UNUSED)
 	}
 
 	if (!i) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	x_delete(i, false);
@@ -1469,7 +1554,7 @@ x_delete(size_t nc, bool push)
 		char *cp2;
 		int j;
 
-		j = x_size2(cp, &cp2);
+		j = uwidthmbT(cp, &cp2);
 		if (cp2 > xep)
 			break;
 		cp = cp2;
@@ -1496,7 +1581,7 @@ x_delete(size_t nc, bool push)
 	/* don't redraw */
 	x_adj_ok = false;
 	xlp_valid = false;
-	x_zots(xcp);
+	x_uescs(xcp);
 	/*
 	 * if we are already filling the line,
 	 * there is no need to ' ', '\b'.
@@ -1505,13 +1590,13 @@ x_delete(size_t nc, bool push)
 	if ((i = xx_cols - 2 - x_col) > 0 || xep - xlp == 0) {
 		nw = i = (nw < i) ? nw : i;
 		while (i--)
-			x_e_putc2(' ');
+			x_e_putb(' ');
 		if (x_col == xx_cols - 2) {
-			x_e_putc2((xep > xlp) ? '>' : (xbp > xbuf) ? '<' : ' ');
+			x_e_putb((xep > xlp) ? '>' : (xbp > xbuf) ? '<' : ' ');
 			++nw;
 		}
 		while (nw--)
-			x_e_putc2('\b');
+			x_e_putb('\b');
 	}
 	/*x_goto(xcp);*/
 	x_adj_ok = true;
@@ -1524,82 +1609,121 @@ x_delete(size_t nc, bool push)
 static int
 x_del_bword(int c MKSH_A_UNUSED)
 {
-	x_delete(x_bword(), true);
+	x_bword(C_MFS, true);
 	return (KSTD);
 }
 
 static int
 x_mv_bword(int c MKSH_A_UNUSED)
 {
-	x_bword();
+	x_bword(C_MFS, false);
 	return (KSTD);
 }
 
 static int
 x_mv_fword(int c MKSH_A_UNUSED)
 {
-	x_fword(true);
+	x_fword(C_MFS, false);
 	return (KSTD);
 }
 
 static int
 x_del_fword(int c MKSH_A_UNUSED)
 {
-	x_delete(x_fword(false), true);
+	x_fword(C_MFS, true);
 	return (KSTD);
 }
 
-static size_t
-x_bword(void)
+#ifndef MKSH_SMALL
+static int
+x_del_bbigword(int c MKSH_A_UNUSED)
+{
+	x_bword(C_BLANK, true);
+	return (KSTD);
+}
+
+static int
+x_mv_bbigword(int c MKSH_A_UNUSED)
+{
+	x_bword(C_BLANK, false);
+	return (KSTD);
+}
+
+static int
+x_mv_fbigword(int c MKSH_A_UNUSED)
+{
+	x_fword(C_BLANK, false);
+	return (KSTD);
+}
+
+static int
+x_del_fbigword(int c MKSH_A_UNUSED)
+{
+	x_fword(C_BLANK, true);
+	return (KSTD);
+}
+#endif
+
+static void
+x_bword(uint32_t separator, bool erase)
 {
 	size_t nb = 0;
 	char *cp = xcp;
 
 	if (cp == xbuf) {
-		x_e_putc2(KSH_BEL);
-		return (0);
+		x_e_putb(KSH_BEL);
+		return;
 	}
 	while (x_arg--) {
-		while (cp != xbuf && ctype(cp[-1], C_MFS)) {
+		while (cp != xbuf && ctype(cp[-1], separator)) {
 			cp--;
 			nb++;
 		}
-		while (cp != xbuf && !ctype(cp[-1], C_MFS)) {
+		while (cp != xbuf && !ctype(cp[-1], separator)) {
 			cp--;
 			nb++;
 		}
 	}
 	x_goto(cp);
-	return (x_nb2nc(nb));
+	if (erase)
+		x_delete(x_nb2nc(nb), true);
 }
 
-static size_t
-x_fword(bool move)
+static void
+x_fword(uint32_t separator, bool erase)
 {
-	size_t nc;
 	char *cp = xcp;
 
 	if (cp == xep) {
-		x_e_putc2(KSH_BEL);
-		return (0);
+		x_e_putb(KSH_BEL);
+		return;
 	}
 	while (x_arg--) {
-		while (cp != xep && ctype(*cp, C_MFS))
+		while (cp != xep && ctype(*cp, separator))
 			cp++;
-		while (cp != xep && !ctype(*cp, C_MFS))
+		while (cp != xep && !ctype(*cp, separator))
 			cp++;
 	}
-	nc = x_nb2nc(cp - xcp);
-	if (move)
+	if (erase)
+		x_delete(x_nb2nc(cp - xcp), true);
+	else
 		x_goto(cp);
-	return (nc);
+}
+
+static void
+x_uescmb(char **cp)
+{
+	unsigned char esc[5];
+
+	uescmbT(esc, (const char **)cp);
+	x_e_puts((const void *)esc);
 }
 
 static void
 x_goto(char *cp)
 {
-	cp = cp >= xep ? xep : x_bs0(cp, xbuf);
-	if (cp < xbp || cp >= utf_skipcols(xbp, x_displen, NULL)) {
+	cp = cp >= xep ? xep : ez_bs(cp, xbuf);
+	if (cp < xbp || (x_lastcp(), cp >= xdp)) {
 		/* we are heading off screen */
 		xcp = cp;
 		x_adjust();
@@ -1610,81 +1734,36 @@ x_goto(char *cp)
 	} else if (cp > xcp) {
 		/* move forward */
 		while (cp > xcp)
-			x_zotc3(&xcp);
+			x_uescmb(&xcp);
 	}
 }
 
-static char *
-x_bs0(char *cp, char *lower_bound)
-{
-	if (UTFMODE)
-		while ((!lower_bound || (cp > lower_bound)) &&
-		    ((rtt2asc(*cp) & 0xC0) == 0x80))
-			--cp;
-	return (cp);
-}
-
 static void
 x_bs3(char **p)
 {
 	int i;
 
-	*p = x_bs0((*p) - 1, NULL);
-	i = x_size2(*p, NULL);
+	*p = ez_bs((*p) - 1, xbuf);
+	i = uwidthmbT(*p, NULL);
 	while (i--)
-		x_e_putc2('\b');
-}
-
-static int
-x_size2(char *cp, char **dcp)
-{
-	uint8_t c = *(unsigned char *)cp;
-
-	if (UTFMODE && (rtt2asc(c) > 0x7F))
-		return (utf_widthadj(cp, (const char **)dcp));
-	if (dcp)
-		*dcp = cp + 1;
-	if (c == '\t')
-		/* Kludge, tabs are always four spaces. */
-		return (4);
-	if (ksh_isctrl(c))
-		/* control unsigned char */
-		return (2);
-	return (1);
+		x_e_putb('\b');
 }
 
 static void
-x_zots(char *str)
+x_uescs(char *str)
 {
-	int adj = x_adj_done;
+	kby adj = x_adj_done;
 
 	x_lastcp();
 	while (*str && str < xlp && x_col < xx_cols && adj == x_adj_done)
-		x_zotc3(&str);
-}
-
-static void
-x_zotc3(char **cp)
-{
-	unsigned char c = **(unsigned char **)cp;
-
-	if (c == '\t') {
-		/* Kludge, tabs are always four spaces. */
-		x_e_puts(T4spaces);
-		(*cp)++;
-	} else if (ksh_isctrl(c)) {
-		x_e_putc2('^');
-		x_e_putc2(ksh_unctrl(c));
-		(*cp)++;
-	} else
-		x_e_putc3((const char **)cp);
+		x_uescmb(&str);
 }
 
 static int
 x_mv_back(int c MKSH_A_UNUSED)
 {
 	if (xcp == xbuf) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	while (x_arg--) {
@@ -1701,11 +1780,11 @@ x_mv_forw(int c MKSH_A_UNUSED)
 	char *cp = xcp, *cp2;
 
 	if (xcp == xep) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	while (x_arg--) {
-		utf_ptradjx(cp, cp2);
+		cp2 = cp + ez_mbtoc(NULL, cp);
 		if (cp2 > xep)
 			break;
 		cp = cp2;
@@ -1718,17 +1797,17 @@ static int
 x_search_char_forw(int c MKSH_A_UNUSED)
 {
 	char *cp = xcp;
-	char tmp[4];
+	char tmp[5];
 
 	*xep = '\0';
 	if (x_e_getmbc(tmp) < 0) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	while (x_arg--) {
-		if ((cp = (cp == xep) ? NULL : strstr(cp + 1, tmp)) == NULL &&
-		    (cp = strstr(xbuf, tmp)) == NULL) {
-			x_e_putc2(KSH_BEL);
+		if ((cp = (cp == xep) ? NULL : ucstrstr(cp + 1, tmp)) == NULL &&
+		    (cp = ucstrstr(xbuf, tmp)) == NULL) {
+			x_e_putb(KSH_BEL);
 			return (KSTD);
 		}
 	}
@@ -1739,11 +1818,11 @@ x_search_char_forw(int c MKSH_A_UNUSED)
 static int
 x_search_char_back(int c MKSH_A_UNUSED)
 {
-	char *cp = xcp, *p, tmp[4];
+	char *cp = xcp, *p, tmp[5];
 	bool b;
 
 	if (x_e_getmbc(tmp) < 0) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	for (; x_arg--; cp = p)
@@ -1751,7 +1830,7 @@ x_search_char_back(int c MKSH_A_UNUSED)
 			if (p-- == xbuf)
 				p = xep;
 			if (p == cp) {
-				x_e_putc2(KSH_BEL);
+				x_e_putb(KSH_BEL);
 				return (KSTD);
 			}
 			if ((tmp[1] && ((p+1) > xep)) ||
@@ -1774,8 +1853,8 @@ x_search_char_back(int c MKSH_A_UNUSED)
 static int
 x_newline(int c MKSH_A_UNUSED)
 {
-	x_e_putc2('\r');
-	x_e_putc2('\n');
+	x_e_putb('\r');
+	x_e_putb('\n');
 	x_flush();
 	*xep++ = '\n';
 	return (KEOL);
@@ -1784,11 +1863,12 @@ x_newline(int c MKSH_A_UNUSED)
 static int
 x_end_of_text(int c MKSH_A_UNUSED)
 {
-	unsigned char tmp[1], *cp = tmp;
+	unsigned char tmp[2], *cp = tmp;
 
 	*tmp = isedchar(edchars.eof) ? (unsigned char)edchars.eof :
 	    (unsigned char)CTRL_D;
-	x_zotc3((char **)&cp);
+	tmp[1] = '\0';
+	x_uescmb((char **)&cp);
 	x_putc('\r');
 	x_putc('\n');
 	x_flush();
@@ -1847,7 +1927,7 @@ x_load_hist(char **hp)
 		sp = holdbufp;
 		modified = 0;
 	} else if (hp < history || hp > histptr) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return;
 	}
 	if (sp == NULL)
@@ -1901,12 +1981,12 @@ x_search_hist(int c)
 		x_flush();
 		if ((c = x_e_getc()) < 0)
 			return (KSTD);
-		f = x_tab[0][c];
-		if (c == CTRL_BO) {
+		f = X_KTAB(0, c);
+		if (ord(c) == CTRL_BO) {
 			if ((f & 0x7F) == XFUNC_meta1) {
 				if ((c = x_e_getc()) < 0)
 					return (KSTD);
-				f = x_tab[1][c] & 0x7F;
+				f = X_KTAB(1, c) & 0x7F;
 				if (f == XFUNC_meta1 || f == XFUNC_meta2)
 					x_meta1(CTRL_BO);
 				x_e_ungetc(c);
@@ -1928,7 +2008,7 @@ x_search_hist(int c)
 				break;
 			}
 			if (p > pat) {
-				p = x_bs0(p - 1, pat);
+				p = ez_bs(p - 1, pat);
 				*p = '\0';
 			}
 			if (p == pat)
@@ -1940,7 +2020,7 @@ x_search_hist(int c)
 			/* add char to pattern */
 			/* overflow check... */
 			if ((size_t)(p - pat) >= sizeof(pat) - 1) {
-				x_e_putc2(KSH_BEL);
+				x_e_putb(KSH_BEL);
 				continue;
 			}
 			*p++ = c, *p = '\0';
@@ -1983,13 +2063,13 @@ x_search(const char *pat, int sameline,
 		i = x_match(*hp, pat);
 		if (i >= 0) {
 			if (offset < 0)
-				x_e_putc2('\n');
+				x_e_putb('\n');
 			x_load_hist(hp);
 			x_goto(xbuf + i + patlen);
 			return (i);
 		}
 	}
-	x_e_putc2(KSH_BEL);
+	x_e_putb(KSH_BEL);
 	x_histp = histptr;
 	return (-1);
 }
@@ -2035,7 +2115,7 @@ x_match(const char *str, const char *pat
 	if (*pat == '^') {
 		return ((strncmp(str, pat + 1, strlen(pat + 1)) == 0) ? 0 : -1);
 	} else {
-		char *q = strstr(str, pat);
+		const char *q = cstrstr(str, pat);
 		return ((q == NULL) ? -1 : q - str);
 	}
 }
@@ -2046,6 +2126,7 @@ x_del_line(int c MKSH_A_UNUSED)
 	*xep = 0;
 	x_push(xep - (xcp = xbuf));
 	xlp = xbp = xep = xbuf;
+	xdp = xbp + x_displen;
 	xlp_valid = true;
 	*xcp = 0;
 	xmp = NULL;
@@ -2079,6 +2160,11 @@ static int
 x_cls(int c MKSH_A_UNUSED)
 {
 	shf_puts(MKSH_CLS_STRING, shl_out);
+	if (prompt_trunc) {
+		/* multi-line prompt */
+		pprompt(prompt, 0);
+		/* x_redraw takes care of the last line */
+	}
 	x_redraw(0);
 	return (KSTD);
 }
@@ -2094,12 +2180,14 @@ x_clrtoeol(int lastch, bool line_was_cle
 {
 	int col;
 
-	if (lastch == ' ' && !line_was_cleared && x_term_mode == 1) {
-		shf_puts(KSH_ESC_STRING "[K", shl_out);
-		line_was_cleared = true;
+	if (lastch == ' ') {
+		if (line_was_cleared)
+			return;
+		if (x_term_mode == 1) {
+			shf_puts(KSH_ESC_STRING "[K", shl_out);
+			return;
+		}
 	}
-	if (lastch == ' ' && line_was_cleared)
-		return;
 
 	col = x_col;
 	while (col < (xx_cols - 2)) {
@@ -2131,7 +2219,7 @@ x_redraw(int cr)
 
 	x_adj_ok = false;
 	/* clear the line */
-	x_e_putc2(cr ? cr : '\r');
+	x_e_putb(cr ? cr : '\r');
 	x_flush();
 	/* display the prompt */
 	if (xbp == xbuf)
@@ -2139,7 +2227,7 @@ x_redraw(int cr)
 	x_displen = xx_cols - 2 - x_col;
 	/* display the line content */
 	xlp_valid = false;
-	x_zots(xbp);
+	x_uescs(xbp);
 	/* check whether there is more off-screen */
 	lch = xep > xlp ? (xbp > xbuf ? '*' : '>') : (xbp > xbuf) ? '<' : ' ';
 	/* clear the rest of the line */
@@ -2161,19 +2249,20 @@ x_transpose(int c MKSH_A_UNUSED)
 	 *	Who			Before	After	Before	After
 	 *	AT&T ksh in emacs mode:	abCd	abdC	abcd_	(bell)
 	 *	AT&T ksh in gmacs mode:	abCd	baCd	abcd_	abdc_
-	 *	gnu emacs:		abCd	acbD	abcd_	abdc_
-	 * Pdksh currently goes with GNU behavior since I believe this is the
+	 *	GNU emacs:		abCd	acbD	abcd_	abdc_
+	 * pdksh currently goes with GNU behavior since I believe this is the
 	 * most common version of emacs, unless in gmacs mode, in which case
 	 * it does the AT&T ksh gmacs mode.
 	 * This should really be broken up into 3 functions so users can bind
 	 * to the one they want.
 	 */
 	if (xcp == xbuf) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
-	} else if (xcp == xep || Flag(FGMACS)) {
+	}
+	if (xcp == xep || Flag(FGMACS)) {
 		if (xcp - xbuf == 1) {
-			x_e_putc2(KSH_BEL);
+			x_e_putb(KSH_BEL);
 			return (KSTD);
 		}
 		/*
@@ -2181,38 +2270,20 @@ x_transpose(int c MKSH_A_UNUSED)
 		 * the cursor, do not change cursor position
 		 */
 		x_bs3(&xcp);
-		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
-			x_e_putc2(KSH_BEL);
-			return (KSTD);
-		}
-		x_bs3(&xcp);
-		if (utf_mbtowc(&tmpb, xcp) == (size_t)-1) {
-			x_e_putc2(KSH_BEL);
-			return (KSTD);
-		}
-		utf_wctomb(xcp, tmpa);
-		x_zotc3(&xcp);
-		utf_wctomb(xcp, tmpb);
-		x_zotc3(&xcp);
-	} else {
-		/*
+	}
+	/* else
 		 * GNU emacs style: Swap the characters before and under the
 		 * cursor, move cursor position along one.
 		 */
-		if (utf_mbtowc(&tmpa, xcp) == (size_t)-1) {
-			x_e_putc2(KSH_BEL);
-			return (KSTD);
-		}
-		x_bs3(&xcp);
-		if (utf_mbtowc(&tmpb, xcp) == (size_t)-1) {
-			x_e_putc2(KSH_BEL);
-			return (KSTD);
-		}
-		utf_wctomb(xcp, tmpa);
-		x_zotc3(&xcp);
-		utf_wctomb(xcp, tmpb);
-		x_zotc3(&xcp);
-	}
+	ez_mbtoc(&tmpa, xcp);
+	x_bs3(&xcp);
+	ez_mbtoc(&tmpb, xcp);
+	/* ensure that swapping e.g. raw 0xA4 0xC3 doesn’t break separation */
+	xcp[ez_ctomb(xcp, tmpa)] = '\0';
+	x_uescmb(&xcp);
+	ez_ctomb(xcp, tmpb);
+	x_uescmb(&xcp);
+	/* though a ^L now re-recognises that, probably okay */
 	x_modified();
 	return (KSTD);
 }
@@ -2220,7 +2291,7 @@ x_transpose(int c MKSH_A_UNUSED)
 static int
 x_literal(int c MKSH_A_UNUSED)
 {
-	x_curprefix = -1;
+	x_curprefix = X_NOTAB;
 	return (KSTD);
 }
 
@@ -2318,12 +2389,13 @@ x_meta_yank(int c MKSH_A_UNUSED)
 static void
 x_intr(int signo, int c)
 {
-	x_vi_zotc(c);
+	uprntc(c, shl_out);
 	*xep = '\0';
 	strip_nuls(xbuf, xep - xbuf);
 	if (*xbuf)
 		histsave(&source->line, xbuf, HIST_STORE, true);
 	xlp = xep = xcp = xbp = xbuf;
+	xdp = xbp + x_displen;
 	xlp_valid = true;
 	*xcp = 0;
 	x_modified();
@@ -2342,7 +2414,7 @@ x_abort(int c MKSH_A_UNUSED)
 static int
 x_error(int c MKSH_A_UNUSED)
 {
-	x_e_putc2(KSH_BEL);
+	x_e_putb(KSH_BEL);
 	return (KSTD);
 }
 
@@ -2397,77 +2469,65 @@ x_vt_hack(int c)
 int
 x_bind_check(void)
 {
-	return (x_tab == NULL);
+	return (x_btab == NULL);
 }
 
-static XString x_bind_show_xs;
-static char *x_bind_show_xp;
+static char *x_bind_show_s;
+static size_t x_bind_show_n;
 
 static void
-x_bind_show_ch(unsigned char ch)
+x_bind_showone(kui prefix, kui key)
 {
-	Xcheck(x_bind_show_xs, x_bind_show_xp);
-	switch (ch) {
-	case ORD('^'):
-	case ORD('\\'):
-	case ORD('='):
-		*x_bind_show_xp++ = '\\';
-		*x_bind_show_xp++ = ch;
-		break;
-	default:
-		if (ksh_isctrl(ch)) {
-			*x_bind_show_xp++ = '^';
-			*x_bind_show_xp++ = ksh_unctrl(ch);
-		} else
-			*x_bind_show_xp++ = ch;
-		break;
-	}
-}
-
-static void
-x_bind_showone(int prefix, int key)
-{
-	unsigned char f = XFUNC_VALUE(x_tab[prefix][key]);
+	kby f = XFUNC_VALUE(X_KTAB(prefix, key));
+	struct shf shf;
 
-	if (!x_bind_show_xs.areap)
-		XinitN(x_bind_show_xs, 16, AEDIT);
+	if (!x_bind_show_n)
+		x_bind_show_s = aresize(x_bind_show_s,
+		    (x_bind_show_n = 12), AEDIT);
 
-	x_bind_show_xp = Xstring(x_bind_show_xs, x_bind_show_xp);
 	shf_puts("bind ", shl_stdout);
 #ifndef MKSH_SMALL
 	if (f == XFUNC_ins_string)
 		shf_puts("-m ", shl_stdout);
 #endif
+
+	shf_sreopen(x_bind_show_s, x_bind_show_n, AEDIT, &shf);
 	switch (prefix) {
 	case 1:
-		x_bind_show_ch(CTRL_BO);
+		uprntc(CTRL_BO, &shf);
 		break;
 	case 2:
-		x_bind_show_ch(CTRL_X);
+		uprntc(CTRL_X, &shf);
 		break;
 	case 3:
-		x_bind_show_ch(0);
+		uprntc(CTRL_AT, &shf);
+		break;
+	}
+	switch (key) {
+	case ORD('^'):
+	case ORD('\\'):
+	case ORD('='):
+		shf_putc('\\', &shf);
+		shf_putc(key, &shf);
 		break;
+	default:
+		uprntc(key, &shf);
 	}
-	x_bind_show_ch(key);
 #ifndef MKSH_SMALL
-	if (x_tab[prefix][key] & 0x80)
-		*x_bind_show_xp++ = '~';
+	if (X_KTAB(prefix, key) & 0x80U)
+		shf_putc('~', &shf);
 #endif
-	*x_bind_show_xp = '\0';
-	x_bind_show_xp = Xstring(x_bind_show_xs, x_bind_show_xp);
-	print_value_quoted(shl_stdout, x_bind_show_xp);
+	x_bind_show_n = shf.wbsize;
+	x_bind_show_s = shf_sclose(&shf);
+	print_value_quoted(shl_stdout, x_bind_show_s);
 	shf_putc('=', shl_stdout);
 #ifndef MKSH_SMALL
 	if (f == XFUNC_ins_string) {
-		const unsigned char *cp = (const void *)x_atab[prefix][key];
-		unsigned char c;
-
-		while ((c = *cp++))
-			x_bind_show_ch(c);
-		*x_bind_show_xp = '\0';
-		x_bind_show_xp = Xstring(x_bind_show_xs, x_bind_show_xp);
-		print_value_quoted(shl_stdout, x_bind_show_xp);
+		shf_sreopen(x_bind_show_s, x_bind_show_n, AEDIT, &shf);
+		uprntmbs(X_MTAB(prefix, key), true, &shf);
+		x_bind_show_n = shf.wbsize;
+		x_bind_show_s = shf_sclose(&shf);
+		print_value_quoted(shl_stdout, x_bind_show_s);
 	} else
 #endif
 	  shf_puts(x_ftab[f].xf_name, shl_stdout);
@@ -2488,11 +2548,11 @@ x_bind_list(void)
 int
 x_bind_showall(void)
 {
-	int prefix, key;
+	kui prefix, key;
 
-	for (prefix = 0; prefix < X_NTABS; prefix++)
-		for (key = 0; key < X_TABSZ; key++)
-			switch (XFUNC_VALUE(x_tab[prefix][key])) {
+	for (prefix = 0; prefix < X_NTABS; ++prefix)
+		for (key = 0; key <= 0xFF; ++key)
+			switch (XFUNC_VALUE(X_KTAB(prefix, key))) {
 			case XFUNC_error:	/* unset */
 			case XFUNC_insert:	/* auto-insert */
 				break;
@@ -2503,28 +2563,69 @@ x_bind_showall(void)
 	return (0);
 }
 
-static unsigned int
-x_bind_getc(const char **ccpp)
+struct x_bind_getc {
+	const char *cp;
+	kby next;
+};
+
+static kui
+x_bind_getc(struct x_bind_getc *ctx)
 {
-	unsigned int ch, ec;
+	kui ch;
+	kby tmp[4];
 
-	if ((ch = ord(**ccpp)))
-		++(*ccpp);
+	if ((ch = ctx->next)) {
+		ctx->next = 0;
+		return (ch);
+	}
+	if ((ch = ord(*(ctx->cp))))
+		++(ctx->cp);
 	switch (ch) {
 	case ORD('^'):
-		ch = ksh_toctrl(**ccpp) | 0x100U;
-		if (**ccpp)
-			++(*ccpp);
+		if ((ch = ord(*(ctx->cp))))
+			++(ctx->cp);
+		switch (ch) {
+		case ORD('!'):
+			if ((ch = ord(*(ctx->cp))))
+				++(ctx->cp);
+			ch = asc2rtt((rtt2asc(ch) & 0x1FU) + 0x80U);
+			break;
+		case ORD('+'):
+			if ((ch = ord(*(ctx->cp))))
+				++(ctx->cp);
+			utf_wctomb((char *)tmp, (rtt2asc(ch) & 0x1FU) + 0x80U);
+			ch = tmp[0];
+			ctx->next = tmp[1];
+			break;
+		case ORD('?'):
+			ch = CTRL_QM;
+			break;
+		default:
+			ch = asc2rtt(rtt2asc(ch) & 0x1FU);
+			break;
+		}
 		break;
 	case ORD('\\'):
-		switch ((ec = ord(**ccpp))) {
-		case ORD('^'):
-		case ORD('\\'):
-		case ORD('='):
-			ch = ec | 0x100U;
-			++(*ccpp);
-			break;
+		if ((ch = ord(*(ctx->cp))))
+			++(ctx->cp);
+		if (ch == ORD('x') && ctype(ctx->cp[0], C_SEDEC) &&
+		    ctype(ctx->cp[1], C_SEDEC)) {
+			if (ctype(ctx->cp[0], C_DIGIT))
+				ch = ksh_numdig(ctx->cp[0]);
+			else if (ctype(ctx->cp[0], C_UPPER))
+				ch = ksh_numuc(ctx->cp[0]) + 10;
+			else
+				ch = ksh_numlc(ctx->cp[0]) + 10;
+			ch <<= 4;
+			if (ctype(ctx->cp[1], C_DIGIT))
+				ch |= ksh_numdig(ctx->cp[1]);
+			else if (ctype(ctx->cp[1], C_UPPER))
+				ch |= ksh_numuc(ctx->cp[1]) + 10;
+			else
+				ch |= ksh_numlc(ctx->cp[1]) + 10;
+			ctx->cp += 2;
 		}
+		ch |= 0x100U;
 		break;
 	}
 	return (ch);
@@ -2533,27 +2634,27 @@ x_bind_getc(const char **ccpp)
 int
 x_bind(const char *s SMALLP(bool macro))
 {
-	const char *ccp = s;
-	int prefix, key;
-	unsigned int c;
+	register kui t;
+	struct x_bind_getc state = { s, 0 };
+	kui c, key, prefix;
 #ifndef MKSH_SMALL
 	bool hastilde = false;
 	char *ms = NULL;
 #endif
 
 	prefix = 0;
-	c = x_bind_getc(&ccp);
+	c = x_bind_getc(&state);
 	if (!c || c == ORD('=')) {
 		bi_errorf("no key to bind");
 		return (1);
 	}
-	key = c & 0xFF;
-	while ((c = x_bind_getc(&ccp)) != ORD('=')) {
+	key = KBI(c);
+	while ((c = x_bind_getc(&state)) != ORD('=')) {
 		if (!c) {
 			x_bind_showone(prefix, key);
 			return (0);
 		}
-		switch (XFUNC_VALUE(x_tab[prefix][key])) {
+		switch (XFUNC_VALUE(X_KTAB(prefix, key))) {
 		case XFUNC_meta1:
 			prefix = 1;
 			if (0)
@@ -2564,7 +2665,7 @@ x_bind(const char *s SMALLP(bool macro))
 				/* FALLTHROUGH */
 		case XFUNC_meta3:
 			  prefix = 3;
-			key = c & 0xFF;
+			key = KBI(c);
 			continue;
 		}
 #ifndef MKSH_SMALL
@@ -2581,41 +2682,40 @@ x_bind(const char *s SMALLP(bool macro))
 	if (macro) {
 		char *cp;
 
-		cp = ms = alloc(strlen(ccp) + 1, AEDIT);
-		while ((c = x_bind_getc(&ccp)))
+		cp = ms = alloc(strlen(state.cp) + 1, AEDIT);
+		while ((c = x_bind_getc(&state)))
 			*cp++ = c;
 		*cp = '\0';
 		c = XFUNC_ins_string;
 	} else
 #endif
-	  if (!*ccp) {
+	  if (state.cp[0] == '\0') {
 		c = XFUNC_insert;
 	} else {
 		for (c = 0; c < NELEM(x_ftab); ++c)
-			if (!strcmp(x_ftab[c].xf_name, ccp))
+			if (!strcmp(x_ftab[c].xf_name, state.cp))
 				break;
 		if (c == NELEM(x_ftab) || x_ftab[c].xf_flags & XF_NOBIND) {
-			bi_errorf("%s: no such editing command", ccp);
+			bi_errorf("%s: no such editing command", state.cp);
 			return (1);
 		}
 	}
 
+	t = X_xTABidx(prefix, key);
 #ifndef MKSH_SMALL
-	if (XFUNC_VALUE(x_tab[prefix][key]) == XFUNC_ins_string)
-		afree(x_atab[prefix][key], AEDIT);
-	x_atab[prefix][key] = ms;
+	if (XFUNC_VALUE(x_ktab[t]) == XFUNC_ins_string)
+		afree(x_mtab[t], AEDIT);
+	x_mtab[t] = ms;
 	if (hastilde)
 		c |= 0x80U;
 #endif
-	x_tab[prefix][key] = c;
+	x_ktab[t] = c;
 
 	/* track what the user has bound, so x_mode(true) won't toast things */
 	if (c == XFUNC_insert)
-		x_bound[(prefix * X_TABSZ + key) / 8] &=
-		    ~(1 << ((prefix * X_TABSZ + key) % 8));
+		x_btab[t >> 3] &= ~BIT(t & 7);
 	else
-		x_bound[(prefix * X_TABSZ + key) / 8] |=
-		    (1 << ((prefix * X_TABSZ + key) % 8));
+		x_btab[t >> 3] |= BIT(t & 7);
 
 	return (0);
 }
@@ -2623,17 +2723,15 @@ x_bind(const char *s SMALLP(bool macro))
 static void
 bind_if_not_bound(int p, int k, int func)
 {
-	int t;
+	register kui t = X_xTABidx(p, k);
 
 	/*
 	 * Has user already bound this key?
 	 * If so, do not override it.
 	 */
-	t = p * X_TABSZ + k;
-	if (x_bound[t >> 3] & (1 << (t & 7)))
+	if (x_btab[t >> 3] & BIT(t & 7))
 		return;
-
-	x_tab[p][k] = func;
+	x_ktab[t] = func;
 }
 
 static int
@@ -2650,7 +2748,7 @@ x_kill_region(int c MKSH_A_UNUSED)
 	char *xr;
 
 	if (xmp == NULL) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	if (xmp > xcp) {
@@ -2672,7 +2770,7 @@ x_xchg_point_mark(int c MKSH_A_UNUSED)
 	char *tmp;
 
 	if (xmp == NULL) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	tmp = xmp;
@@ -2750,7 +2848,7 @@ x_expand(int c MKSH_A_UNUSED)
 	    &start, &end, &words);
 
 	if (nwords == 0) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	x_goto(xbuf + start);
@@ -2760,7 +2858,7 @@ x_expand(int c MKSH_A_UNUSED)
 	while (i < nwords) {
 		if (x_escape(words[i], strlen(words[i]), x_do_ins) < 0 ||
 		    (++i < nwords && x_ins(T1space) < 0)) {
-			x_e_putc2(KSH_BEL);
+			x_e_putb(KSH_BEL);
 			return (KSTD);
 		}
 	}
@@ -2784,7 +2882,7 @@ do_complete(
 	    &start, &end, &words);
 	/* no match */
 	if (nwords == 0) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return;
 	}
 	if (type == CT_LIST) {
@@ -2831,8 +2929,7 @@ do_complete(
 	}
 	if (completed) {
 		/* expand on the command line */
-		xmp = NULL;
-		xcp = xbuf + start;
+		xmp = xcp = xbuf + start;
 		xep -= olen;
 		memmove(xcp, xcp + olen, xep - xcp + 1);
 		x_escape(words[0], nlen, x_do_ins);
@@ -2840,11 +2937,13 @@ do_complete(
 	x_adjust();
 	/*
 	 * append a space if this is a single non-directory match
-	 * and not a parameter or homedir substitution
+	 * and not a parameter substitution, slash for homedir
 	 */
-	if (nwords == 1 && !mksh_cdirsep(words[0][nlen - 1]) &&
-	    !(flags & XCF_IS_NOSPACE)) {
-		x_ins(T1space);
+	if (nwords == 1 && !mksh_cdirsep(words[0][nlen - 1])) {
+		if (flags & XCF_IS_HOMEDIR)
+			x_ins("/");
+		else if (!(flags & XCF_IS_NOSPACE))
+			x_ins(T1space);
 	}
 
 	x_free_words(nwords, words);
@@ -2867,40 +2966,50 @@ do_complete(
 static void
 x_adjust(void)
 {
-	int col_left, n;
+	int colcur, colmax;
 
 	/* flag the fact that we were called */
 	x_adj_done++;
 
+	/* fix up xcp to just past a character end first */
+	xcp = xcp >= xep ? xep : ez_bs(xcp, xbuf);
+	/* shortcut if going to beginning of line */
+	if (xcp == (xbp = xbuf))
+		goto x_adjust_out;
+
+	/* check if the entire line fits */
+	x_displen = xx_cols - 2 - pwidth;
+	xlp_valid = false;
+	x_lastcp();
+	/* accept if the cursor is still in the editable area */
+	if (xcp < xdp /*|| xdp >= xep */)
+		goto x_adjust_out;
+
+	/* ok, that was a failure so we need to proceed backwards from xcp */
+	xbp = xcp;
+	/* assert xbp > xbuf */
+
 	/*
-	 * calculate the amount of columns we need to "go back"
-	 * from xcp to set xbp to (but never < xbuf) to 2/3 of
-	 * the display width; take care of pwidth though
+	 * if we have enough space left on screen, we aim to
+	 * position the cursor at 3/4 of the display width;
+	 * if not we emergency-fit just one character before…
 	 */
-	if ((col_left = xx_cols * 2 / 3) < MIN_EDIT_SPACE) {
-		/*
-		 * cowardly refuse to do anything
-		 * if the available space is too small;
-		 * fall back to dumb pdksh code
-		 */
-		if ((xbp = xcp - (x_displen / 2)) < xbuf)
-			xbp = xbuf;
-		/* elide UTF-8 fixup as penalty */
+	if ((colmax = xx_cols * 3 / 4) < MIN_EDIT_SPACE) {
+		/* one backwards though */
+		xbp = ez_bs(xbp - 1, xbuf);
+		/* go for it */
 		goto x_adjust_out;
 	}
 
-	/* fix up xbp to just past a character end first */
-	xbp = xcp >= xep ? xep : x_bs0(xcp, xbuf);
-	/* walk backwards */
-	while (xbp > xbuf && col_left > 0) {
-		xbp = x_bs0(xbp - 1, xbuf);
-		col_left -= (n = x_size2(xbp, NULL));
-	}
-	/* check if we hit the prompt */
-	if (xbp == xbuf && xcp != xbuf && col_left >= 0 && col_left < pwidth) {
-		/* so we did; force scrolling occurs */
-		xbp += utf_ptradj(xbp);
+	/* go backwards until we reached the target width */
+	colcur = 0;
+	while (xbp > xbuf && colcur < colmax) {
+		xbp = ez_bs(xbp - 1, xbuf);
+		colcur += uwidthmbT(xbp, NULL);
 	}
+	/* check if we hit the prompt and force scrolling if so */
+	if (xbp == xbuf)
+		xbp += ez_mbtoc(NULL, xbp);
 
  x_adjust_out:
 	xlp_valid = false;
@@ -2936,42 +3045,23 @@ x_e_getc(void)
 	return (x_getc());
 }
 
+/* takes single-column single-byte characters only */
 static void
-x_e_putc2(int c)
+x_e_putb(int c)
 {
-	int width = 1;
-
-	if (ctype(c, C_CR | C_LF))
+	if (ctype(c, C_CR | C_LF)) {
+		x_putc(c);
 		x_col = 0;
-	if (x_col < xx_cols) {
-#ifndef MKSH_EBCDIC
-		if (UTFMODE && (c > 0x7F)) {
-			char utf_tmp[3];
-			size_t x;
-
-			if (c < 0xA0)
-				c = 0xFFFD;
-			x = utf_wctomb(utf_tmp, c);
-			x_putc(utf_tmp[0]);
-			if (x > 1)
-				x_putc(utf_tmp[1]);
-			if (x > 2)
-				x_putc(utf_tmp[2]);
-			width = utf_wcwidth(c);
-		} else
-#endif
-			x_putc(c);
-		switch (c) {
-		case KSH_BEL:
-			break;
-		case '\r':
-		case '\n':
+	} else if (x_col < xx_cols) {
+		x_putc(c);
+		switch (ord(c)) {
+		case ORD(KSH_BEL):
 			break;
-		case '\b':
-			x_col--;
+		case ORD('\b'):
+			--x_col;
 			break;
 		default:
-			x_col += width;
+			++x_col;
 			break;
 		}
 	}
@@ -2980,58 +3070,50 @@ x_e_putc2(int c)
 }
 
 static void
-x_e_putc3(const char **cp)
+x_e_puts(const char *s)
 {
-	int width = 1, c = **(const unsigned char **)cp;
+	unsigned int c;
+	int width;
+	size_t len;
+	kby adj = x_adj_done;
 
-	if (ctype(c, C_CR | C_LF))
-		x_col = 0;
-	if (x_col < xx_cols) {
-		if (UTFMODE && (c > 0x7F)) {
-			char *cp2;
-
-			width = utf_widthadj(*cp, (const char **)&cp2);
-			if (cp2 == *cp + 1) {
-				(*cp)++;
-#ifdef MKSH_EBCDIC
-				x_putc(asc2rtt(0xEF));
-				x_putc(asc2rtt(0xBF));
-				x_putc(asc2rtt(0xBD));
-#else
-				shf_puts("\xEF\xBF\xBD", shl_out);
-#endif
-			} else
-				while (*cp < cp2)
-					x_putcf(*(*cp)++);
-		} else {
-			(*cp)++;
+	while ((c = ord(*s)) && adj == x_adj_done) {
+		if (ctype(c, C_CR | C_LF)) {
 			x_putc(c);
+			x_col = 0;
+			++s;
+		} else if (x_col < xx_cols) {
+			if (rtt2asc(c) < 0x80U || !UTFMODE) {
+				x_putc(c);
+				switch (c) {
+				case ORD(KSH_BEL):
+					break;
+				case ORD('\b'):
+					--x_col;
+					break;
+				default:
+					++x_col;
+					break;
+				}
+				++s;
+			} else if ((len = utf_mbtowc(&c, s)) == (size_t)-1) {
+				/* substitute U+FFFD */
+				x_putcf(asc2rtt(0xEF));
+				x_putcf(asc2rtt(0xBF));
+				x_putcf(asc2rtt(0xBD));
+				++x_col;
+				++s;
+			} else {
+				/* C1 control character? C0/DEL use 1 above */
+				if ((width = utf_wcwidth(c)) < 0)
+					width = /* for consistency */ 1;
+				shf_wr_sm(s, len, shl_out);
+				x_col += width;
+			}
 		}
-		switch (c) {
-		case KSH_BEL:
-			break;
-		case '\r':
-		case '\n':
-			break;
-		case '\b':
-			x_col--;
-			break;
-		default:
-			x_col += width;
-			break;
-		}
+		if (x_adj_ok && (x_col < 0 || x_col >= (xx_cols - 2)))
+			x_adjust();
 	}
-	if (x_adj_ok && (x_col < 0 || x_col >= (xx_cols - 2)))
-		x_adjust();
-}
-
-static void
-x_e_puts(const char *s)
-{
-	int adj = x_adj_done;
-
-	while (*s && adj == x_adj_done)
-		x_e_putc3(&s);
 }
 
 /*-
@@ -3052,7 +3134,8 @@ x_set_arg(int c)
 
 	/* strip command prefix */
 	c &= 255;
-	while (c >= 0 && ctype(c, C_DIGIT)) {
+	/* loop to get digits */
+	while (cinttype(c, C_DIGIT)) {
 		n = n * 10 + ksh_numdig(c);
 		if (n > LINE)
 			/* upper bound for repeat */
@@ -3062,7 +3145,7 @@ x_set_arg(int c)
 	}
 	if (c < 0 || first) {
  x_set_arg_too_big:
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		x_arg = 1;
 		x_arg_defaulted = true;
 	} else {
@@ -3081,7 +3164,7 @@ x_comment(int c MKSH_A_UNUSED)
 	int ret = x_do_comment(xbuf, xend - xbuf, &len);
 
 	if (ret < 0)
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 	else {
 		x_modified();
 		xep = xbuf + len;
@@ -3149,12 +3232,12 @@ x_edit_line(int c MKSH_A_UNUSED)
 
 /*-
  * NAME:
- *	x_prev_histword - recover word from prev command
+ *	x_prev_histword - recover bigword from prev command
  *
  * DESCRIPTION:
- *	This function recovers the last word from the previous
+ *	This function recovers the last bigword from the previous
  *	command and inserts it into the current edit line. If a
- *	numeric arg is supplied then the n'th word from the
+ *	numeric arg is supplied then the n'th bigword from the
  *	start of the previous command is used.
  *	As a side effect, trashes the mark in order to achieve
  *	being called in a repeatable fashion.
@@ -3182,7 +3265,7 @@ x_prev_histword(int c MKSH_A_UNUSED)
 		last_arg = x_arg_defaulted ? -1 : x_arg;
 	xhp = histptr - (m - 1);
 	if ((xhp < history) || !(cp = *xhp)) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		x_modified();
 		return (KSTD);
 	}
@@ -3192,13 +3275,13 @@ x_prev_histword(int c MKSH_A_UNUSED)
 
 		rcp = &cp[strlen(cp) - 1];
 		/*
-		 * ignore white-space after the last word
+		 * ignore whitespace after the last bigword
 		 */
-		while (rcp > cp && ctype(*rcp, C_CFS))
+		while (rcp > cp && ctype(*rcp, C_BLANK))
 			rcp--;
-		while (rcp > cp && !ctype(*rcp, C_CFS))
+		while (rcp > cp && !ctype(*rcp, C_BLANK))
 			rcp--;
-		if (ctype(*rcp, C_CFS))
+		if (ctype(*rcp, C_BLANK))
 			rcp++;
 		x_ins(rcp);
 	} else {
@@ -3207,18 +3290,18 @@ x_prev_histword(int c MKSH_A_UNUSED)
 
 		rcp = cp;
 		/*
-		 * ignore white-space at start of line
+		 * ignore whitespace at start of line
 		 */
-		while (*rcp && ctype(*rcp, C_CFS))
+		while (*rcp && ctype(*rcp, C_BLANK))
 			rcp++;
 		while (x_arg-- > 0) {
-			while (*rcp && !ctype(*rcp, C_CFS))
+			while (*rcp && !ctype(*rcp, C_BLANK))
 				rcp++;
-			while (*rcp && ctype(*rcp, C_CFS))
+			while (*rcp && ctype(*rcp, C_BLANK))
 				rcp++;
 		}
 		cp = rcp;
-		while (*rcp && !ctype(*rcp, C_CFS))
+		while (*rcp && !ctype(*rcp, C_BLANK))
 			rcp++;
 		ch = *rcp;
 		*rcp = '\0';
@@ -3236,21 +3319,42 @@ x_prev_histword(int c MKSH_A_UNUSED)
 static int
 x_fold_upper(int c MKSH_A_UNUSED)
 {
-	return (x_fold_case('U'));
+	return (x_fold_case('U', C_MFS));
 }
 
 /* Lowercase N(1) words */
 static int
 x_fold_lower(int c MKSH_A_UNUSED)
 {
-	return (x_fold_case('L'));
+	return (x_fold_case('L', C_MFS));
 }
 
 /* Titlecase N(1) words */
 static int
 x_fold_capitalise(int c MKSH_A_UNUSED)
 {
-	return (x_fold_case('C'));
+	return (x_fold_case('C', C_MFS));
+}
+
+/* Uppercase N(1) bigwords */
+static int
+x_foldb_upper(int c MKSH_A_UNUSED)
+{
+	return (x_fold_case('U', C_BLANK));
+}
+
+/* Lowercase N(1) bigwords */
+static int
+x_foldb_lower(int c MKSH_A_UNUSED)
+{
+	return (x_fold_case('L', C_BLANK));
+}
+
+/* Titlecase N(1) bigwords */
+static int
+x_foldb_capitalise(int c MKSH_A_UNUSED)
+{
+	return (x_fold_case('C', C_BLANK));
 }
 
 /*-
@@ -3259,25 +3363,25 @@ x_fold_capitalise(int c MKSH_A_UNUSED)
  *
  * DESCRIPTION:
  *	This function is used to implement M-U/M-u, M-L/M-l, M-C/M-c
- *	to UPPER CASE, lower case or Capitalise Words.
+ *	to UPPER CASE, lower case or Capitalise words and bigwords.
  *
  * RETURN VALUE:
  *	None
  */
 static int
-x_fold_case(int c)
+x_fold_case(int c, uint32_t separator)
 {
 	char *cp = xcp;
 
 	if (cp == xep) {
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		return (KSTD);
 	}
 	while (x_arg--) {
 		/*
 		 * first skip over any white-space
 		 */
-		while (cp != xep && ctype(*cp, C_MFS))
+		while (cp != xep && ctype(*cp, separator))
 			cp++;
 		/*
 		 * do the first char on its own since it may be
@@ -3295,7 +3399,7 @@ x_fold_case(int c)
 		/*
 		 * now for the rest of the word
 		 */
-		while (cp != xep && !ctype(*cp, C_MFS)) {
+		while (cp != xep && !ctype(*cp, separator)) {
 			if (c == 'U')
 				/* uppercase */
 				*cp = ksh_toupper(*cp);
@@ -3318,7 +3422,7 @@ x_fold_case(int c)
  * DESCRIPTION:
  *	This function returns a pointer to that char in the
  *	edit buffer that will be the last displayed on the
- *	screen.
+ *	screen. It also updates xlp and xdp.
  */
 static char *
 x_lastcp(void)
@@ -3329,14 +3433,20 @@ x_lastcp(void)
 
 		xlp = xbp;
 		while (xlp < xep) {
-			j = x_size2(xlp, &xlp2);
-			if ((i + j) > x_displen)
-				break;
+			j = uwidthmbT(xlp, &xlp2);
+			if ((i + j) > x_displen) {
+				/* don’t add (x_displen - i) here */
+				/* can be 2-column doesn’t-fit char */
+				xdp = xlp;
+				goto xlp_longline;
+			}
 			i += j;
 			xlp = xlp2;
 		}
+		xdp = xlp + (x_displen - i);
+ xlp_longline:
+		xlp_valid = true;
 	}
-	xlp_valid = true;
 	return (xlp);
 }
 
@@ -3449,6 +3559,7 @@ static void vi_error(void);
 static void vi_macro_reset(void);
 static int x_vi_putbuf(const char *, size_t);
 #define char_len(c) (ksh_isctrl(c) ? 2 : 1)
+#define ksh_unctrl(c) asc2rtt(rtt2asc(c) ^ 0x40U)
 
 #define vC	0x01		/* a valid command that isn't a vM, vE, vU */
 #define vM	0x02		/* movement command (h, l, etc.) */
@@ -3540,11 +3651,11 @@ static int inslen;			/* length of input
 static int srchlen;			/* length of current search pattern */
 static char *ybuf;			/* yank buffer */
 static int yanklen;			/* length of yank buffer */
-static uint8_t fsavecmd = ORD(' ');	/* last find command */
+static kby fsavecmd = ORD(' ');		/* last find command */
 static int fsavech;			/* character to find */
 static char lastcmd[MAXVICMD];		/* last non-move command */
 static int lastac;			/* argcnt for lastcmd */
-static uint8_t lastsearch = ORD(' ');	/* last search command */
+static kby lastsearch = ORD(' ');	/* last search command */
 static char srchpat[SRCHLEN];		/* last search pattern */
 static int insert;			/* <>0 in insert mode */
 static int hnum;			/* position in history */
@@ -3571,7 +3682,7 @@ static enum expand_mode {
 	NONE = 0, EXPAND, COMPLETE, PRINT
 } expanded;
 
-static int
+static ssize_t
 x_vi(char *buf)
 {
 	int c;
@@ -3646,7 +3757,11 @@ x_vi(char *buf)
 			} else if (isched(c, edchars.eof) &&
 			    state != VVERSION) {
 				if (vs->linelen == 0) {
-					x_vi_zotc(c);
+					if (ksh_isctrl(c)) {
+						x_putc('^');
+						c = ksh_unctrl(c);
+					}
+					x_putc(c);
 					c = -1;
 					break;
 				}
@@ -4592,7 +4707,6 @@ vi_cmd(int argcnt, const char *cmd)
 			print_expansions(vs, 1);
 			break;
 
-
 		/* Nonstandard vi/ksh */
 		case CTRL_I:
 			if (!Flag(FVITABCOMPLETE))
@@ -4612,7 +4726,6 @@ vi_cmd(int argcnt, const char *cmd)
 			complete_word(1, argcnt);
 			break;
 
-
 		/* AT&T ksh */
 		case ORD('*'):
 		/* Nonstandard vi/ksh */
@@ -4620,7 +4733,6 @@ vi_cmd(int argcnt, const char *cmd)
 			expand_word(1);
 			break;
 
-
 		/* mksh: cursor movement */
 		case ORD('['):
 		case ORD('O'):
@@ -5318,7 +5430,6 @@ ed_mov_opt(int col, char *wb)
 	x_col = col;
 }
 
-
 /* replace word with all expansions (ie, expand word*) */
 static int
 expand_word(int cmd)
@@ -5471,11 +5582,14 @@ complete_word(int cmd, int count)
 
 		/*
 		 * append a space if this is a non-directory match
-		 * and not a parameter or homedir substitution
+		 * and not a parameter substitution, slash for homedir
 		 */
-		if (match_len > 0 && !mksh_cdirsep(match[match_len - 1]) &&
-		    !(flags & XCF_IS_NOSPACE))
-			rval = putbuf(T1space, 1, false);
+		if (match_len > 0 && !mksh_cdirsep(match[match_len - 1])) {
+			if (flags & XCF_IS_HOMEDIR)
+				rval = putbuf("/", 1, false);
+			else if (!(flags & XCF_IS_NOSPACE))
+				rval = putbuf(T1space, 1, false);
+		}
 	}
 	x_free_words(nwords, words);
 
@@ -5507,20 +5621,7 @@ print_expansions(struct edstate *est, in
 	redraw_line(false);
 	return (0);
 }
-#endif /* !MKSH_S_NOVI */
-
-/* Similar to x_zotc(emacs.c), but no tab weirdness */
-static void
-x_vi_zotc(int c)
-{
-	if (ksh_isctrl(c)) {
-		x_putc('^');
-		c = ksh_unctrl(c);
-	}
-	x_putc(c);
-}
 
-#if !MKSH_S_NOVI
 static void
 vi_error(void)
 {
@@ -5544,7 +5645,7 @@ vi_macro_reset(void)
 void
 x_init(void)
 {
-	int i, j;
+	size_t i;
 
 	/*
 	 * set edchars to force initial binding, except we need
@@ -5561,29 +5662,32 @@ x_init(void)
 	/* initialise Emacs command line editing mode */
 	x_nextcmd = -1;
 
-	x_tab = alloc2(X_NTABS, sizeof(*x_tab), AEDIT);
-	for (j = 0; j < X_TABSZ; j++)
-		x_tab[0][j] = XFUNC_insert;
-	for (i = 1; i < X_NTABS; i++)
-		for (j = 0; j < X_TABSZ; j++)
-			x_tab[i][j] = XFUNC_error;
-	for (i = 0; i < (int)NELEM(x_defbindings); i++)
-		x_tab[x_defbindings[i].xdb_tab][x_defbindings[i].xdb_char]
-		    = x_defbindings[i].xdb_func;
+	x_ktab = alloc2(X_NTABS << 8, sizeof(kby), AEDIT);
+	i = 0;
+	while (i <= 0xFF)
+		x_ktab[i++] = XFUNC_insert;
+	while (i < (X_NTABS << 8))
+		x_ktab[i++] = XFUNC_error;
+	for (i = 0; i < NELEM(x_defbindings); ++i)
+		X_KTAB(x_defbindings[i].xdb_tab,
+		    x_defbindings[i].xdb_char) = x_defbindings[i].xdb_func;
 
 #ifndef MKSH_SMALL
-	x_atab = alloc2(X_NTABS, sizeof(*x_atab), AEDIT);
-	for (i = 1; i < X_NTABS; i++)
-		for (j = 0; j < X_TABSZ; j++)
-			x_atab[i][j] = NULL;
+	x_mtab = alloc2(X_NTABS << 8, sizeof(char *), AEDIT);
+	i = 0;
+	while (i < (X_NTABS << 8))
+		x_mtab[i++] = NULL;
 #endif
+
+	x_btab = alloc2(X_NTABS << (8 - 3), sizeof(kby), AEDIT);
+	memset(x_btab, 0, (X_NTABS << (8 - 3)) * sizeof(kby));
 }
 
 #ifdef DEBUG_LEAKS
 void
 x_done(void)
 {
-	if (x_tab != NULL)
+	if (x_btab != NULL)
 		afreeall(AEDIT);
 }
 #endif
@@ -5597,12 +5701,12 @@ x_initterm(const char *termtype)
 	switch (*termtype) {
 	case 's':
 		if (!strncmp(termtype, "screen", 6) &&
-		    (termtype[6] == '\0' || termtype[6] == '-'))
+		    (!termtype[6] || ord(termtype[6]) == ORD('-')))
 			x_term_mode = 1;
 		break;
 	case 't':
 		if (!strncmp(termtype, "tmux", 4) &&
-		    (termtype[4] == '\0' || termtype[4] == '-'))
+		    (!termtype[4] || ord(termtype[4]) == ORD('-')))
 			x_term_mode = 1;
 		break;
 	}
@@ -5652,7 +5756,7 @@ x_operate_region(char *(*helper)(const c
 		rgend = xmp;
 	}
 
-	x_e_putc2('\r');
+	x_e_putb('\r');
 	x_clrtoeol(' ', false);
 	x_flush();
 	x_mode(false);
@@ -5662,7 +5766,7 @@ x_operate_region(char *(*helper)(const c
 	if (cp == NULL) {
 		/* error return from helper */
  x_eval_region_err:
-		x_e_putc2(KSH_BEL);
+		x_e_putb(KSH_BEL);
 		x_redraw('\r');
 		return (KSTD);
 	}
@@ -5699,9 +5803,7 @@ x_quote_region_helper(const char *cmd, s
 
 	strndupx(s, cmd, len, ATEMP);
 	newlen = len < 256 ? 256 : 4096;
-	shf_sopen(alloc(newlen, AEDIT), newlen, SHF_WR | SHF_DYNAMIC, &shf);
-	shf.areap = AEDIT;
-	shf.flags |= SHF_ALLOCB;
+	shf_sreopen(alloc(newlen, AEDIT), newlen, AEDIT, &shf);
 	print_value_quoted(&shf, s);
 	afree(s, ATEMP);
 	return (shf_sclose(&shf));
@@ -5713,4 +5815,88 @@ x_quote_region(int c MKSH_A_UNUSED)
 	return (x_operate_region(x_quote_region_helper));
 }
 #endif /* !MKSH_SMALL */
+
+#ifdef DF
+/* debug code to dump the Emacs buffer state */
+#define TL() do {							\
+	tmp = ofs & 0xFU;						\
+	if (tmp) {							\
+		while (tmp != 0x10U) {					\
+			shf_puts(tmp == 0x8U ? " -   " : "   ", &to);	\
+			++tmp;						\
+		}							\
+		tmp = ofs & (size_t)~(size_t)0xFU;			\
+	} else if (ofs)							\
+		tmp = ofs - 0x10U;					\
+	shf_puts("  ", &to);						\
+	while ((tmp & 0xFU) < lbeg) {					\
+		shf_putc(' ', &to);					\
+		++tmp;							\
+	}								\
+	shf_putc('|', &to);						\
+	while (tmp < ofs) {						\
+		kby c = xbuf[tmp++];					\
+		shf_putc(ctype(c, C_PRINT) ? c : '.', &to);		\
+	}								\
+	shf_putc('|', &to);						\
+	lbeg = ofs & 0xFU;						\
+	nl = 1;								\
+} while (/* CONSTCOND */ 0)
+
+#define DP(p) do { if ((xbuf + ofs) == p) {				\
+	if (!nl) TL();							\
+	shf_fprintf(&to, nl < 2 ? "\n   ↓ = %s" : " and %s", #p);	\
+	nl = 2;								\
+} } while (/* CONSTCOND */ 0)
+
+static void
+x_emacs_DF(const char *reason)
+{
+	struct shf to;
+	kby nl;
+	size_t ofs, end, tmp, lbeg = 0;
+
+	shf_sopen(NULL, 0, SHF_WR | SHF_DYNAMIC, &to);
+	ofs = 0;
+	nl = 1;
+	if (xdp > xep)
+		end = xdp - xbuf + 1;
+	else
+		end = xep - xbuf + 1;
+	/* end is within xend + X_EXTRA */
+	while (ofs < end) {
+		DP(xbp);
+		DP(xmp);
+		DP(xcp);
+		DP(xlp);
+		DP(xdp);
+		DP(xep);
+		if (nl) {
+			shf_fprintf(&to, "\n%04zX ", ofs);
+			tmp = ofs & (size_t)~(size_t)0xFU;
+			while (tmp < ofs) {
+				shf_puts((tmp & 0xFU) == 0x8U ?
+				    " -   " : "   ", &to);
+				++tmp;
+			}
+			nl = 0;
+		}
+		shf_fprintf(&to, (ofs & 0xFU) == 0x8U ? " - %02X" : " %02X",
+		    ord(xbuf[ofs]));
+		++ofs;
+		if (!(ofs & 0xFU))
+			TL();
+	}
+	if (!nl)
+		TL();
+	DF("‣ xbuf: %s%s", reason, shf_sclose(&to));
+}
+
+static int
+x_debug_buf(int c MKSH_A_UNUSED)
+{
+	x_emacs_DF("from keyboard");
+	return (KSTD);
+}
+#endif
 #endif /* !MKSH_NO_CMDLINE_EDITING */
--- mksh-59c.orig/emacsfn.h
+++ mksh-59c/emacsfn.h
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 2009, 2010, 2015, 2016, 2020
+ * Copyright (c) 2009, 2010, 2015, 2016, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -19,7 +19,7 @@
  */
 
 #if defined(EMACSFN_DEFNS)
-__RCSID("$MirOS: src/bin/mksh/emacsfn.h,v 1.11 2020/04/13 20:46:39 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/emacsfn.h,v 1.16 2021/10/16 01:28:06 tg Exp $");
 #define FN(cname,sname,flags)	static int x_##cname(int);
 #elif defined(EMACSFN_ENUMS)
 #define FN(cname,sname,flags)	XFUNC_##cname,
@@ -40,10 +40,19 @@ FN(comp_comm, "complete-command", 0)
 FN(comp_file, "complete-file", 0)
 FN(comp_list, "complete-list", 0)
 FN(complete, "complete", 0)
+#ifdef DF
+FN(debug_buf, "debug-buffer", 0)
+#endif
 FN(del_back, "delete-char-backward", XF_ARG)
 FN(del_bword, "delete-word-backward", XF_ARG)
+#ifndef MKSH_SMALL
+FN(del_bbigword, "delete-bigword-backward", XF_ARG)
+#endif
 FN(del_char, "delete-char-forward", XF_ARG)
 FN(del_fword, "delete-word-forward", XF_ARG)
+#ifndef MKSH_SMALL
+FN(del_fbigword, "delete-bigword-forward", XF_ARG)
+#endif
 FN(del_line, "kill-line", 0)
 FN(draw_line, "redraw", 0)
 #ifndef MKSH_SMALL
@@ -59,8 +68,11 @@ FN(eval_region, "evaluate-region", 0)
 #endif
 FN(expand, "expand-file", 0)
 #ifndef MKSH_SMALL
-FN(fold_capitalise, "capitalize-word", XF_ARG)
+FN(foldb_capitalise, "capitalise-bigword", XF_ARG)
+FN(fold_capitalise, "capitalise-word", XF_ARG)
+FN(foldb_lower, "downcase-bigword", XF_ARG)
 FN(fold_lower, "downcase-word", XF_ARG)
+FN(foldb_upper, "upcase-bigword", XF_ARG)
 FN(fold_upper, "upcase-word", XF_ARG)
 #endif
 FN(goto_hist, "goto-history", XF_ARG)
@@ -80,15 +92,21 @@ FN(meta_yank, "yank-pop", 0)
 FN(mv_back, "backward-char", XF_ARG)
 FN(mv_beg, "beginning-of-line", 0)
 FN(mv_bword, "backward-word", XF_ARG)
+#ifndef MKSH_SMALL
+FN(mv_bbigword, "backward-bigword", XF_ARG)
+#endif
 FN(mv_end, "end-of-line", 0)
 FN(mv_forw, "forward-char", XF_ARG)
 FN(mv_fword, "forward-word", XF_ARG)
+#ifndef MKSH_SMALL
+FN(mv_fbigword, "forward-bigword", XF_ARG)
+#endif
 FN(newline, "newline", 0)
 FN(next_com, "down-history", XF_ARG)
 FN(nl_next_com, "newline-and-next", 0)
 FN(noop, "no-op", 0)
 FN(prev_com, "up-history", XF_ARG)
-FN(prev_histword, "prev-hist-word", XF_ARG)
+FN(prev_histword, "prev-hist-bigword", XF_ARG)
 #ifndef MKSH_SMALL
 FN(quote_region, "quote-region", 0)
 #endif
--- mksh-59c.orig/eval.c
+++ mksh-59c/eval.c
@@ -3,7 +3,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
- *		 2019, 2020
+ *		 2019, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -24,7 +24,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.231 2020/05/05 21:34:27 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/eval.c,v 1.243 2021/10/10 21:36:52 tg Exp $");
 
 /*
  * string expansion
@@ -79,6 +79,7 @@ typedef struct {
 static int varsub(Expand *, const char *, const char *, unsigned int *, int *);
 static int comsub(Expand *, const char *, int);
 static char *valsub(struct op *, Area *);
+static void funsub(struct op *);
 static char *trimsub(char *, char *, int);
 static void glob(char *, XPtrV *, bool);
 static void globit(XString *, char **, char *, XPtrV *, int);
@@ -99,7 +100,7 @@ utflen(const char *s)
 	if (UTFMODE) {
 		n = 0;
 		while (*s) {
-			s += utf_ptradj(s);
+			s += ez_mbtoc(NULL, s);
 			++n;
 		}
 	} else
@@ -116,7 +117,7 @@ utfincptr(const char *s, mksh_ari_t *lp)
 	const char *cp = s;
 
 	while ((*lp)--)
-		cp += utf_ptradj(cp);
+		cp += ez_mbtoc(NULL, cp);
 	*lp = cp - s;
 }
 
@@ -212,8 +213,8 @@ typedef struct SubType {
 	size_t	base;		/* start position of expanded word */
 	unsigned short stype;	/* [=+-?%#] action after expanded word */
 	short	f;		/* saved value of f (DOPAT, etc) */
-	uint8_t	quotep;		/* saved value of quote (for ${..[%#]..}) */
-	uint8_t	quotew;		/* saved value of quote (for ${..[+-=]..}) */
+	kby	quotep;		/* saved value of quote (for ${..[%#]..}) */
+	kby	quotew;		/* saved value of quote (for ${..[+-=]..}) */
 } SubType;
 
 void
@@ -386,7 +387,7 @@ expand(
 			 */
 				/* skip the { or x (}) */
 				const char *varname = ++sp;
-				unsigned int stype;
+				unsigned int stype /* for GCC */ = 0;
 				int slen = 0;
 
 				/* skip variable */
@@ -443,6 +444,7 @@ expand(
 					switch (stype & STYPE_SINGLE) {
 					case ORD('#') | STYPE_AT:
 					case ORD('Q') | STYPE_AT:
+					case ORD('^') | STYPE_AT:
 						break;
 					case ORD('0'): {
 						char *beg, *mid, *end, *stg;
@@ -807,7 +809,7 @@ expand(
 					    debunk(dp, dp, strlen(dp) + 1));
 					break;
 				case ORD('#') | STYPE_AT:
-					x.str = shf_smprintf("%08X",
+					x.str = shf_smprintf(Thex32,
 					    (unsigned int)hash(str_val(st->var)));
 					goto common_CSUBST;
 				case ORD('Q') | STYPE_AT: {
@@ -818,6 +820,14 @@ expand(
 					x.str = shf_sclose(&shf);
 					goto common_CSUBST;
 				    }
+				case ORD('^') | STYPE_AT: {
+					struct shf shf;
+
+					shf_sopen(NULL, 0, SHF_WR|SHF_DYNAMIC, &shf);
+					uprntmbs(str_val(st->var), true, &shf);
+					x.str = shf_sclose(&shf);
+					goto common_CSUBST;
+				    }
 				case ORD('0'):
 				case ORD('/') | STYPE_AT:
 				case ORD('/'):
@@ -1005,8 +1015,8 @@ expand(
 				c = ORD('\n');
 				--newlines;
 			} else {
-				while ((c = shf_getc(x.u.shf)) == 0 ||
-				    cinttype(c, C_NL)) {
+				while (c = shf_getc(x.u.shf),
+				    cinttype(c, C_NL | C_NUL)) {
 #ifdef MKSH_WITH_TEXTMODE
 					if (c == ORD('\r')) {
 						c = shf_getc(x.u.shf);
@@ -1300,7 +1310,7 @@ varsub(Expand *xp, const char *sp, const
 			if (sc & 2) {
 				stype = 0;
 				XPinit(wv, 32);
-				vp = global(arrayname(sp));
+				vp = arraybase(sp);
 				do {
 					if (vp->flag & ISSET)
 						XPput(wv, shf_smprintf(Tf_lu,
@@ -1327,13 +1337,7 @@ varsub(Expand *xp, const char *sp, const
 			/* partial utf_mbswidth reimplementation */
 			sc = 0;
 			while (*p) {
-				if (!UTFMODE ||
-				    (wv.len = utf_mbtowc(&c, p)) == (size_t)-1)
-					/* not UTFMODE or not UTF-8 */
-					c = rtt2asc(*p++);
-				else
-					/* UTFMODE and UTF-8 */
-					p += wv.len;
+				p += ez_mbtowc(&c, p);
 				/* c == char or wchar at p++ */
 				if ((slen = utf_wcwidth(c)) == -1) {
 					/* 646, 8859-1, 10646 C0/C1 */
@@ -1347,7 +1351,7 @@ varsub(Expand *xp, const char *sp, const
 		case ORD('#'):
 			  switch (sc & 3) {
 			case 3:
-				vp = global(arrayname(sp));
+				vp = arraybase(sp);
 				if (vp->flag & (ISSET|ARRAY))
 					zero_ok = true;
 				sc = 0;
@@ -1414,6 +1418,7 @@ varsub(Expand *xp, const char *sp, const
 		case ORD('#'):
 		case ORD('/'):
 		case ORD('Q'):
+		case ORD('^'):
 			break;
 		default:
 			return (-1);
@@ -1452,13 +1457,14 @@ varsub(Expand *xp, const char *sp, const
 		case ORD('0'):
 		case ORD('#') | STYPE_AT:
 		case ORD('Q') | STYPE_AT:
+		case ORD('^') | STYPE_AT:
 	*/	default:
 			return (-1);
 		}
 		/* do what we can */
 		if (sc & 2) {
 			XPinit(wv, 32);
-			vp = global(arrayname(sp));
+			vp = arraybase(sp);
 			do {
 				if (vp->flag & ISSET)
 					XPput(wv, str_val(vp));
@@ -1502,6 +1508,7 @@ varsub(Expand *xp, const char *sp, const
 	    stype == (ORD('0') | STYPE_DBL) ||
 	    stype == (ORD('#') | STYPE_AT) ||
 	    stype == (ORD('Q') | STYPE_AT) ||
+	    stype == (ORD('^') | STYPE_AT) ||
 	    (stype & STYPE_CHAR) == ORD('/'))
 		/* expand word instead of variable value */
 		state = XBASE;
@@ -1523,7 +1530,7 @@ comsub(Expand *xp, const char *cp, int f
 	struct op *t;
 	struct shf *shf;
 	bool doalias = false;
-	uint8_t old_utfmode = UTFMODE;
+	kby old_utfmode = UTFMODE;
 
 	switch (fn) {
 	case COMASUB:
@@ -1538,7 +1545,7 @@ comsub(Expand *xp, const char *cp, int f
 	s = pushs(SSTRING, ATEMP);
 	s->start = s->str = cp;
 	sold = source;
-	t = compile(s, true, doalias);
+	t = compile(s, doalias);
 	afree(s, ATEMP);
 	source = sold;
 
@@ -1561,9 +1568,8 @@ comsub(Expand *xp, const char *cp, int f
 			shf = shf_open(name = evalstr(io->ioname, DOTILDE),
 				O_RDONLY, 0, SHF_MAPHI | SHF_CLEXEC);
 			if (shf == NULL)
-				warningf(!Flag(FTALKING), Tf_sD_s_sD_s,
-				    name, Tcant_open, "$(<...) input",
-				    cstrerror(errno));
+				warningf(!Flag(FTALKING), Tf_sD_sD_s,
+				    name, Tcant_filesub, cstrerror(errno));
 			break;
 		case IOHERE:
 			if (!herein(io, &name)) {
@@ -1605,7 +1611,7 @@ comsub(Expand *xp, const char *cp, int f
 		 * run tree, with output thrown into the tempfile,
 		 * in a new function block
 		 */
-		valsub(t, NULL);
+		funsub(t);
 		subst_exstat = exstat & 0xFF;
 		/* rewind the tempfile and restore regular stdout */
 		lseek(shf_fileno(shf), (off_t)0, SEEK_SET);
@@ -1647,26 +1653,32 @@ trimsub(char *str, char *pat, int how)
 	switch (how & (STYPE_CHAR | STYPE_DBL)) {
 	case ORD('#'):
 		/* shortest match at beginning */
-		for (p = str; p <= end; p += utf_ptradj(p)) {
-			c = *p; *p = '\0';
+		p = str;
+		do {
+			c = *p;
+			*p = '\0';
 			if (gmatchx(str, pat, false)) {
 				record_match(str);
 				*p = c;
 				return (p);
 			}
 			*p = c;
-		}
+			p += ez_mbtoc(NULL, p);
+		} while (c != '\0');
 		break;
 	case ORD('#') | STYPE_DBL:
 		/* longest match at beginning */
-		for (p = end; p >= str; p--) {
-			c = *p; *p = '\0';
+		p = end;
+		while (p >= str) {
+			c = *p;
+			*p = '\0';
 			if (gmatchx(str, pat, false)) {
 				record_match(str);
 				*p = c;
 				return (p);
 			}
 			*p = c;
+			--p;
 		}
 		break;
 	case ORD('%'):
@@ -1675,14 +1687,7 @@ trimsub(char *str, char *pat, int how)
 		while (p >= str) {
 			if (gmatchx(p, pat, false))
 				goto trimsub_match;
-			if (UTFMODE) {
-				char *op = p;
-				while ((p-- > str) && ((rtt2asc(*p) & 0xC0) == 0x80))
-					;
-				if ((p < str) || (p + utf_ptradj(p) != op))
-					p = op - 1;
-			} else
-				--p;
+			p = ez_bs(p - 1, str);
 		}
 		break;
 	case ORD('%') | STYPE_DBL:
@@ -1822,7 +1827,6 @@ globit(XString *xs,	/* dest string */
 		se = strnul(sp);
 	}
 
-
 	/*
 	 * Check if sp needs globbing - done to avoid pattern checks for strings
 	 * containing MAGIC characters, open [s without the matching close ],
@@ -1872,7 +1876,7 @@ globit(XString *xs,	/* dest string */
 	}
 
 	if (np != NULL)
-		*--np = odirsep;
+		*(char *)(--np) = odirsep;
 }
 
 /* remove MAGIC from string */
@@ -2017,7 +2021,7 @@ alt_expand(XPtrV *wp, char *start, char
 	char *p = exp_start;
 
 	/* search for open brace */
-	while ((p = strchr(p, MAGIC)) && ord(p[1]) != ORD('{' /*}*/))
+	while ((p = ucstrchr(p, MAGIC)) && ord(p[1]) != ORD('{' /*}*/))
 		p += 2;
 	brace_start = p;
 
@@ -2094,18 +2098,31 @@ alt_expand(XPtrV *wp, char *start, char
 static char *
 valsub(struct op *t, Area *ap)
 {
-	char * volatile cp = NULL;
-	struct tbl * volatile vp = NULL;
+	char *cp;
+	struct tbl * volatile vp;
+	int i;
 
 	newenv(E_FUNC);
 	newblock();
-	if (ap)
-		vp = local(TREPLY, false);
-	if (!kshsetjmp(e->jbuf))
-		execute(t, XXCOM | XERROK, NULL);
-	if (vp)
-		strdupx(cp, str_val(vp), ap);
+	vp = local(TREPLY, false);
+	if (!(i = kshsetjmp(e->jbuf))) {
+		execute(t, XXCOM, NULL);
+		i = LRETURN;
+	}
+	strdupx(cp, str_val(vp), ap);
 	quitenv(NULL);
+	/* see CFUNC case in exec.c:comexec() */
+	if (i != LRETURN)
+		unwind(i);
 
 	return (cp);
 }
+static void
+funsub(struct op *t)
+{
+	newenv(E_FUNC);
+	newblock();
+	if (!kshsetjmp(e->jbuf))
+		execute(t, XXCOM | XERROK, NULL);
+	quitenv(NULL);
+}
--- mksh-59c.orig/exec.c
+++ mksh-59c/exec.c
@@ -3,7 +3,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
- *		 2019, 2020
+ *		 2019, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -24,7 +24,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.224 2020/08/27 19:52:43 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/exec.c,v 1.234 2021/10/10 21:35:04 tg Exp $");
 
 #ifndef MKSH_DEFAULT_EXECSHELL
 #define MKSH_DEFAULT_EXECSHELL	MKSH_UNIXROOT "/bin/sh"
@@ -132,9 +132,9 @@ execute(struct op * volatile t,
 	flags &= ~XTIME;
 
 	if (t->ioact != NULL || t->type == TPIPE || t->type == TCOPROC) {
-		e->savefd = alloc2(NUFILE, sizeof(short), ATEMP);
+		e->savedfd = alloc2(NUFILE, sizeof(ksh_fdsave), ATEMP);
 		/* initialise to not redirected */
-		memset(e->savefd, 0, NUFILE * sizeof(short));
+		memset(e->savedfd, 0, NUFILE * sizeof(ksh_fdsave));
 	}
 
 	/* mark for replacement later (unless TPIPE) */
@@ -169,8 +169,8 @@ execute(struct op * volatile t,
 	case TPIPE:
 		flags |= XFORK;
 		flags &= ~XEXEC;
-		e->savefd[0] = savefd(0);
-		e->savefd[1] = savefd(1);
+		FDSAVE(0, savefd(0));
+		FDSAVE(1, savefd(1));
 		while (t->type == TPIPE) {
 			openpipe(pv);
 			/* stdout of curr */
@@ -190,9 +190,9 @@ execute(struct op * volatile t,
 			t = t->right;
 		}
 		/* stdout of last */
-		restfd(1, e->savefd[1]);
+		restfd(1, SAVEDFD(e, 1));
 		/* no need to re-restore this */
-		e->savefd[1] = 0;
+		e->savedfd[1] = 0;
 		/* Let exchild() close 0 in parent, after fork, before wait */
 		i = exchild(t, flags | XPCLOSE | XPIPEST, xerrok, 0);
 		if (!(flags&XBGND) && !(flags&XXCOM))
@@ -232,8 +232,8 @@ execute(struct op * volatile t,
 		coproc_cleanup(true);
 
 		/* do this before opening pipes, in case these fail */
-		e->savefd[0] = savefd(0);
-		e->savefd[1] = savefd(1);
+		FDSAVE(0, savefd(0));
+		FDSAVE(1, savefd(1));
 
 		openpipe(pv);
 		if (pv[0] != 0) {
@@ -433,8 +433,11 @@ execute(struct op * volatile t,
 		/* I/O redirection cleanup to be done in child process */
 		if (!Flag(FPOSIX) && !Flag(FSH) && t->left->ioact != NULL)
 			for (iowp = t->left->ioact; *iowp != NULL; iowp++)
-				if ((*iowp)->ioflag & IODUPSELF)
-					fcntl((*iowp)->unit, F_SETFD, 0);
+				if (((*iowp)->ioflag & IODUPSELF) &&
+				    fcntl((*iowp)->unit, F_SETFD, 0) == -1)
+					internal_warningf(Tcloexec_failed,
+					    "clear", (*iowp)->unit,
+					    cstrerror(errno));
 		/* try to execute */
 		{
 			union mksh_ccphack cargs;
@@ -694,7 +697,7 @@ comexec(struct op *t, struct tbl * volat
 	case CFUNC: {
 		volatile uint32_t old_inuse;
 		const char * volatile old_kshname;
-		volatile uint8_t old_flags[FNFLAGS];
+		volatile kby old_flags[FNFLAGS];
 
 		if (!(tp->flag & ISSET)) {
 			struct tbl *ftp;
@@ -702,9 +705,9 @@ comexec(struct op *t, struct tbl * volat
 			if (!tp->u.fpath) {
  fpath_error:
 				rv = (tp->u2.errnov == ENOENT) ? 127 : 126;
-				warningf(true, Tf_sD_s_sD_s, cp,
-				    Tcant_find, Tfile_fd,
-				    cstrerror(tp->u2.errnov));
+				warningf(true,
+				    "%s: can't find function definition file: %s",
+				    cp, cstrerror(tp->u2.errnov));
 				break;
 			}
 			errno = 0;
@@ -773,8 +776,17 @@ comexec(struct op *t, struct tbl * volat
 		if (tp->flag & FKSH) {
 			/* Korn style functions restore Flags on return */
 			old_flags[(int)FXTRACE] = Flag(FXTRACE);
+			/* some must not be restored / need special handling */
 			for (type_flags = 0; type_flags < FNFLAGS; ++type_flags)
-				shell_flags[type_flags] = old_flags[type_flags];
+#ifndef MKSH_UNEMPLOYED
+				if (type_flags == FMONITOR)
+					change_flag(type_flags, OF_INTERNAL,
+					    old_flags[type_flags]);
+				else
+#endif
+				  if (type_flags != FPRIVILEGED)
+					shell_flags[type_flags] =
+					    old_flags[type_flags];
 		}
 #endif
 		tp->flag = (tp->flag & ~FINUSE) | old_inuse;
@@ -844,14 +856,6 @@ comexec(struct op *t, struct tbl * volat
 			if (exec_argv0)
 				texec.args[0] = exec_argv0;
 			j_exit();
-			if (!(flags & XBGND)
-#ifndef MKSH_UNEMPLOYED
-			    || Flag(FMONITOR)
-#endif
-			    ) {
-				setexecsig(&sigtraps[SIGINT], SS_RESTORE_ORIG);
-				setexecsig(&sigtraps[SIGQUIT], SS_RESTORE_ORIG);
-			}
 		}
 
 		rv = exchild(&texec, flags, xerrok, -1);
@@ -903,11 +907,8 @@ scriptexec(struct op *tp, const char **a
 		/* terminate buffer */
 		buf[n] = '\0';
 
-		/* skip UTF-8 Byte Order Mark, if present */
-		cp = buf + (n = ((buf[0] == 0xEF) && (buf[1] == 0xBB) &&
-		    (buf[2] == 0xBF)) ? 3 : 0);
-
 		/* scan for newline or NUL (end of buffer) */
+		cp = buf;
 		while (!ctype(*cp, C_NL | C_NUL))
 			++cp;
 		/* if the shebang line is longer than MAXINTERP, bail out */
@@ -916,8 +917,8 @@ scriptexec(struct op *tp, const char **a
 		/* replace newline by NUL */
 		*cp = '\0';
 
-		/* restore start of shebang position (buf+0 or buf+3) */
-		cp = buf + n;
+		/* restore start of shebang position */
+		cp = buf;
 		/* bail out if no shebang magic found */
 		if (cp[0] == '#' && cp[1] == '!')
 			cp += 2;
@@ -983,7 +984,10 @@ scriptexec(struct op *tp, const char **a
 		    (m == /* ksh93 */ 0x0B13) || (m == /* LZIP */ 0x4C5A) ||
 		    (m == /* xz */ 0xFD37 && buf[2] == 'z' && buf[3] == 'X' &&
 		    buf[4] == 'Z') || (m == /* 7zip */ 0x377A) ||
-		    (m == /* gzip */ 0x1F8B) || (m == /* .Z */ 0x1F9D))
+		    (m == /* gzip */ 0x1F8B) || (m == /* .Z */ 0x1F9D) ||
+		    (m == /* UTF-8 BOM */ 0xEFBB && buf[2] == 0xBF) ||
+		    (m == /* UCS-4, may also be general binary */ 0x0000) ||
+		    (m == /* UCS-2LE */ 0xFFFE) || (m == /* UCS-2BE */ 0xFEFF))
 			errorf("%s: not executable: magic %04X", tp->str, m);
 #endif
 #ifdef __OS2__
@@ -1388,7 +1392,11 @@ call_builtin(struct tbl *tp, const char
 	shl_stdout_ok = true;
 	ksh_getopt_reset(&builtin_opt, GF_ERROR);
 	rv = (*tp->val.f)(wp);
-	shf_flush(shl_stdout);
+	if (shf_flush(shl_stdout) < 0) {
+		bi_errorf(Tf_sD_s, Twrite, cstrerror(errno));
+		if (rv == 0)
+			rv = 1;
+	}
 	shl_stdout_ok = false;
 	builtin_argv0 = NULL;
 	builtin_spec = false;
@@ -1396,7 +1404,7 @@ call_builtin(struct tbl *tp, const char
 }
 
 /*
- * set up redirection, saving old fds in e->savefd
+ * set up redirection, saving old fds in e->savedfd
  */
 static int
 iosetup(struct ioword *iop, struct tbl *tp)
@@ -1524,25 +1532,20 @@ iosetup(struct ioword *iop, struct tbl *
 		}
 		return (-1);
 	}
-	/* Do not save if it has already been redirected (i.e. "cat >x >y"). */
-	if (e->savefd[iop->unit] == 0) {
-		/* If these are the same, it means unit was previously closed */
-		if (u == (int)iop->unit)
-			e->savefd[iop->unit] = -1;
-		else
-			/*
-			 * c_exec() assumes e->savefd[fd] set for any
-			 * redirections. Ask savefd() not to close iop->unit;
-			 * this allows error messages to be seen if iop->unit
-			 * is 2; also means we can't lose the fd (eg, both
-			 * dup2 below and dup2 in restfd() failing).
-			 */
-			e->savefd[iop->unit] = savefd(iop->unit);
-	}
+	/* only save if it has not yet been redirected (e.g. by "cat >x >y") */
+	if (FDSVNUM(e, iop->unit) == 0U) {
+		/* c_exec() assumes e->savedfd[fd] set for any redirection */
+		FDSAVE(iop->unit, u == (int)iop->unit ?
+		    /* previously closed (exec >&-; ls >x; print e) */ -1 :
+		    savefd(iop->unit));
+	} else
+		/* clear previous fd-was-closed flag */
+		e->savedfd[iop->unit] &= FDNUMMASK;
 
-	if (do_close)
+	if (do_close) {
 		close(iop->unit);
-	else if (u != (int)iop->unit) {
+		e->savedfd[iop->unit] |= FDICLMASK;
+	} else if (u != (int)iop->unit) {
 		if (ksh_dup2(u, iop->unit, true) < 0) {
 			int eno;
 			char *sp;
--- mksh-59c.orig/expr.c
+++ mksh-59c/expr.c
@@ -2,7 +2,8 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012, 2013, 2014, 2016, 2017, 2018, 2019
+ *		 2011, 2012, 2013, 2014, 2016, 2017, 2018, 2019,
+ *		 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +24,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.108 2020/06/20 02:27:50 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/expr.c,v 1.114 2021/10/10 20:41:16 tg Exp $");
 
 #define EXPRTOK_DEFNS
 #include "exprtok.h"
@@ -56,12 +57,12 @@ static const char opname[][4] = {
 #include "exprtok.h"
 };
 
-static const uint8_t oplen[] = {
+static const kby oplen[] = {
 #define EXPRTOK_LEN
 #include "exprtok.h"
 };
 
-static const uint8_t opprec[] = {
+static const kby opprec[] = {
 #define EXPRTOK_PREC
 #include "exprtok.h"
 };
@@ -78,7 +79,7 @@ typedef struct expr_state {
 	/* token from token() */
 	enum token tok;
 	/* don't do assignments (for ?:, &&, ||) */
-	uint8_t noassign;
+	kby noassign;
 	/* evaluating an $(()) expression? */
 	bool arith;
 	/* unsigned arithmetic calculation */
@@ -391,6 +392,10 @@ evalexpr(Expr_state *es, unsigned int pr
 		case O_RORASN:
 			t1 = vl->val.u;
 			t2 = vr->val.u & 31;
+			if (!t2) {
+				res = t1;
+				goto rotate_by_zero;
+			}
 			break;
 #endif
 		case O_LAND:
@@ -466,6 +471,7 @@ evalexpr(Expr_state *es, unsigned int pr
 		case O_ROR:
 		case O_RORASN:
 			res = (t1 >> t2) | (t1 << (32 - t2));
+ rotate_by_zero:
 			break;
 #endif
 		case O_LSHIFT:
@@ -597,7 +603,7 @@ exprtoken(Expr_state *es)
 	} else if (c == '1' && cp[1] == '#') {
 		cp += 2;
 		if (*cp)
-			cp += utf_ptradj(cp);
+			cp += ez_mbtoc(NULL, cp);
 		strndupx(tvar, es->tokp, cp - es->tokp, ATEMP);
 		goto process_tvar;
 #ifndef MKSH_SMALL
@@ -606,7 +612,7 @@ exprtoken(Expr_state *es)
 			es->tok = END;
 			evalerr(es, ET_UNEXPECTED, NULL);
 		}
-		cp += utf_ptradj(cp);
+		cp += ez_mbtoc(NULL, cp);
 		if (*cp++ != '\'')
 			evalerr(es, ET_STR,
 			    "multi-character character constant");
@@ -699,11 +705,30 @@ intvar(Expr_state *es, struct tbl *vp)
 	return (vq);
 }
 
-
 /*
  * UTF-8 support code: high-level functions
  */
 
+char *
+ez_bs(char *cp, char *lower_bound)
+{
+	if (UTFMODE) {
+		char *bp = cp;
+		size_t n;
+
+		/* skip backwards knowing the UTF-8 encoding */
+		while (bp > lower_bound && (rtt2asc(*bp) & 0xC0U) == 0x80U)
+			--bp;
+		/* ensure we arrive back at the original point */
+		n = ez_mbtoc(NULL, bp);
+		/* back where we started? if so, this was indeed UTF-8 */
+		if (bp + n - 1 == cp)
+			return (bp);
+		/* no so some raw octet is at *cp */
+	}
+	return (cp);
+}
+
 int
 utf_widthadj(const char *src, const char **dst)
 {
@@ -711,15 +736,12 @@ utf_widthadj(const char *src, const char
 	unsigned int wc;
 	int width;
 
-	if (!UTFMODE || (len = utf_mbtowc(&wc, src)) == (size_t)-1 ||
-	    wc == 0)
+	if (!UTFMODE || !*src || (len = utf_mbtowc(&wc, src)) == (size_t)-1)
 		len = width = 1;
 	else if ((width = utf_wcwidth(wc)) < 0)
-		/* XXX use 2 for x_zotc3 here? */
 		width = 1;
 
-	if (dst)
-		*dst = src + len;
+	*dst = src + len;
 	return (width);
 }
 
@@ -745,41 +767,6 @@ utf_mbswidth(const char *s)
 	return (width);
 }
 
-const char *
-utf_skipcols(const char *p, int cols, int *colp)
-{
-	int c = 0;
-	const char *q;
-
-	while (c < cols) {
-		if (!*p) {
-			/* end of input; special handling for edit.c */
-			if (!colp)
-				return (p + cols - c);
-			*colp = c;
-			return (p);
-		}
-		c += utf_widthadj(p, &p);
-	}
-	if (UTFMODE)
-		while (utf_widthadj(p, &q) == 0)
-			p = q;
-	if (colp)
-		*colp = c;
-	return (p);
-}
-
-size_t
-utf_ptradj(const char *src)
-{
-	register size_t n;
-
-	if (!UTFMODE || rtt2asc(*src) < 0xC2 ||
-	    (n = utf_mbtowc(NULL, src)) == (size_t)-1)
-		n = 1;
-	return (n);
-}
-
 /*
  * UTF-8 support code: low-level functions
  */
@@ -850,6 +837,54 @@ utf_wctomb(char *dst, unsigned int wc)
 	return ((char *)d - dst);
 }
 
+/* “give me that character right now” */
+
+#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
+/* as UCS codepoint; dst must not be NULL */
+size_t
+ez_mbtowc(unsigned int *dst, const char *src)
+{
+	size_t n;
+
+	if (UTFMODE) {
+		if ((n = utf_mbtowc(dst, src)) != (size_t)-1)
+			return (n);
+		*dst = OPTUMKRAW(rtt2asc(*src));
+	} else
+		*dst = ord(rtt2asc(*src));
+	return (*src ? 1 : 0);
+}
+/* identical to ez_mbtoc, unless EBCDIC… */
+#endif
+
+/* as kby if !UTFMODE, UCS codepoint or OPTURAW otherwise */
+size_t
+ez_mbtoc(unsigned int *dst, const char *src)
+{
+	size_t n;
+
+	if (UTFMODE) {
+		if ((n = utf_mbtowc(dst, src)) != (size_t)-1)
+			return (n);
+		if (dst)
+			*dst = OPTUMKRAW(rtt2asc(*src));
+	} else if (dst)
+		*dst = ord(*src);
+	return (*src ? 1 : 0);
+}
+
+size_t
+ez_ctomb(char *dst, unsigned int wc)
+{
+	if (!UTFMODE)
+		*dst = (kby)wc;
+	else if (OPTUISRAW(wc))
+		*dst = asc2rtt((kby)wc);
+	else
+		return (utf_wctomb(dst, wc));
+	return (1);
+}
+
 /*
  * Wrapper around access(2) because it says root can execute everything
  * on some operating systems. Does not set errno, no user needs it. Use
@@ -1220,8 +1255,12 @@ int
 utf_wcwidth(unsigned int wc)
 {
 	/* except NUL, C0/C1 control characters and DEL yield -1 */
-	if (wc < 0x20 || (wc >= 0x7F && wc < 0xA0))
+	if (wc < 0x20)
 		return (wc ? -1 : 0);
+	if (wc < 0x7F)
+		return (1);
+	if (wc < 0xA0)
+		return (-1);
 
 	/* combining characters use 0 screen columns */
 	if (mb_ucsbsearch(mb_ucs_combining, NELEM(mb_ucs_combining), wc))
--- mksh-59c.orig/funcs.c
+++ mksh-59c/funcs.c
@@ -5,7 +5,7 @@
 /*-
  * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
  *		 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
- *		 2019, 2020
+ *		 2019, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -30,15 +30,12 @@
 #if HAVE_SYS_BSDTYPES_H
 #include <sys/bsdtypes.h>
 #endif
-#if HAVE_SYS_SELECT_H
-#include <sys/select.h>
-#endif
 #if HAVE_BSTRING_H
 #include <bstring.h>
 #endif
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.379 2020/08/27 19:52:44 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/funcs.c,v 1.393 2021/10/10 20:30:33 tg Exp $");
 
 #if HAVE_KILLPG
 /*
@@ -98,7 +95,6 @@ const struct builtin mkshbuiltins[] = {
 	{Tsgbreak, c_brkcont},
 	{T__builtin, c_builtin},
 	{Tbuiltin, c_builtin},
-	{Tbcat, c_cat},
 	{Tcd, c_cd},
 	/* dash compatibility hack */
 	{"chdir", c_cd},
@@ -120,7 +116,9 @@ const struct builtin mkshbuiltins[] = {
 	{Tread, c_read},
 	{Tdsgreadonly, c_typeset},
 	{"!realpath", c_realpath},
+#if HAVE_RENAME
 	{"~rename", c_rename},
+#endif
 	{"*=return", c_exitreturn},
 	{Tsghset, c_set},
 	{"*=#shift", c_shift},
@@ -152,13 +150,6 @@ const struct builtin mkshbuiltins[] = {
 #ifdef MKSH_PRINTF_BUILTIN
 	{"~printf", c_printf},
 #endif
-#if HAVE_SELECT
-	{"sleep", c_sleep},
-#endif
-#ifdef __MirBSD__
-	/* alias to "true" for historical reasons */
-	{"domainname", c_true},
-#endif
 #ifdef __OS2__
 	{Textproc, c_true},
 #endif
@@ -285,8 +276,6 @@ c_print(const char **wp)
 		mksh_ari_t wc;
 		/* output file descriptor (if any) */
 		int fd;
-		/* temporary storage for a multibyte character */
-		char ts[4];
 		/* output word separator */
 		char ws;
 		/* output line separator */
@@ -451,20 +440,13 @@ c_print(const char **wp)
 				break;
 			if (!evaluate(s, &po.wc, KSH_RETURN_ERROR, true))
 				return (1);
-			Xcheck(xs, xp);
-			if (UTFMODE) {
-				po.ts[utf_wctomb(po.ts, po.wc)] = 0;
-				c = 0;
-				do {
-					Xput(xs, xp, po.ts[c]);
-				} while (po.ts[++c]);
-			} else
-				Xput(xs, xp, po.wc & 0xFF);
+			XcheckN(xs, xp, 4);
+			xp += ez_ctomb(xp, po.wc);
 		}
 	} else {
 		s = *wp++;
 		while ((c = *s++) != '\0') {
-			Xcheck(xs, xp);
+			XcheckN(xs, xp, 4);
 			if (po.exp && c == '\\') {
 				s_ptr = s;
 				c = unbksl(false, s_get, s_put);
@@ -485,11 +467,7 @@ c_print(const char **wp)
 					}
 				} else if ((unsigned int)c > 0xFF) {
 					/* generic function returned UCS */
-					po.ts[utf_wctomb(po.ts, c - 0x100)] = 0;
-					c = 0;
-					do {
-						Xput(xs, xp, po.ts[c]);
-					} while (po.ts[++c]);
+					xp += utf_wctomb(xp, c - 0x100);
 					continue;
 				}
 			}
@@ -562,6 +540,7 @@ c_print(const char **wp)
 						po.copipe = block_pipe();
 					continue;
 				}
+				bi_errorf(Tf_sD_s, Twrite, cstrerror(errno));
 				c = 1;
 				break;
 			}
@@ -1142,7 +1121,8 @@ c_kill(const char **wp)
 			n = 1;
 			while (n < ksh_NSIG) {
 				shf_puts(sigtraps[n].name, shl_stdout);
-				shf_putc(++n == ksh_NSIG ? '\n' : ' ',
+				++n;
+				shf_putc(n == ksh_NSIG ? '\n' : ' ',
 				    shl_stdout);
 			}
 		} else {
@@ -1682,8 +1662,7 @@ c_read(const char **wp)
 	}
 
 	if ((ccp = cstrchr(*wp, '?')) != NULL) {
-		strdupx(allocd, *wp, ATEMP);
-		allocd[ccp - *wp] = '\0';
+		strndupx(allocd, *wp, ccp - *wp, ATEMP);
 		*wp = allocd;
 		if (isatty(fd)) {
 			/*
@@ -1899,18 +1878,23 @@ c_read(const char **wp)
 		goto c_read_gotword;
 	}
 	if (aschars) {
+		bytesleft = ez_mbtoc(NULL, ccp);
+		if (!bytesleft) {
+			/* got a NUL byte */
+			Xput(xs, xp, '2');
+			Xput(xs, xp, '#');
+			Xput(xs, xp, '0');
+			++ccp;
+			--bytesread;
+			goto c_read_gotword;
+		}
 		Xput(xs, xp, '1');
 		Xput(xs, xp, '#');
-		bytesleft = utf_ptradj(ccp);
 		while (bytesleft && bytesread) {
 			*xp++ = *ccp++;
 			--bytesleft;
 			--bytesread;
 		}
-		if (xp[-1] == '\0') {
-			xp[-1] = '0';
-			xp[-3] = '2';
-		}
 		goto c_read_gotword;
 	}
 
@@ -2344,13 +2328,15 @@ c_times(const char **wp MKSH_A_UNUSED)
 {
 	struct rusage usage;
 
-	getrusage(RUSAGE_SELF, &usage);
+	if (ksh_getrusage(RUSAGE_SELF, &usage))
+		bi_errorf("getrusage: %s", cstrerror(errno));
 	p_time(shl_stdout, false, usage.ru_utime.tv_sec,
 	    usage.ru_utime.tv_usec, 0, null, T1space);
 	p_time(shl_stdout, false, usage.ru_stime.tv_sec,
 	    usage.ru_stime.tv_usec, 0, null, "\n");
 
-	getrusage(RUSAGE_CHILDREN, &usage);
+	if (ksh_getrusage(RUSAGE_CHILDREN, &usage))
+		bi_errorf("getrusage: %s", cstrerror(errno));
 	p_time(shl_stdout, false, usage.ru_utime.tv_sec,
 	    usage.ru_utime.tv_usec, 0, null, T1space);
 	p_time(shl_stdout, false, usage.ru_stime.tv_sec,
@@ -2373,8 +2359,11 @@ timex(struct op *t, int f, volatile int
 	struct timeval usrtime, systime, tv0, tv1;
 
 	mksh_TIME(tv0);
-	getrusage(RUSAGE_SELF, &ru0);
-	getrusage(RUSAGE_CHILDREN, &cru0);
+	if (ksh_getrusage(RUSAGE_SELF, &ru0) ||
+	    ksh_getrusage(RUSAGE_CHILDREN, &cru0)) {
+		warningf(true, "time: getrusage: %s", cstrerror(errno));
+		return (125);
+	}
 	if (t->left) {
 		/*
 		 * Two ways of getting cpu usage of a command: just use t0
@@ -2390,8 +2379,11 @@ timex(struct op *t, int f, volatile int
 		if (t->left->type == TCOM)
 			tf |= t->left->str[0];
 		mksh_TIME(tv1);
-		getrusage(RUSAGE_SELF, &ru1);
-		getrusage(RUSAGE_CHILDREN, &cru1);
+		if (ksh_getrusage(RUSAGE_SELF, &ru1) ||
+		    ksh_getrusage(RUSAGE_CHILDREN, &cru1)) {
+			warningf(true, "time: getrusage: %s", cstrerror(errno));
+			return (rv);
+		}
 	} else
 		tf = TF_NOARGS;
 
@@ -2472,22 +2464,35 @@ int
 c_exec(const char **wp MKSH_A_UNUSED)
 {
 	int i;
+	kui sfd;
+
+	if (e->savedfd == NULL)
+		return (0);
 
 	/* make sure redirects stay in place */
-	if (e->savefd != NULL) {
+
+	/* for ksh, keep file descriptors private (except stdin/out/err)… */
+	if (!Flag(FPOSIX) && !Flag(FSH)) {
 		for (i = 0; i < NUFILE; i++) {
-			if (e->savefd[i] > 0)
-				close(e->savefd[i]);
-			/*
-			 * keep all file descriptors > 2 private for ksh,
-			 * but not for POSIX or legacy/kludge sh
-			 */
-			if (!Flag(FPOSIX) && !Flag(FSH) && i > 2 &&
-			    e->savefd[i])
-				fcntl(i, F_SETFD, FD_CLOEXEC);
+			if (!(sfd = FDSVNUM(e, i)))
+				continue;
+			if (sfd > (kui)FDBASE)
+				close((int)sfd);
+			if (i > 2 && !(e->savedfd[i] & FDICLMASK) &&
+			    fcntl(i, F_SETFD, FD_CLOEXEC) == -1)
+				internal_warningf(Tcloexec_failed, "set", i,
+				    cstrerror(errno));
+		}
+	} else {
+		/* … but not for POSIX or legacy/kludge sh */
+		for (i = 0; i < NUFILE; i++) {
+			sfd = FDSVNUM(e, i);
+			if (sfd > (kui)FDBASE)
+				close((int)sfd);
 		}
-		e->savefd = NULL;
 	}
+
+	e->savedfd = NULL;
 	return (0);
 }
 
@@ -2757,11 +2762,6 @@ test_isop(Test_meta meta, const char *s)
 #define test_lstat(name,buffer)	lstat((name), (buffer))
 #endif
 
-#if HAVE_ST_MTIM
-#undef st_mtimensec
-#define st_mtimensec st_mtim.tv_nsec
-#endif
-
 static int
 mtimecmp(const struct stat *sb1, const struct stat *sb2)
 {
@@ -2769,7 +2769,7 @@ mtimecmp(const struct stat *sb1, const s
 		return (-1);
 	if (sb1->st_mtime > sb2->st_mtime)
 		return (1);
-#if (HAVE_ST_MTIMENSEC || HAVE_ST_MTIM)
+#if HAVE_ST_MTIMENSEC
 	if (sb1->st_mtimensec < sb2->st_mtimensec)
 		return (-1);
 	if (sb1->st_mtimensec > sb2->st_mtimensec)
@@ -3223,6 +3223,7 @@ ptest_error(Test_env *te, int ofs, const
 		bi_errorf(Tf_s, msg);
 }
 
+#if HAVE_RENAME
 int
 c_rename(const char **wp)
 {
@@ -3246,6 +3247,7 @@ c_rename(const char **wp)
 
 	return (rv);
 }
+#endif
 
 int
 c_realpath(const char **wp)
@@ -3276,167 +3278,6 @@ c_realpath(const char **wp)
 	return (rv);
 }
 
-int
-c_cat(const char **wp)
-{
-	int fd = 0, rv;
-	ssize_t n, w;
-	const char *fn = "<stdin>";
-	char *buf, *cp;
-	bool opipe;
-#define MKSH_CAT_BUFSIZ 4096
-
-	/* parse options: POSIX demands we support "-u" as no-op */
-	while ((rv = ksh_getopt(wp, &builtin_opt, Tu)) != -1) {
-		switch (rv) {
-		case 'u':
-			/* we already operate unbuffered */
-			break;
-		default:
-			bi_errorf(Tsynerr);
-			return (1);
-		}
-	}
-	wp += builtin_opt.optind;
-	rv = 0;
-
-	if ((buf = malloc_osfunc(MKSH_CAT_BUFSIZ)) == NULL) {
-		bi_errorf(Toomem, (size_t)MKSH_CAT_BUFSIZ);
-		return (1);
-	}
-
-	/* catch SIGPIPE */
-	opipe = block_pipe();
-
-	do {
-		if (*wp) {
-			fn = *wp++;
-			if (ksh_isdash(fn))
-				fd = 0;
-			else if ((fd = binopen2(fn, O_RDONLY)) < 0) {
-				bi_errorf(Tf_sD_s, fn, cstrerror(errno));
-				rv = 1;
-				continue;
-			}
-		}
-		while (/* CONSTCOND */ 1) {
-			if ((n = blocking_read(fd, (cp = buf),
-			    MKSH_CAT_BUFSIZ)) == -1) {
-				if (errno == EINTR) {
-					if (opipe)
-						restore_pipe();
-					/* give the user a chance to ^C out */
-					intrcheck();
-					/* interrupted, try again */
-					opipe = block_pipe();
-					continue;
-				}
-				/* an error occurred during reading */
-				bi_errorf(Tf_sD_s, fn, cstrerror(errno));
-				rv = 1;
-				break;
-			} else if (n == 0)
-				/* end of file reached */
-				break;
-			while (n) {
-				if (intrsig)
-					goto has_intrsig;
-				if ((w = write(1, cp, n)) != -1) {
-					n -= w;
-					cp += w;
-					continue;
-				}
-				if (errno == EINTR) {
- has_intrsig:
-					if (opipe)
-						restore_pipe();
-					/* give the user a chance to ^C out */
-					intrcheck();
-					/* interrupted, try again */
-					opipe = block_pipe();
-					continue;
-				}
-				if (errno == EPIPE) {
-					/* fake receiving signal */
-					rv = ksh_sigmask(SIGPIPE);
-				} else {
-					/* an error occurred during writing */
-					bi_errorf(Tf_sD_s, "<stdout>",
-					    cstrerror(errno));
-					rv = 1;
-				}
-				if (fd != 0)
-					close(fd);
-				goto out;
-			}
-		}
-		if (fd != 0)
-			close(fd);
-	} while (*wp);
-
- out:
-	if (opipe)
-		restore_pipe();
-	free_osfunc(buf);
-	return (rv);
-}
-
-#if HAVE_SELECT
-int
-c_sleep(const char **wp)
-{
-	struct timeval tv;
-	int rv = 1;
-
-	/* skip argv[0] */
-	++wp;
-	if (wp[0] && !strcmp(wp[0], "--"))
-		/* skip "--" (options separator) */
-		++wp;
-
-	if (!wp[0] || wp[1])
-		bi_errorf(Tsynerr);
-	else if (parse_usec(wp[0], &tv))
-		bi_errorf(Tf_sD_s_qs, Tsynerr, cstrerror(errno), wp[0]);
-	else {
-#ifndef MKSH_NOPROSPECTOFWORK
-		sigset_t omask, bmask;
-
-		/* block a number of signals from interrupting us, though */
-		(void)sigemptyset(&bmask);
-		(void)sigaddset(&bmask, SIGPIPE);
-		(void)sigaddset(&bmask, SIGCHLD);
-#ifdef SIGWINCH
-		(void)sigaddset(&bmask, SIGWINCH);
-#endif
-#ifdef SIGINFO
-		(void)sigaddset(&bmask, SIGINFO);
-#endif
-#ifdef SIGUSR1
-		(void)sigaddset(&bmask, SIGUSR1);
-#endif
-#ifdef SIGUSR2
-		(void)sigaddset(&bmask, SIGUSR2);
-#endif
-		sigprocmask(SIG_BLOCK, &bmask, &omask);
-#endif
-		if (select(1, NULL, NULL, NULL, &tv) == 0 || errno == EINTR)
-			/*
-			 * strictly speaking only for SIGALRM, but the
-			 * execution may be interrupted by other signals
-			 */
-			rv = 0;
-		else
-			bi_errorf(Tf_sD_s, Tselect, cstrerror(errno));
-#ifndef MKSH_NOPROSPECTOFWORK
-		/* this will re-schedule signal delivery */
-		sigprocmask(SIG_SETMASK, &omask, NULL);
-#endif
-	}
-	return (rv);
-}
-#endif
-
 #if !defined(MKSH_UNEMPLOYED) && HAVE_GETSID
 static int
 c_suspend(const char **wp)
--- mksh-59c.orig/histrap.c
+++ mksh-59c/histrap.c
@@ -3,7 +3,8 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012, 2014, 2015, 2016, 2017, 2018, 2019
+ *		 2011, 2012, 2014, 2015, 2016, 2017, 2018, 2019,
+ *		 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -27,10 +28,9 @@
 #include <sys/file.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.170 2020/10/01 22:53:20 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/histrap.c,v 1.176 2021/10/10 20:41:16 tg Exp $");
 
 Trap sigtraps[ksh_NSIG + 1];
-static struct sigaction Sigact_ign;
 
 #if HAVE_PERSISTENT_HISTORY
 static int histload(Source *, unsigned char *, size_t);
@@ -198,7 +198,7 @@ c_fc(const char **wp)
 			pat_len = strlen(pat);
 			rep_len = strlen(rep);
 			Xinit(xs, xp, 128, ATEMP);
-			for (s = *hp; (s1 = strstr(s, pat)) &&
+			for (s = *hp; (s1 = ucstrstr(s, pat)) &&
 			    (!any_subst || gflag); s = s1 + pat_len) {
 				any_subst = true;
 				len = s1 - s;
@@ -278,7 +278,7 @@ c_fc(const char **wp)
 			shf_putc('\t', shl_stdout);
 			/* print multi-line commands correctly */
 			s = *hp;
-			while ((t = strchr(s, '\n'))) {
+			while ((t = ucstrchr(s, '\n'))) {
 				*t = '\0';
 				shf_fprintf(shl_stdout, "%s\n\t", s);
 				*t++ = '\n';
@@ -493,7 +493,7 @@ findhist(int start, const char *str, boo
 	hp = &history[start];
 	for (; hp >= history && hp <= histptr; hp += incr)
 		if ((anchored && strncmp(*hp, str, len) == 0) ||
-		    (!anchored && strstr(*hp, str)))
+		    (!anchored && vstrstr(*hp, str)))
 			return (hp - history);
 
 	return (-1);
@@ -573,7 +573,6 @@ init_histvec(void)
 	}
 }
 
-
 /*
  * It turns out that there is a lot of ghastly hackery here
  */
@@ -788,8 +787,10 @@ hist_persist_init(void)
 	/* we have a file and are interactive */
 	if ((fd = binopen3(hname, O_RDWR | O_CREAT | O_APPEND, 0600)) < 0)
 		return;
-	if ((histfd = savefd(fd)) < 0)
+	if ((histfd = savefd(fd)) < 0) {
+		close(fd);
 		return;
+	}
 	if (histfd != fd)
 		close(fd);
 
@@ -1034,6 +1035,7 @@ hist_finish(void)
 }
 #endif
 
+/* +++ signals +++ */
 
 #if !HAVE_SYS_SIGNAME
 static const struct mksh_sigpair {
@@ -1122,10 +1124,6 @@ inittraps(void)
 	sigtraps[ksh_SIGERR].name = "ERR";
 	sigtraps[ksh_SIGERR].mess = "Error handler";
 
-	(void)sigemptyset(&Sigact_ign.sa_mask);
-	Sigact_ign.sa_flags = 0; /* interruptible */
-	Sigact_ign.sa_handler = SIG_IGN;
-
 	sigtraps[SIGINT].flags |= TF_DFL_INTR | TF_TTY_INTR;
 	sigtraps[SIGQUIT].flags |= TF_DFL_INTR | TF_TTY_INTR;
 	/* SIGTERM is not fatal for interactive */
@@ -1496,20 +1494,18 @@ restore_pipe(void)
 int
 setsig(Trap *p, sig_t f, int flags)
 {
-	struct sigaction sigact;
-
 	if (p->signal == ksh_SIGEXIT || p->signal == ksh_SIGERR)
 		return (1);
 
-	memset(&sigact, 0, sizeof(sigact));
-
 	/*
 	 * First time setting this signal? If so, get and note the current
 	 * setting.
 	 */
 	if (!(p->flags & (TF_ORIG_IGN|TF_ORIG_DFL))) {
-		sigaction(p->signal, &Sigact_ign, &sigact);
-		p->flags |= sigact.sa_handler == SIG_IGN ?
+		ksh_sigsaved ohandler;
+
+		ksh_sigset(p->signal, SIG_IGN, &ohandler);
+		p->flags |= ksh_sighandler(ohandler) == SIG_IGN ?
 		    TF_ORIG_IGN : TF_ORIG_DFL;
 		p->cursig = SIG_IGN;
 	}
@@ -1540,11 +1536,7 @@ setsig(Trap *p, sig_t f, int flags)
 
 	if (p->cursig != f) {
 		p->cursig = f;
-		(void)sigemptyset(&sigact.sa_mask);
-		/* interruptible */
-		sigact.sa_flags = 0;
-		sigact.sa_handler = f;
-		sigaction(p->signal, &sigact, NULL);
+		ksh_sigset(p->signal, f, NULL);
 	}
 
 	return (1);
@@ -1629,3 +1621,72 @@ mksh_unlkfd(int fd)
 }
 #endif
 #endif
+
+/*
+ * On handling errors when setting signals
+ *
+ * The signal management calls fail with:
+ * - EFAULT: (sigaction only) &sa or old point to invalid memory,
+ *   which is not bloody likely
+ * - E?????: (sigaction only) if SA_SIGINFO is set and […]
+ *   but we don’t ever set SA_SIGINFO
+ * - EINVAL: on invalid signal number; operating on uncatchable
+ *   respectively unignorable signals (SIGKILL, SIGSTOP)
+ *
+ * The signal number is already verified in higher-up code. We
+ * deliberately do not error nor even warn for SIGKILL or SIGSTOP
+ * because startx on Debian for example attempts that (POSIX says
+ * undefined); therefore silently ignoring invalid signal numbers
+ * that otherwise pass muster is acceptable.
+ */
+
+#if HAVE_SIGACTION
+#ifndef SIG_ERR
+static void
+ksh_sigerr(int sig MKSH_A_UNUSED)
+{
+}
+#define SIG_ERR (&ksh_sigerr)
+#endif
+
+/* masks the signal, does not (may) restart, not oneshot */
+void
+ksh_sigset(int sig, sig_t act, ksh_sigsaved *old)
+{
+	int rv;
+
+	if (act != SIG_ERR) {
+		struct sigaction sa;
+
+		memset(&sa, '\0', sizeof(sa));
+		sigemptyset(&sa.sa_mask);
+		sa.sa_handler = act;
+		rv = sigaction(sig, &sa, old);
+	} else if (!old)
+		return;
+	else
+		rv = sigaction(sig, NULL, old);
+	if (rv && old) {
+		memset(old, '\0', sizeof(*old));
+		old->sa_handler = SIG_ERR;
+	}
+}
+
+void
+ksh_sigrestore(int sig, ksh_sigsaved *savedp)
+{
+	if (savedp->sa_handler != SIG_ERR)
+		sigaction(sig, savedp, NULL);
+}
+#elif defined(MKSH_USABLE_SIGNALFUNC)
+/* masks the signal, may (probably will, not always) restart, not oneshot */
+void
+ksh_sigset(int sig, sig_t act, ksh_sigsaved *old)
+{
+	sig_t res;
+
+	res = act == SIG_ERR ? SIG_ERR : MKSH_USABLE_SIGNALFUNC(sig, act);
+	if (old)
+		*old = res;
+}
+#endif
--- mksh-59c.orig/jobs.c
+++ mksh-59c/jobs.c
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
- *		 2012, 2013, 2014, 2015, 2016, 2018, 2019
+ *		 2012, 2013, 2014, 2015, 2016, 2018, 2019, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -22,8 +22,11 @@
  */
 
 #include "sh.h"
+#ifdef MKSH_POLL_FOR_PAUSE
+#include <poll.h>
+#endif
 
-__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.128 2019/12/11 19:46:20 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/jobs.c,v 1.145 2021/10/10 20:41:17 tg Exp $");
 
 #if HAVE_KILLPG
 #define mksh_killpg		killpg
@@ -38,6 +41,8 @@ __RCSID("$MirOS: src/bin/mksh/jobs.c,v 1
 #define PSIGNALLED	2
 #define PSTOPPED	3
 
+#define PROC_TGTSZ	256
+
 typedef struct proc Proc;
 /* to take alignment into consideration */
 struct proc_dummy {
@@ -45,8 +50,14 @@ struct proc_dummy {
 	pid_t pid;
 	int state;
 	int status;
-	char command[128];
+	char command[PROC_TGTSZ - (ALLOC_OVERHEAD + 32)];
 };
+#ifdef MKSH_BROKEN_OFFSETOF
+/* assumes no padding; check manually! */
+#define PROC_OFS (sizeof(Proc *) + sizeof(pid_t) + 2 * sizeof(int))
+#else
+#define PROC_OFS (offsetof(struct proc_dummy, command[0]))
+#endif
 /* real structure */
 struct proc {
 	/* next process in pipeline (if any) */
@@ -58,8 +69,7 @@ struct proc {
 	/* wait status */
 	int status;
 	/* process command string from vistree */
-	char command[256 - (ALLOC_OVERHEAD +
-	    offsetof(struct proc_dummy, command[0]))];
+	char command[PROC_TGTSZ - (ALLOC_OVERHEAD + PROC_OFS)];
 };
 
 /* Notify/print flag - j_print() argument */
@@ -120,6 +130,8 @@ struct job {
 #define JL_AMBIG	1	/* %foo or %?foo is ambiguous */
 #define JL_INVALID	2	/* non-pid, non-% job id */
 
+const char Tpipest[] = "PIPESTATUS";
+
 static const char * const lookup_msgs[] = {
 	"no such job",
 	"ambiguous",
@@ -166,6 +178,9 @@ static int		kill_job(Job *, int);
 static void tty_init_talking(void);
 static void tty_init_state(void);
 
+static void vistree(char *, size_t, struct op *)
+    MKSH_A_BOUNDED(__string__, 1, 2);
+
 /* initialise job control */
 void
 j_init(void)
@@ -227,6 +242,7 @@ proc_errorlevel(Proc *p)
 	case PEXITED:
 		return ((WEXITSTATUS(p->status)) & 255);
 	case PSIGNALLED:
+		/* coverity[result_independent_of_operands : SUPPRESS] */
 		return (ksh_sigmask(WTERMSIG(p->status)));
 	default:
 		return (0);
@@ -238,7 +254,7 @@ proc_errorlevel(Proc *p)
 void
 j_suspend(void)
 {
-	struct sigaction sa, osa;
+	ksh_sigsaved ohandler;
 
 	/* Restore tty and pgrp. */
 	if (ttypgrp_ok) {
@@ -256,14 +272,11 @@ j_suspend(void)
 	}
 
 	/* Suspend the shell. */
-	memset(&sa, 0, sizeof(sa));
-	sigemptyset(&sa.sa_mask);
-	sa.sa_handler = SIG_DFL;
-	sigaction(SIGTSTP, &sa, &osa);
+	ksh_sigset(SIGTSTP, SIG_DFL, &ohandler);
 	kill(0, SIGTSTP);
 
 	/* Back from suspend, reset signals, pgrp and tty. */
-	sigaction(SIGTSTP, &osa, NULL);
+	ksh_sigrestore(SIGTSTP, &ohandler);
 	if (ttypgrp_ok) {
 		if (restore_ttypgrp >= 0) {
 			if (setpgid(0, kshpid) < 0) {
@@ -635,7 +648,7 @@ exchild(struct op *t, int flags,
 				for (p = j->proc_list; p; p = p->next)
 					shf_fprintf(shl_out, Tf__d,
 					    (int)p->pid);
-				shf_putchar('\n', shl_out);
+				shf_putc('\n', shl_out);
 				shf_flush(shl_out);
 			}
 		} else
@@ -834,8 +847,10 @@ j_resume(const char *cp, int bg)
 		return (1);
 	}
 
-	if (bg)
-		shprintf("[%d] ", j->job);
+	if (bg) {
+		shprintf("[%d]", j->job);
+		shf_putc(' ', shl_stdout);
+	}
 
 	running = false;
 	for (p = j->proc_list; p != NULL; p = p->next) {
@@ -846,7 +861,7 @@ j_resume(const char *cp, int bg)
 		}
 		shf_puts(p->command, shl_stdout);
 		if (p->next)
-			shf_puts("| ", shl_stdout);
+			shf_puts(" | ", shl_stdout);
 	}
 	shf_putc('\n', shl_stdout);
 	shf_flush(shl_stdout);
@@ -938,7 +953,6 @@ j_stopped_running(void)
 	return (0);
 }
 
-
 /* list jobs for jobs built-in */
 int
 j_jobs(const char *cp, int slp,
@@ -1126,7 +1140,7 @@ j_waitj(Job *j,
 {
 	Proc *p;
 	int rv;
-#ifdef MKSH_NO_SIGSUSPEND
+#if !defined(MKSH_NOPROSPECTOFWORK) && defined(MKSH_NO_SIGSUSPEND)
 	sigset_t omask;
 #endif
 
@@ -1147,7 +1161,11 @@ j_waitj(Job *j,
 #ifndef MKSH_NOPROSPECTOFWORK
 #ifdef MKSH_NO_SIGSUSPEND
 		sigprocmask(SIG_SETMASK, &sm_default, &omask);
+#ifdef MKSH_POLL_FOR_PAUSE
+		poll(NULL, 0, -1);
+#else
 		pause();
+#endif
 		/* note that handlers may run here so they need to know */
 		sigprocmask(SIG_SETMASK, &omask, NULL);
 #else
@@ -1257,6 +1275,7 @@ j_waitj(Job *j,
 	} else if (flags & JW_PIPEST) {
 		uint32_t num = 0;
 		struct tbl *vp;
+		kby *vt;
 
 		unset(vp_pipest, 1);
 		vp = vp_pipest;
@@ -1264,17 +1283,13 @@ j_waitj(Job *j,
 		goto got_array;
 
 		while (p != NULL) {
-			{
-				struct tbl *vq;
-
-				/* strlen(vp_pipest->name) == 10 */
-				vq = alloc(offsetof(struct tbl, name[0]) + 11,
-				    vp_pipest->areap);
-				memset(vq, 0, offsetof(struct tbl, name[0]));
-				memcpy(vq->name, vp_pipest->name, 11);
-				vp->u.array = vq;
-				vp = vq;
-			}
+			vt = alloc(offsetof(struct tbl, name[0]) +
+			    sizeof(Tpipest), vp_pipest->areap);
+			memset(vt, 0, offsetof(struct tbl, name[0]));
+			memcpy(vt + offsetof(struct tbl, name[0]),
+			    Tpipest, sizeof(Tpipest));
+			vp->u.array = (void *)vt;
+			vp = (void *)vt;
 			vp->areap = vp_pipest->areap;
 			vp->ua.index = ++num;
 			vp->flag = DEFINED | ISSET | INTEGER | RDONLY |
@@ -1327,7 +1342,7 @@ j_sigchld(int sig MKSH_A_UNUSED)
 	pid_t pid;
 	int status;
 	struct rusage ru0, ru1;
-#ifdef MKSH_NO_SIGSUSPEND
+#if !defined(MKSH_NOPROSPECTOFWORK) && defined(MKSH_NO_SIGSUSPEND)
 	sigset_t omask;
 
 	/* this handler can run while SIGCHLD is not blocked, so block it now */
@@ -1348,7 +1363,8 @@ j_sigchld(int sig MKSH_A_UNUSED)
 		}
 #endif
 
-	getrusage(RUSAGE_CHILDREN, &ru0);
+	if (ksh_getrusage(RUSAGE_CHILDREN, &ru0))
+		warningf(true, "getrusage1: %s", cstrerror(errno));
 	do {
 #ifndef MKSH_NOPROSPECTOFWORK
 		pid = waitpid(-1, &status, (WNOHANG |
@@ -1367,7 +1383,8 @@ j_sigchld(int sig MKSH_A_UNUSED)
 		if (pid <= 0)
 			goto j_sigchld_out;
 
-		getrusage(RUSAGE_CHILDREN, &ru1);
+		if (ksh_getrusage(RUSAGE_CHILDREN, &ru1))
+			warningf(true, "getrusage2: %s", cstrerror(errno));
 
 		/* find job and process structures for this pid */
 		for (j = job_list; j != NULL; j = j->next)
@@ -1417,7 +1434,7 @@ j_sigchld(int sig MKSH_A_UNUSED)
 #endif
 
  j_sigchld_out:
-#ifdef MKSH_NO_SIGSUSPEND
+#if !defined(MKSH_NOPROSPECTOFWORK) && defined(MKSH_NO_SIGSUSPEND)
 	sigprocmask(SIG_SETMASK, &omask, NULL);
 #endif
 	errno = saved_errno;
@@ -1492,16 +1509,17 @@ check_job(Job *j)
 			put_job(j, PJ_ON_FRONT);
 		if (Flag(FNOTIFY) &&
 		    (j->flags & (JF_WAITING|JF_W_ASYNCNOTIFY)) != JF_WAITING) {
-			/* Look for the real file descriptor 2 */
-			{
-				struct env *ep;
-				int fd = 2;
-
-				for (ep = e; ep; ep = ep->oenv)
-					if (ep->savefd && ep->savefd[2])
-						fd = ep->savefd[2];
-				shf_reopen(fd, SHF_WR, shl_j);
+			struct env *ep = e;
+			int fd = 2, nfd;
+
+			/* look for the real file descriptor 2 */
+			while (ep) {
+				if (ep->savedfd && (nfd = SAVEDFD(ep, 2)))
+					fd = nfd;
+				ep = ep->oenv;
 			}
+			shf_reopen(fd, SHF_WR, shl_j);
+
 			/*
 			 * Can't call j_notify() as it removes jobs. The job
 			 * must stay in the job list as j_waitj() may be
@@ -1543,10 +1561,11 @@ j_print(Job *j, int how, struct shf *shf
 #ifdef WCOREDUMP
 	bool coredumped;
 #endif
-	char jobchar = ' ';
-	char buf[64];
+	char jobchar;
+	bool output = false;
+	const char *msg;
 	const char *filler;
-	int output = 0;
+	char msgbuf[sizeof("Done (255)")];
 
 	if (how == JP_PGRP) {
 		/*
@@ -1558,12 +1577,15 @@ j_print(Job *j, int how, struct shf *shf
 		    (j->last_proc ? j->last_proc->pid : 0)));
 		return;
 	}
+	/* how is one of JP_SHORT, JP_MEDIUM, JP_LONG from here */
 	j->flags &= ~JF_CHANGED;
 	filler = j->job > 10 ? "\n       " : "\n      ";
 	if (j == job_list)
 		jobchar = '+';
 	else if (j == job_list->next)
 		jobchar = '-';
+	else
+		jobchar = ' ';
 
 	for (p = j->proc_list; p != NULL;) {
 #ifdef WCOREDUMP
@@ -1571,95 +1593,94 @@ j_print(Job *j, int how, struct shf *shf
 #endif
 		switch (p->state) {
 		case PRUNNING:
-			memcpy(buf, "Running", 8);
+			msg = "Running";
 			break;
-		case PSTOPPED: {
-			int stopsig = WSTOPSIG(p->status);
-
-			strlcpy(buf, stopsig > 0 && stopsig < ksh_NSIG ?
-			    sigtraps[stopsig].mess : "Stopped", sizeof(buf));
+		case PSTOPPED:
+			status = WSTOPSIG(p->status);
+			msg = status > 0 && status < ksh_NSIG ?
+			    sigtraps[status].mess : "Stopped";
 			break;
-		}
-		case PEXITED: {
-			int exitstatus = (WEXITSTATUS(p->status)) & 255;
-
+		case PEXITED:
 			if (how == JP_SHORT)
-				buf[0] = '\0';
-			else if (exitstatus == 0)
-				memcpy(buf, "Done", 5);
-			else
-				shf_snprintf(buf, sizeof(buf), "Done (%d)",
-				    exitstatus);
+				msg = null;
+			else if ((status = (WEXITSTATUS(p->status)) & 255) == 0)
+				msg = "Done";
+			else {
+				shf_snprintf(msgbuf, sizeof(msgbuf),
+				    "Done (%d)", status);
+				msg = msgbuf;
+			}
 			break;
-		}
-		case PSIGNALLED: {
-			int termsig = WTERMSIG(p->status);
+		case PSIGNALLED:
 #ifdef WCOREDUMP
 			if (WCOREDUMP(p->status))
 				coredumped = true;
 #endif
-			/*
-			 * kludge for not reporting 'normal termination
-			 * signals' (i.e. SIGINT, SIGPIPE)
-			 */
-			if (how == JP_SHORT &&
+			status = WTERMSIG(p->status);
+			/* only report “abnormal” termination signals short */
+			if (how != JP_SHORT ||
 #ifdef WCOREDUMP
-			    !coredumped &&
+			    coredumped ||
 #endif
-			    (termsig == SIGINT || termsig == SIGPIPE)) {
-				buf[0] = '\0';
-			} else
-				strlcpy(buf, termsig > 0 && termsig < ksh_NSIG ?
-				    sigtraps[termsig].mess : "Signalled",
-				    sizeof(buf));
-			break;
-		}
+			    (status != SIGINT && status != SIGPIPE)) {
+				msg = status > 0 && status < ksh_NSIG ?
+				    sigtraps[status].mess : "Signalled";
+				break;
+			}
+			/* FALLTHROUGH */
 		default:
-			buf[0] = '\0';
-		}
-
-		if (how != JP_SHORT) {
-			if (p == j->proc_list)
-				shf_fprintf(shf, "[%d] %c ", j->job, jobchar);
-			else
-				shf_puts(filler, shf);
+			msg = null;
 		}
 
-		if (how == JP_LONG)
-			shf_fprintf(shf, "%5d ", (int)p->pid);
-
 		if (how == JP_SHORT) {
-			if (buf[0]) {
-				output = 1;
+			if (msg[0]) {
+				output = true;
+				shf_puts(msg, shf);
 #ifdef WCOREDUMP
-				shf_fprintf(shf, "%s%s ",
-				    buf, coredumped ? " (core dumped)" : null);
-#else
-				shf_puts(buf, shf);
-				shf_putchar(' ', shf);
+				if (coredumped)
+					shf_puts(" (core dumped)", shf);
 #endif
+				shf_putc(' ', shf);
 			}
 		} else {
-			output = 1;
-			shf_fprintf(shf, "%-20s %s%s%s", buf, p->command,
-			    p->next ? "|" : null,
+			/* JP_MEDIUM or JP_LONG */
+			if (p == j->proc_list)
+				shf_fprintf(shf, "[%d] %c ", j->job, jobchar);
+			else
+				shf_puts(filler, shf);
+			if (how == JP_LONG)
+				shf_fprintf(shf, "%5d ", (int)p->pid);
+			output = true;
+			shf_fprintf(shf, "%-20s %s", msg, p->command);
+			if (p->next) {
+				shf_putc(' ', shf);
+				shf_putc('|', shf);
+			}
 #ifdef WCOREDUMP
-			    coredumped ? " (core dumped)" :
+			if (coredumped)
+				shf_puts(" (core dumped)", shf);
 #endif
-			     null);
 		}
 
 		state = p->state;
 		status = p->status;
 		p = p->next;
 		while (p && p->state == state && p->status == status) {
-			if (how == JP_LONG)
-				shf_fprintf(shf, "%s%5d %-20s %s%s", filler,
-				    (int)p->pid, T1space, p->command,
-				    p->next ? "|" : null);
-			else if (how == JP_MEDIUM)
-				shf_fprintf(shf, Tf__ss, p->command,
-				    p->next ? "|" : null);
+			switch (how) {
+			case JP_LONG:
+				shf_puts(filler, shf);
+				shf_fprintf(shf, "%5d %-20s",
+				    (int)p->pid, T1space);
+				/* FALLTHROUGH */
+			case JP_MEDIUM:
+				shf_putc(' ', shf);
+				shf_puts(p->command, shf);
+				if (p->next) {
+					shf_putc(' ', shf);
+					shf_putc('|', shf);
+				}
+				break;
+			}
 			p = p->next;
 		}
 	}
@@ -1727,7 +1748,7 @@ j_lookup(const char *cp, int *ecodep)
 		last_match = NULL;
 		for (j = job_list; j != NULL; j = j->next)
 			for (p = j->proc_list; p != NULL; p = p->next)
-				if (strstr(p->command, cp+1) != NULL) {
+				if (vstrstr(p->command, cp + 1)) {
 					if (last_match) {
 						if (ecodep)
 							*ecodep = JL_AMBIG;
@@ -1931,19 +1952,19 @@ tty_init_talking(void)
 		break;
 	case 1:
 #ifndef MKSH_DISABLE_TTY_WARNING
-		warningf(false, Tf_sD_s_sD_s,
-		    "No controlling tty", Topen, T_devtty, cstrerror(errno));
+		warningf(false, "can't find controlling tty: %s",
+		    cstrerror(errno));
 #endif
 		break;
 	case 2:
 #ifndef MKSH_DISABLE_TTY_WARNING
-		warningf(false, Tf_s_sD_s, Tcant_find, Ttty_fd,
+		warningf(false, "can't find tty fd: %s",
 		    cstrerror(errno));
 #endif
 		break;
 	case 3:
 		warningf(false, Tf_ssfaileds, "j_ttyinit",
-		    Ttty_fd_dupof, cstrerror(errno));
+		    "dup of tty fd", cstrerror(errno));
 		break;
 	case 4:
 		warningf(false, Tf_sD_sD_s, "j_ttyinit",
@@ -1960,3 +1981,17 @@ tty_init_state(void)
 		tty_hasstate = true;
 	}
 }
+
+static void
+vistree(char *dst, size_t sz, struct op *t)
+{
+	char buf[PROC_TGTSZ - 12];
+	struct shf shf;
+
+	snptreef(buf, sizeof(buf), Tf_T, t);
+	shf_sopen(dst, sz, SHF_WR, &shf);
+	uprntmbs(buf, false, &shf);
+	while ((char *)shf.wp > dst && ctype(shf.wp[-1], C_IFSWS))
+		--shf.wp;
+	shf_sclose(&shf);
+}
--- mksh-59c.orig/lalloc.c
+++ mksh-59c/lalloc.c
@@ -23,7 +23,7 @@
 #include <err.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.26 2016/02/26 21:53:36 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lalloc.c,v 1.28 2021/10/10 20:41:17 tg Exp $");
 
 /* build with CPPFLAGS+= -DUSE_REALLOC_MALLOC=0 on ancient systems */
 #if defined(USE_REALLOC_MALLOC) && (USE_REALLOC_MALLOC == 0)
@@ -32,7 +32,6 @@ __RCSID("$MirOS: src/bin/mksh/lalloc.c,v
 #define remalloc(p,n)	realloc_osi((p), (n))
 #endif
 
-
 static struct lalloc_common *findptr(struct lalloc_common **, char *, Area *);
 
 #ifndef MKSH_ALLOC_CATCH_UNDERRUNS
@@ -158,6 +157,7 @@ aresize(void *ptr, size_t numb, Area *ap
 	    )
 		internal_errorf(Toomem, numb);
 	/* area pointer and items share struct lalloc_common */
+	/*XXX C99 §6.5(6) and footnote 72 may dislike this? */
 	lp->next = ap->next;
 	ap->next = lp;
 	/* return user item address */
--- mksh-59c.orig/lex.c
+++ mksh-59c/lex.c
@@ -2,7 +2,8 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
+ *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
+ *		 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +24,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.251 2020/03/10 23:48:40 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/lex.c,v 1.261 2021/10/10 21:36:53 tg Exp $");
 
 /*
  * states while lexing word
@@ -76,9 +77,9 @@ typedef struct lex_state {
 	/* count open parentheses */
 	short nparen;
 	/* type of this state */
-	uint8_t type;
+	kby type;
 	/* extra flags */
-	uint8_t ls_flags;
+	kby ls_flags;
 } Lex_state;
 #define ls_base		u.base
 #define ls_start	u.start
@@ -152,7 +153,7 @@ getsc_r(int c)
 #define STATE_BSIZE	8
 
 #define PUSH_STATE(s)	do {					\
-	uint8_t state_flags = statep->ls_flags;			\
+	kby state_flags = statep->ls_flags;			\
 	if (++statep == state_info.end)				\
 		statep = push_state_i(&state_info, statep);	\
 	state = statep->type = (s);				\
@@ -552,7 +553,7 @@ yylex(int cf)
 				 * "…`…\"…`…" because, unlike for COMSUBs, the
 				 * outer double quoteing changes the backslash
 				 * meaning for the inside. For more details:
-				 * http://austingroupbugs.net/view.php?id=1015
+				 * https://www.austingroupbugs.net/view.php?id=1015
 				 */
 				statep->ls_bool = false;
 				s2 = statep;
@@ -596,7 +597,7 @@ yylex(int cf)
 				if (c2 == 0)
 					statep->ls_bool = true;
 				if (!statep->ls_bool) {
-					char ts[4];
+					char ts[5];
 
 					if ((unsigned int)c2 < 0x100) {
 						*wp++ = QCHAR;
@@ -1380,14 +1381,8 @@ getsc_line(Source *s)
 	    Flag(FVI) ||
 #endif
 	    Flag(FEMACS) || Flag(FGMACS))) {
-		int nread;
-
-		nread = x_read(xp);
-		if (nread < 0)
-			/* read error */
-			nread = 0;
-		xp[nread] = '\0';
-		xp += nread;
+		xp = x_read(xp);
+		*xp = '\0';
 	} else
 #endif
 	  {
@@ -1470,7 +1465,7 @@ getsc_line(Source *s)
 void
 set_prompt(int to, Source *s)
 {
-	cur_prompt = (uint8_t)to;
+	cur_prompt = (kby)to;
 
 	switch (to) {
 	/* command */
@@ -1482,26 +1477,29 @@ set_prompt(int to, Source *s)
 		 * substitutions, POSIX doesn't say which is to be done.
 		 */
 		{
+			char ch;
 			struct shf *shf;
 			char * volatile ps1;
 			Area *saved_atemp;
 			int saved_lineno;
 
+			saved_atemp = ATEMP;
+			newenv(E_ERRH);
 			ps1 = str_val(global("PS1"));
 			shf = shf_sopen(NULL, strlen(ps1) * 2,
 			    SHF_WR | SHF_DYNAMIC, NULL);
-			while (*ps1)
-				if (*ps1 != '!' || *++ps1 == '!')
-					shf_putchar(*ps1++, shf);
-				else
+			while ((ch = *ps1++))
+				if (ch != '!' || *ps1++ == '!')
+					shf_putc(ch, shf);
+				else {
+					--ps1;
 					shf_fprintf(shf, Tf_lu, s ?
 					    (unsigned long)s->line + 1 : 0UL);
+				}
 			ps1 = shf_sclose(shf);
 			saved_lineno = current_lineno;
 			if (s)
 				current_lineno = s->line + 1;
-			saved_atemp = ATEMP;
-			newenv(E_ERRH);
 			if (kshsetjmp(e->jbuf)) {
 				prompt = safe_prompt;
 				/*
@@ -1516,6 +1514,7 @@ set_prompt(int to, Source *s)
 				strdupx(prompt, cp, saved_atemp);
 			}
 			current_lineno = saved_lineno;
+			/* frees everything in post-newenv ATEMP */
 			quitenv(NULL);
 		}
 		break;
@@ -1545,7 +1544,7 @@ pprompt(const char *cp, int ntruncate)
 		delimiter = *cp;
 		cp += 2;
 	}
-	for (; *cp; cp++) {
+	while (*cp) {
 		if (indelimit && *cp != delimiter)
 			;
 		else if (ctype(*cp, C_CR | C_LF)) {
@@ -1560,17 +1559,19 @@ pprompt(const char *cp, int ntruncate)
 			indelimit = !indelimit;
 		else if (UTFMODE && (rtt2asc(*cp) > 0x7F)) {
 			const char *cp2;
+
 			columns += utf_widthadj(cp, &cp2);
 			if (doprint && (indelimit ||
 			    (ntruncate < (x_cols * lines + columns))))
 				shf_write(cp, cp2 - cp, shl_out);
-			cp = cp2 - /* loop increment */ 1;
+			cp = cp2;
 			continue;
 		} else
 			columns++;
 		if (doprint && (*cp != delimiter) &&
 		    (indelimit || (ntruncate < (x_cols * lines + columns))))
 			shf_putc(*cp, shl_out);
+		++cp;
 	}
 	if (doprint)
 		shf_flush(shl_out);
@@ -1600,10 +1601,8 @@ get_brace_var(XString *wsp, char *wp)
 
 				c2 = getsc();
 				ungetsc(c2);
-				if (ord(c2) != ORD(/*{*/ '}')) {
-					ungetsc(c);
+				if (ord(c2) != ORD(/*{*/ '}'))
 					goto out;
-				}
 			}
 			goto ps_common;
 		case PS_SAW_BANG:
@@ -1742,7 +1741,6 @@ ungetsc_i(int c)
 	}
 }
 
-
 /* Called to get a char that isn't a \newline sequence. */
 static int
 getsc_bn(void)
@@ -1772,29 +1770,6 @@ getsc_bn(void)
 	}
 }
 
-void
-yyskiputf8bom(void)
-{
-	int c;
-
-	if (rtt2asc((c = o_getsc_u())) != 0xEF) {
-		ungetsc_i(c);
-		return;
-	}
-	if (rtt2asc((c = o_getsc_u())) != 0xBB) {
-		ungetsc_i(c);
-		ungetsc_i(asc2rtt(0xEF));
-		return;
-	}
-	if (rtt2asc((c = o_getsc_u())) != 0xBF) {
-		ungetsc_i(c);
-		ungetsc_i(asc2rtt(0xBB));
-		ungetsc_i(asc2rtt(0xEF));
-		return;
-	}
-	UTFMODE |= 8;
-}
-
 static Lex_state *
 push_state_i(State_info *si, Lex_state *old_end)
 {
--- mksh-59c.orig/lksh.1
+++ mksh-59c/lksh.1
@@ -1,4 +1,4 @@
-.\" $MirOS: src/bin/mksh/lksh.1,v 1.26 2020/09/04 22:37:01 tg Exp $
+.\" $MirOS: src/bin/mksh/lksh.1,v 1.28 2021/06/15 13:20:05 tg Exp $
 .\"-
 .\" Copyright (c) 2008, 2009, 2010, 2012, 2013, 2015, 2016, 2017, 2018
 .\"	mirabilos <m@mirbsd.org>
@@ -81,7 +81,7 @@
 .\" with -mandoc, it might implement .Mx itself, but we want to
 .\" use our own definition. And .Dd must come *first*, always.
 .\"
-.Dd $Mdocdate: September 4 2020 $
+.Dd $Mdocdate: June 15 2021 $
 .\"
 .\" Check which macro package we use, and do other -mdoc setup.
 .\"
@@ -346,16 +346,12 @@ Talk to the
 .Mx
 development team and users using the mailing list at
 .Aq Mt miros\-mksh@mirbsd.org
-(please note the EU-DSGVO/GDPR notice on
-.Pa http://www.mirbsd.org/rss.htm#lists
-and in the SMTP banner!) or the
+or in the
 .Li \&#\&!/bin/mksh
-.Pq or Li \&#ksh
-IRC channel at
-.Pa irc.freenode.net
-.Pq Port 6697 SSL, 6667 unencrypted
-if you need any further quirks or assistance,
-and consider migrating your legacy scripts to work with
+IRC channel; mind the infos from
+.Pa http://www.mirbsd.org/mksh\-faq.htm#contact
+for either.
+Consider migrating your legacy scripts to work with
 .Nm mksh
 instead of requiring
 .Nm .
--- mksh-59c.orig/main.c
+++ mksh-59c/main.c
@@ -6,7 +6,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
- *		 2019, 2020
+ *		 2019, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -35,7 +35,7 @@
 #include <locale.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/main.c,v 1.374 2020/10/01 20:28:54 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/main.c,v 1.398 2021/10/12 23:18:13 tg Exp $");
 
 #ifndef MKSHRC_PATH
 #define MKSHRC_PATH	"~/.mkshrc"
@@ -45,7 +45,16 @@ __RCSID("$MirOS: src/bin/mksh/main.c,v 1
 #define MKSH_DEFAULT_TMPDIR	MKSH_UNIXROOT "/tmp"
 #endif
 
-static uint8_t isuc(const char *);
+#if !HAVE_SETLOCALE_CTYPE
+/* this is the “implementation-defined default locale” */
+#ifdef MKSH_DEFAULT_UTFLOC
+#define MKSH_DEFAULT_LOCALE	"UTF-8"
+#else
+#define MKSH_DEFAULT_LOCALE	"C"
+#endif
+#endif
+
+static kby isuc(const char *);
 static int main_init(int, const char *[], Source **, struct block **);
 void chvt_reinit(void);
 static void reclaim(void);
@@ -84,15 +93,17 @@ static const char *initcoms[] = {
 	NULL,
 	 /* this is what AT&T ksh seems to track, with the addition of emacs */
 	Talias, "-tU",
-	Tcat, "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
+	"cat", "cc", "chmod", "cp", "date", "ed", "emacs", "grep", "ls",
 	"make", "mv", "pr", "rm", "sed", Tsh, "vi", "who", NULL,
 	NULL
 };
 
 static const char *restr_com[] = {
-	Ttypeset, Tdr, TPATH, TENV, TSHELL, NULL
+	Ttypeset, Tdr, TENV, "HISTFILE", TPATH, TSHELL, NULL
 };
 
+extern const char Tpipest[];
+
 static bool initio_done;
 
 /* top-level parsing and execution environment */
@@ -197,10 +208,10 @@ static const char *empty_argv[] = {
 	Tmksh, NULL
 };
 
-static uint8_t
+static kby
 isuc(const char *cx) {
 	char *cp, *x;
-	uint8_t rv = 0;
+	kby rv = 0;
 
 	if (!cx || !*cx)
 		return (0);
@@ -212,7 +223,7 @@ isuc(const char *cx) {
 		++cp;
 
 	/* check for UTF-8 */
-	if (strstr(x, "UTF-8") || strstr(x, "UTF8"))
+	if (vstrstr(x, "UTF-8") || vstrstr(x, "UTF8"))
 		rv = 1;
 
 	/* free copy and out */
@@ -236,6 +247,7 @@ main_init(int argc, const char *argv[],
 #endif
 
 #if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
+	/* this must come *really* early due to locale use */
 	ebcdic_init();
 #endif
 	set_ifs(TC_IFSWS);
@@ -306,7 +318,7 @@ main_init(int argc, const char *argv[],
 
 	/* define built-in commands and see if we were called as one */
 	ktinit(APERM, &builtins,
-	    /* currently up to 52 builtins: 75% of 128 = 2^7 */
+	    /* currently up to 50 builtins: 75% of 128 = 2^7 */
 	    7);
 	for (i = 0; mkshbuiltins[i].name != NULL; ++i) {
 		const char *builtin_name;
@@ -393,7 +405,8 @@ main_init(int argc, const char *argv[],
 
 	/*
 	 * Set PATH to def_path (will set the path global variable).
-	 * (import of environment below will probably change this setting).
+	 * Import of environment below will probably change this setting;
+	 * the EXPORT flag is only added via initcoms for this to work.
 	 */
 	vp = global(TPATH);
 	/* setstr can't fail here */
@@ -449,7 +462,7 @@ main_init(int argc, const char *argv[],
 	vp = global("PS1");
 	/* Set PS1 if unset or we are root and prompt doesn't contain a # */
 	if (!(vp->flag & ISSET) ||
-	    (!ksheuid && !strchr(str_val(vp), '#')))
+	    (!ksheuid && !vstrchr(str_val(vp), '#')))
 		/* setstr can't fail here */
 		setstr(vp, safe_prompt, KSH_RETURN_ERROR);
 	setint_n((vp = global("BASHPID")), 0, 10);
@@ -468,7 +481,7 @@ main_init(int argc, const char *argv[],
 	vp->flag |= INT_U;
 	setint_n((vp = global("RANDOM")), rndsetup(), 10);
 	vp->flag |= INT_U;
-	setint_n((vp_pipest = global("PIPESTATUS")), 0, 10);
+	setint_n((vp_pipest = global(Tpipest)), 0, 10);
 
 	/* Set this before parsing arguments */
 	Flag(FPRIVILEGED) = (kshuid != ksheuid || kshgid != kshegid) ? 2 : 0;
@@ -478,6 +491,8 @@ main_init(int argc, const char *argv[],
 	Flag(FMONITOR) = 127;
 #endif
 	/* this to note if utf-8 mode is set on command line (see below) */
+/*XXX this and the below can probably go away */
+/*XXX UTFMODE should be set from env here if locale tracking, just keep it */
 	UTFMODE = 2;
 
 	if (!as_builtin) {
@@ -486,6 +501,7 @@ main_init(int argc, const char *argv[],
 			return (1);
 	}
 
+/*XXX drop this and the entire cases below */
 	/* process this later only, default to off (hysterical raisins) */
 	utf_flag = UTFMODE;
 	UTFMODE = 0;
@@ -496,7 +512,7 @@ main_init(int argc, const char *argv[],
 	} else if (Flag(FCOMMAND)) {
 		s = pushs(SSTRINGCMDLINE, ATEMP);
 		if (!(s->start = s->str = argv[argi++]))
-			errorf(Tf_optfoo, "", "", 'c', Treq_arg);
+			errorf(Tf_optdcs, 'c', Treq_arg);
 		while (*s->str) {
 			if (ctype(*s->str, C_QUOTE))
 				break;
@@ -607,12 +623,18 @@ main_init(int argc, const char *argv[],
 		getopts_reset(1);
 	}
 
+/*XXX to go away entirely with locale tracking */
 	/* divine the initial state of the utf8-mode Flag */
 	ccp = null;
 	switch (utf_flag) {
 
+#ifdef MKSH_EARLY_LOCALE_TRACKING
+	/* not set on command line, not FTALKING */
+	case 2:
+#endif
 	/* auto-detect from locale or environment */
 	case 4:
+#ifndef MKSH_EARLY_LOCALE_TRACKING
 #if HAVE_SETLOCALE_CTYPE
 		ccp = setlocale(LC_CTYPE, "");
 #if HAVE_LANGINFO_CODESET
@@ -622,10 +644,12 @@ main_init(int argc, const char *argv[],
 		if (!isuc(ccp))
 			ccp = null;
 #endif
+#endif
 		/* FALLTHROUGH */
 
 	/* auto-detect from environment */
 	case 3:
+#ifndef MKSH_EARLY_LOCALE_TRACKING
 		/* these were imported from environ earlier */
 		if (ccp == null)
 			ccp = str_val(global("LC_ALL"));
@@ -634,10 +658,15 @@ main_init(int argc, const char *argv[],
 		if (ccp == null)
 			ccp = str_val(global("LANG"));
 		UTFMODE = isuc(ccp);
+#else
+		recheck_ctype(); /*XXX probably unnecessary here */
+#endif
 		break;
 
+#ifndef MKSH_EARLY_LOCALE_TRACKING
 	/* not set on command line, not FTALKING */
 	case 2:
+#endif
 	/* unknown values */
 	default:
 		utf_flag = 0;
@@ -738,6 +767,9 @@ main(int argc, const char *argv[])
 	if ((rv = main_init(argc, argv, &s, &l)) == 0) {
 		if (as_builtin) {
 			rv = c_builtin(l->argv);
+			exstat = rv & 0xFF;
+			unwind(LEXIT);
+			/* NOTREACHED */
 		} else {
 			shell(s, 0);
 			/* NOTREACHED */
@@ -837,9 +869,8 @@ shell(Source * volatile s, volatile int
 {
 	struct op *t;
 	volatile bool wastty = tobool(s->flags & SF_TTY);
-	volatile uint8_t attempts = 13;
+	volatile kby attempts = 13;
 	volatile bool interactive = (level == 0) && Flag(FTALKING);
-	volatile bool sfirst = true;
 	Source *volatile old_source = source;
 	int i;
 
@@ -923,10 +954,9 @@ shell(Source * volatile s, volatile int
 			j_notify();
 			set_prompt(PS1, s);
 		}
-		t = compile(s, sfirst, true);
+		t = compile(s, true);
 		if (interactive)
 			histsave(&s->line, NULL, HIST_FLUSH, true);
-		sfirst = false;
 		if (!t)
 			goto source_no_tree;
 		if (t->type == TEOF) {
@@ -1026,7 +1056,7 @@ newenv(int type)
 	ainit(&ep->area);
 	ep->oenv = e;
 	ep->loc = e->loc;
-	ep->savefd = NULL;
+	ep->savedfd = NULL;
 	ep->temps = NULL;
 	ep->yyrecursive_statep = NULL;
 	ep->type = type;
@@ -1039,17 +1069,16 @@ quitenv(struct shf *shf)
 {
 	struct env *ep = e;
 	char *cp;
-	int fd;
+	int fd, i;
 
 	yyrecursive_pop(true);
 	while (ep->oenv && ep->oenv->loc != ep->loc)
 		popblock();
-	if (ep->savefd != NULL) {
+	if (ep->savedfd != NULL) {
 		for (fd = 0; fd < NUFILE; fd++)
-			/* if ep->savefd[fd] < 0, means fd was closed */
-			if (ep->savefd[fd])
-				restfd(fd, ep->savefd[fd]);
-		if (ep->savefd[2])
+			if ((i = SAVEDFD(ep, fd)))
+				restfd(fd, i);
+		if (SAVEDFD(ep, 2))
 			/* Clear any write errors */
 			shf_reopen(2, SHF_WR, shl_out);
 	}
@@ -1058,10 +1087,6 @@ quitenv(struct shf *shf)
 	 * Either main shell is exiting or cleanup_parents_env() was called.
 	 */
 	if (ep->oenv == NULL) {
-#ifdef DEBUG_LEAKS
-		int i;
-#endif
-
 		if (ep->type == E_NONE) {
 			/* Main shell exiting? */
 #if HAVE_PERSISTENT_HISTORY
@@ -1132,14 +1157,14 @@ cleanup_parents_env(void)
 	 * anywhere.
 	 */
 
-	/* close all file descriptors hiding in savefd */
+	/* close all file descriptors hiding in savedfd */
 	for (ep = e; ep; ep = ep->oenv) {
-		if (ep->savefd) {
+		if (ep->savedfd) {
 			for (fd = 0; fd < NUFILE; fd++)
-				if (ep->savefd[fd] > 0)
-					close(ep->savefd[fd]);
-			afree(ep->savefd, &ep->area);
-			ep->savefd = NULL;
+				if (FDSVNUM(ep, fd) > (kui)FDBASE)
+					close((int)FDSVNUM(ep, fd));
+			afree(ep->savedfd, &ep->area);
+			ep->savedfd = NULL;
 		}
 #ifdef DEBUG_LEAKS
 		if (ep->type != E_NONE)
@@ -1291,7 +1316,7 @@ vwarningf(unsigned int flags, const char
 		    builtin_argv0 && builtin_argv0 != kshname)
 			shf_fprintf(shl_out, Tf_sD_, builtin_argv0);
 		shf_vfprintf(shl_out, fmt, ap);
-		shf_putchar('\n', shl_out);
+		shf_putc('\n', shl_out);
 	}
 	shf_flush(shl_out);
 }
@@ -1406,6 +1431,10 @@ internal_errorf(const char *fmt, ...)
 {
 	va_list va;
 
+	exstat = 0xFF;
+	if (trap_exstat != -1)
+		trap_exstat = exstat;
+
 	va_start(va, fmt);
 	vwarningf(VWARNINGF_INTERNAL, fmt, va);
 	va_end(va);
@@ -1527,7 +1556,7 @@ ksh_dup2(int ofd, int nfd, bool errok)
 	int rv;
 
 	if (((rv = dup2(ofd, nfd)) < 0) && !errok && (errno != EBADF))
-		errorf(Ttoo_many_files);
+		errorf(Ttoo_many_files, ofd, nfd, cstrerror(errno));
 
 #ifdef __ultrix
 	/*XXX imake style */
@@ -1539,21 +1568,24 @@ ksh_dup2(int ofd, int nfd, bool errok)
 }
 
 /*
- * Move fd from user space (0 <= fd < 10) to shell space (fd >= 10),
- * set close-on-exec flag. See FDBASE in sh.h, maybe 24 not 10 here.
+ * Move fd from user space (0 <= fd < FDBASE) to shell space (fd >= FDBASE)
+ * set moved fd’s close-on-exec flag (see sh.h for FDBASE).
  */
-short
+int
 savefd(int fd)
 {
 	int nfd = fd;
 
+	errno = 0;
 	if (fd < FDBASE && (nfd = fcntl(fd, F_DUPFD, FDBASE)) < 0 &&
 	    (errno == EBADF || errno == EPERM))
 		return (-1);
-	if (nfd < 0 || nfd > SHRT_MAX)
-		errorf(Ttoo_many_files);
-	fcntl(nfd, F_SETFD, FD_CLOEXEC);
-	return ((short)nfd);
+	if (nfd < FDBASE || nfd > (int)(kui)FDMAXNUM)
+		errorf(Ttoo_many_files, fd, nfd, cstrerror(errno));
+	if (fcntl(nfd, F_SETFD, FD_CLOEXEC) == -1)
+		internal_warningf(Tcloexec_failed, "set", nfd,
+		    cstrerror(errno));
+	return (nfd);
 }
 
 void
@@ -1755,7 +1787,7 @@ maketemp(Area *ap, Temp_type type, struc
 	cp += offsetof(struct temp, tffn[0]);
 	memcpy(cp, dir, len);
 	cp += len;
-	memcpy(cp, "/shXXXXXX.tmp", 14);
+	memstr(cp, "/shXXXXXX.tmp");
 	/* point to the first of six Xes */
 	cp += 3;
 
@@ -1856,7 +1888,7 @@ tgrow(struct table *tp)
 }
 
 void
-ktinit(Area *ap, struct table *tp, uint8_t initshift)
+ktinit(Area *ap, struct table *tp, kby initshift)
 {
 	tp->areap = ap;
 	tp->tbls = NULL;
@@ -1997,8 +2029,8 @@ DF(const char *fmt, ...)
 	mksh_TIME(tv);
 	timet2mjd(&mjd, tv.tv_sec);
 	shf_fprintf(shl_dbg, "[%02u:%02u:%02u (%u) %u.%06u] ",
-	    (unsigned)mjd.sec / 3600, ((unsigned)mjd.sec / 60) % 60,
-	    (unsigned)mjd.sec % 60, (unsigned)getpid(),
+	    (unsigned)mjd.sec / 3600U, ((unsigned)mjd.sec / 60U) % 60U,
+	    (unsigned)mjd.sec % 60U, (unsigned)getpid(),
 	    (unsigned)tv.tv_sec, (unsigned)tv.tv_usec);
 	va_start(args, fmt);
 	shf_vfprintf(shl_dbg, fmt, args);
@@ -2018,22 +2050,24 @@ x_mkraw(int fd, mksh_ttyst *ocb, bool fo
 		mksh_tcget(fd, ocb);
 	else
 		ocb = &tty_state;
+#ifdef FLUSHO
+	ocb->c_lflag &= ~(FLUSHO);
+#endif
 
 	cb = *ocb;
-	if (forread) {
-		cb.c_iflag &= ~(ISTRIP);
-		cb.c_lflag &= ~(ICANON) | ECHO;
-	} else {
-		cb.c_iflag &= ~(INLCR | ICRNL | ISTRIP);
+	cb.c_iflag &= ~(IGNPAR | PARMRK | INLCR | IGNCR | ICRNL | ISTRIP);
+	cb.c_iflag |= BRKINT;
+	if (forread)
+		cb.c_lflag &= ~(ICANON);
+	else
 		cb.c_lflag &= ~(ISIG | ICANON | ECHO);
-	}
-#if defined(VLNEXT) && defined(_POSIX_VDISABLE)
+#if defined(VLNEXT)
 	/* OSF/1 processes lnext when ~icanon */
-	cb.c_cc[VLNEXT] = _POSIX_VDISABLE;
+	KSH_DOVDIS(cb.c_cc[VLNEXT]);
 #endif
 	/* SunOS 4.1.x and OSF/1 process discard(flush) when ~icanon */
-#if defined(VDISCARD) && defined(_POSIX_VDISABLE)
-	cb.c_cc[VDISCARD] = _POSIX_VDISABLE;
+#if defined(VDISCARD)
+	KSH_DOVDIS(cb.c_cc[VDISCARD]);
 #endif
 	cb.c_cc[VTIME] = 0;
 	cb.c_cc[VMIN] = 1;
@@ -2042,6 +2076,9 @@ x_mkraw(int fd, mksh_ttyst *ocb, bool fo
 }
 
 #ifdef MKSH_ENVDIR
+#if HAVE_SETLOCALE_CTYPE
+# error MKSH_ENVDIR has not been adapted to work with POSIX locale!
+#else
 static void
 init_environ(void)
 {
@@ -2080,7 +2117,7 @@ init_environ(void)
 			while ((n = shf_read(xp, Xnleft(xs, xp), shf)) > 0) {
 				xp += n;
 				if (Xnleft(xs, xp) <= 0)
-					XcheckN(xs, xp, Xlength(xs, xp));
+					XcheckN(xs, xp, 128);
 			}
 			if (n < 0) {
 				warningf(false,
@@ -2102,6 +2139,7 @@ init_environ(void)
 	closedir(dirp);
 	Xfree(xs, xp);
 }
+#endif
 #else
 extern char **environ;
 
@@ -2117,7 +2155,23 @@ init_environ(void)
 	while (*wp != NULL) {
 		rndpush(*wp);
 		typeset(*wp, IMPORT | EXPORT, 0, 0, 0);
+#ifdef MKSH_EARLY_LOCALE_TRACKING
+		if (ord((*wp)[0]) == ORD('L') && (
+		    (ord((*wp)[1]) == ORD('C') && ord((*wp)[2]) == ORD('_')) ||
+		    !strcmp(*wp, "LANG"))) {
+			const char **P;
+
+			/* remove LC_* / LANG from own environment */
+			P = wp;
+			while ((*P = *(P + 1)))
+				++P;
+			/* now setlocale with "" will use the default locale */
+			/* matching the user expectation wrt passed-in vars */
+		} else
+			++wp;
+#else
 		++wp;
+#endif
 	}
 }
 #endif
@@ -2127,25 +2181,50 @@ void
 recheck_ctype(void)
 {
 	const char *ccp;
-	uint8_t old_utfmode = UTFMODE;
 
+	/*XXX OSX has LC_CTYPE=UTF-8 */
 	ccp = str_val(global("LC_ALL"));
 	if (ccp == null)
 		ccp = str_val(global("LC_CTYPE"));
 	if (ccp == null)
 		ccp = str_val(global("LANG"));
+#if !HAVE_SETLOCALE_CTYPE
+	/*XXX == null? this :- or - ? */
+	if (ccp == null)
+		ccp = MKSH_DEFAULT_LOCALE;
+#endif
+/*XXX check either the parameters directly or setlocale, not both */
 	UTFMODE = isuc(ccp);
 #if HAVE_SETLOCALE_CTYPE
 	ccp = setlocale(LC_CTYPE, ccp);
 #if HAVE_LANGINFO_CODESET
+/*XXX setlocale without nl_langinfo(CODESET) makes no sense for us */
 	if (!isuc(ccp))
 		ccp = nl_langinfo(CODESET);
 #endif
 	if (isuc(ccp))
 		UTFMODE = 1;
 #endif
+}
+#endif
 
-	if (Flag(FPOSIX) && UTFMODE && !old_utfmode)
-		warningf(true, "early locale tracking enabled UTF-8 mode while in POSIX mode, you are now noncompliant");
+#if !HAVE_MEMMOVE
+void *
+rpl_memmove(void *dst, const void *src, size_t len)
+{
+	const unsigned char *s = src;
+	unsigned char *d = dst;
+
+	if (len) {
+		if (src < dst) {
+			s += len;
+			d += len;
+			while (len--)
+				*--d = *--s;
+		} else
+			while (len--)
+				*d++ = *s++;
+	}
+	return (dst);
 }
 #endif
--- mksh-59c.orig/mirhash.h
+++ mksh-59c/mirhash.h
@@ -1,5 +1,5 @@
 /*-
- * Copyright © 2011, 2014, 2015
+ * Copyright © 2011, 2014, 2015, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -35,7 +35,7 @@
  *	We are looking into it. Changing the core
  *	hash function in PHP isn't a trivial change
  *	and will take us some time.
- * -- Rasmus Lerdorf
+ *		-- Rasmus Lerdorf
  */
 
 #ifndef SYSKERN_MIRHASH_H
@@ -44,7 +44,7 @@
 
 #include <sys/types.h>
 
-__RCSID("$MirOS: src/bin/mksh/mirhash.h,v 1.6 2015/11/29 17:05:02 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/mirhash.h,v 1.9 2021/07/31 19:56:33 tg Exp $");
 
 /*-
  * BAFH itself is defined by the following primitives:
@@ -61,7 +61,7 @@ __RCSID("$MirOS: src/bin/mksh/mirhash.h,
  *   the context is (still) zero, adding a NUL byte is not ignored.
  *
  * • BAFHror(eax,cl) evaluates to the unsigned 32-bit integer “eax”,
- *   rotated right by “cl” ∈ [0; 31] (no casting, be careful!) where
+ *   rotated right by “cl” ∈ [1; 31] (no casting, be careful!) where
  *   “eax” must be uint32_t and “cl” an in-range integer.
  *
  * • BAFHFinish(ctx) avalanches the context around so every sub-byte
@@ -83,16 +83,12 @@ __RCSID("$MirOS: src/bin/mksh/mirhash.h,
  *
  * • BAFHUpdateMem(ctx,buf,len) adds a memory block to a context.
  * • BAFHUpdateStr(ctx,buf) is equivalent to using len=strlen(buf).
- * • BAFHHostMem(ctx,buf,len) calculates the hash of the memory buf‐
- *   fer using the first 4 octets (mixed) for IV, as outlined above;
- *   the result is endian-dependent; “ctx” assumed to be a register.
- * • BAFHHostStr(ctx,buf) does the same for C strings.
  *
  * All macros may use ctx multiple times in their expansion, but all
  * other arguments are always evaluated at most once except BAFHror.
  *
- * To stay portable, never use the BAFHHost*() macros (these are for
- * host-local entropy shuffling), and encode numbers using ULEB128.
+ * To stay portable, encode numbers using ULEB128, or better and for
+ * sortability, VLQ (same unsigned but big endian), normal or Git’s.
  */
 
 #define BAFHInit(h) do {					\
@@ -100,7 +96,7 @@ __RCSID("$MirOS: src/bin/mksh/mirhash.h,
 } while (/* CONSTCOND */ 0)
 
 #define BAFHUpdateOctet_reg(h,b) do {				\
-	(h) += (uint8_t)(b);					\
+	(h) += (unsigned char)(b);				\
 	++(h);							\
 	(h) += (h) << 10;					\
 	(h) ^= (h) >> 6;					\
@@ -144,7 +140,7 @@ __RCSID("$MirOS: src/bin/mksh/mirhash.h,
 } while (/* CONSTCOND */ 0)
 
 #define BAFHUpdateMem_reg(h,p,z) do {				\
-	register const uint8_t *BAFHUpdate_p;			\
+	register const unsigned char *BAFHUpdate_p;		\
 	register size_t BAFHUpdate_z = (z);			\
 								\
 	BAFHUpdate_p = (const void *)(p);			\
@@ -161,8 +157,8 @@ __RCSID("$MirOS: src/bin/mksh/mirhash.h,
 } while (/* CONSTCOND */ 0)
 
 #define BAFHUpdateStr_reg(h,s) do {				\
-	register const uint8_t *BAFHUpdate_s;			\
-	register uint8_t BAFHUpdate_c;				\
+	register const unsigned char *BAFHUpdate_s;		\
+	register unsigned char BAFHUpdate_c;			\
 								\
 	BAFHUpdate_s = (const void *)(s);			\
 	while ((BAFHUpdate_c = *BAFHUpdate_s++) != 0)		\
@@ -176,51 +172,4 @@ __RCSID("$MirOS: src/bin/mksh/mirhash.h,
 	(m) = BAFH_h;						\
 } while (/* CONSTCOND */ 0)
 
-#define BAFHHostMem(h,p,z) do {					\
-	register const uint8_t *BAFHUpdate_p;			\
-	register size_t BAFHUpdate_z = (z);			\
-	size_t BAFHHost_z;					\
-	union {							\
-		uint8_t as_u8[4];				\
-		uint32_t as_u32;				\
-	} BAFHHost_v;						\
-								\
-	BAFHUpdate_p = (const void *)(p);			\
-	BAFHHost_v.as_u32 = 0;					\
-	BAFHHost_z = BAFHUpdate_z < 4 ? BAFHUpdate_z : 4;	\
-	memcpy(BAFHHost_v.as_u8, BAFHUpdate_p, BAFHHost_z);	\
-	BAFHUpdate_p += BAFHHost_z;				\
-	BAFHUpdate_z -= BAFHHost_z;				\
-	(h) = BAFHHost_v.as_u32;				\
-	BAFHFinish_reg(h);					\
-	while (BAFHUpdate_z--)					\
-		BAFHUpdateOctet_reg((h), *BAFHUpdate_p++);	\
-	BAFHFinish_reg(h);					\
-} while (/* CONSTCOND */ 0)
-
-#define BAFHHostStr(h,s) do {					\
-	register const uint8_t *BAFHUpdate_s;			\
-	register uint8_t BAFHUpdate_c;				\
-	union {							\
-		uint8_t as_u8[4];				\
-		uint32_t as_u32;				\
-	} BAFHHost_v;						\
-								\
-	BAFHUpdate_s = (const void *)(s);			\
-	BAFHHost_v.as_u32 = 0;					\
-	if ((BAFHHost_v.as_u8[0] = *BAFHUpdate_s) != 0)		\
-		++BAFHUpdate_s;					\
-	if ((BAFHHost_v.as_u8[1] = *BAFHUpdate_s) != 0)		\
-		++BAFHUpdate_s;					\
-	if ((BAFHHost_v.as_u8[2] = *BAFHUpdate_s) != 0)		\
-		++BAFHUpdate_s;					\
-	if ((BAFHHost_v.as_u8[3] = *BAFHUpdate_s) != 0)		\
-		++BAFHUpdate_s;					\
-	(h) = BAFHHost_v.as_u32;				\
-	BAFHFinish_reg(h);					\
-	while ((BAFHUpdate_c = *BAFHUpdate_s++) != 0)		\
-		BAFHUpdateOctet_reg((h), BAFHUpdate_c);		\
-	BAFHFinish_reg(h);					\
-} while (/* CONSTCOND */ 0)
-
 #endif
--- mksh-59c.orig/misc.c
+++ mksh-59c/misc.c
@@ -4,7 +4,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2019,
- *		 2020
+ *		 2020, 2021
  *	mirabilos <m@mirbsd.org>
  * Copyright (c) 2015
  *	Daniel Richard G. <skunk@iSKUNK.ORG>
@@ -33,7 +33,7 @@
 #include <grp.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.302 2020/08/27 19:52:45 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/misc.c,v 1.330 2021/10/10 20:41:17 tg Exp $");
 
 #define KSH_CHVT_FLAG
 #ifdef MKSH_SMALL
@@ -44,9 +44,6 @@ __RCSID("$MirOS: src/bin/mksh/misc.c,v 1
 #define KSH_CHVT_FLAG
 #endif
 
-/* type bits for unsigned char */
-unsigned char chtypes[UCHAR_MAX + 1];
-
 static const unsigned char *pat_scan(const unsigned char *,
     const unsigned char *, bool) MKSH_A_PURE;
 static int do_gmatch(const unsigned char *, const unsigned char *,
@@ -57,6 +54,12 @@ static const unsigned char *gmatch_cclas
 #ifdef KSH_CHVT_CODE
 static void chvt(const Getopt *);
 #endif
+static unsigned int dollarqU(struct shf *, const unsigned char *);
+#ifndef MKSH_SMALL
+static void dollarq8(struct shf *, const unsigned char *);
+#else
+#define dollarq8 dollarqU
+#endif
 
 /*XXX this should go away */
 static int make_path(const char *, const char *, char **, XString *, int *);
@@ -72,7 +75,6 @@ static int make_path(const char *, const
 #define DO_SETUID(func,argvec) func argvec
 #endif
 
-
 /* called from XcheckN() to grow buffer */
 char *
 Xcheck_grow(XString *xsp, const char *xp, size_t more)
@@ -88,7 +90,6 @@ Xcheck_grow(XString *xsp, const char *xp
 	return (xsp->beg + (xp - old_beg));
 }
 
-
 #define SHFLAGS_DEFNS
 #define FN(sname,cname,flags,ochar)		\
 	static const struct {			\
@@ -292,10 +293,6 @@ change_flag(enum sh_flag f, int what, bo
 
 		/* +++ privs changed +++ */
 	} else if ((f == FPOSIX || f == FSH) && newval) {
-		/* Turning on -o posix? */
-		if (f == FPOSIX)
-			/* C locale required for compliance */
-			UTFMODE = 0;
 		/* Turning on -o posix or -o sh? */
 		Flag(FBRACEEXPAND) = 0;
 #ifndef MKSH_NO_CMDLINE_EDITING
@@ -423,8 +420,7 @@ parse_args(const char **argv,
 				 */
 #if !defined(MKSH_SMALL) || defined(DEBUG)
 				if (!set && !baseline_flags[(int)FNFLAGS]) {
-					bi_errorf(Tf_s_s, "too early",
-					    Tset_po);
+					bi_errorf(Ttooearly, T_set_po);
 					return (-1);
 				}
 #endif
@@ -457,8 +453,7 @@ parse_args(const char **argv,
 			else if (!strcmp(go.optarg, To_reset)) {
 #if !defined(MKSH_SMALL) || defined(DEBUG)
 				if (!baseline_flags[(int)FNFLAGS]) {
-					bi_errorf(Tf_ss, "too early",
-					    To_o_reset);
+					bi_errorf(Ttooearly, To_o_reset);
 					return (-1);
 				}
 #endif
@@ -554,11 +549,25 @@ parse_args(const char **argv,
 int
 getn(const char *s, int *ai)
 {
+	return (getpn(&s, ai) && !*s);
+}
+
+/*
+ * parse a decimal number
+ * on success, returns 1 and *ai contains it and *sp points past it
+ * on overflow, returns 0, *ai is 0, *sp points behind the parsed number
+ * on parse error (not numeric) returns 0, *ai is 0, *sp is not changed
+ */
+int
+getpn(const char **sp, int *ai)
+{
 	char c;
-	mksh_ari_u num;
+	const char *s;
+	mksh_uari_t num = 0;
+	kby state = 0;
 	bool neg = false;
 
-	num.u = 0;
+	s = *sp;
 
 	do {
 		c = *s++;
@@ -573,24 +582,32 @@ getn(const char *s, int *ai)
 		break;
 	}
 
-	do {
-		if (!ctype(c, C_DIGIT))
-			/* not numeric */
-			return (0);
-		if (num.u > 214748364U)
+	while (ctype(c, C_DIGIT)) {
+		if (num > 214748364U)
 			/* overflow on multiplication */
-			return (0);
-		num.u = num.u * 10U + (unsigned int)ksh_numdig(c);
-		/* now: num.u <= 2147483649U */
-	} while ((c = *s++));
+			state = 2;
+		if (state < 2) {
+			state = 1;
+			num = num * 10U + (unsigned int)ksh_numdig(c);
+		}
+		/* now: num <= 2147483649U */
+		c = *s++;
+	}
+	--s;
 
-	if (num.u > (neg ? 2147483648U : 2147483647U))
+	if (num > (neg ? 2147483648U : 2147483647U))
 		/* overflow for signed 32-bit int */
-		return (0);
+		state = 2;
 
-	if (neg)
-		num.u = -num.u;
-	*ai = num.i;
+	if (state)
+		*sp = s;
+	if (state != 1) {
+		*ai = 0;
+		return (0);
+	}
+	*ai = (neg && num > 0) ?
+	    (mksh_ari_t)(-(mksh_ari_t)((num - 1U) & 0x7FFFFFFF) - 1) :
+	    (mksh_ari_t)num;
 	return (1);
 }
 
@@ -602,7 +619,7 @@ getn(const char *s, int *ai)
 static void *
 simplify_gmatch_pattern(const unsigned char *sp)
 {
-	uint8_t c;
+	kby c;
 	unsigned char *cp, *dp;
 	const unsigned char *ps, *se;
 
@@ -870,7 +887,7 @@ do_gmatch(const unsigned char *s, const
 				return (0);
 			if (UTFMODE) {
 				--s;
-				s += utf_ptradj((const void *)s);
+				s += ez_mbtoc(NULL, (const void *)s);
 			}
 			break;
 
@@ -1231,7 +1248,7 @@ pat_scan(const unsigned char *p, const u
 int
 ascstrcmp(const void *s1, const void *s2)
 {
-	const uint8_t *cp1 = s1, *cp2 = s2;
+	const kby *cp1 = s1, *cp2 = s2;
 
 	while (*cp1 == *cp2) {
 		if (*cp1++ == '\0')
@@ -1260,7 +1277,6 @@ ksh_getopt_reset(Getopt *go, int flags)
 	go->buf[1] = '\0';
 }
 
-
 /**
  * getopt() used for shell built-in commands, the getopts command, and
  * command line options.
@@ -1406,117 +1422,249 @@ print_value_quoted(struct shf *shf, cons
 	}
 
 	/* non-empty; check whether any quotes are needed */
-	while (rtt2asc(c = *p++) >= 32)
-		if (ctype(c, C_QUOTE | C_SPC))
-			inquote = false;
+	if (UTFMODE) {
+		/* C1 always escaped; multibyte makes this tricky */
+		while ((c = *p++) != 0) {
+			if (ctype(c, C_CNTRL)) {
+				dollarqU(shf, (const unsigned char *)s);
+				return;
+			}
+			/* anything out of ASCII present? */
+			if (rtt2asc(c) > 0x7EU) {
+				/* dollar-quote, but be prepared to redo */
+				char *guess;
+				struct shf to;
+
+				shf_sopen(NULL, 0, SHF_WR | SHF_DYNAMIC, &to);
+				c = dollarqU(&to, (const unsigned char *)s);
+				guess = shf_sclose(&to);
+				/* output guess if it was right */
+				if (c > 1)
+					shf_puts(guess, shf);
+				afree(guess, ATEMP);
+				if (c == 1)
+					goto always_single;
+				if (c == 0)
+ noquoteneeded:
+					shf_puts(s, shf);
+				return;
+			}
+			if (ctype(c, C_QUOTE | C_SPC))
+				inquote = false;
+		}
+		/* assert: c == 0; all chars in [20;7E] ASCII */
+#ifndef MKSH_EBCDIC
+	} else if (Flag(FASIS)) {
+		while ((c = *p++), !ksh_asisctrl(c))
+			if (ctype(c, C_QUOTE | C_SPC))
+				inquote = false;
+#endif
+	} else {
+		while ((c = *p++), !ksh_isctrl(c))
+			if (ctype(c, C_QUOTE | C_SPC))
+				inquote = false;
+	}
+	/* state: if c == 0, all chars printable, inquote shortcuts */
+
+	if (c) {
+		/* otherwise, escape control chars */
+		dollarq8(shf, (const unsigned char *)s);
+		return;
+	}
 
+	/* can we shortcut? */
+	if (inquote)
+		goto noquoteneeded;
+	/* no */
+ always_single:
+	/* all chars printable, no control chars, quote nicely */
+	inquote = false;
 	p = (const unsigned char *)s;
-	if (c == 0) {
-		if (inquote) {
-			/* nope, use the shortcut */
-			shf_puts(s, shf);
-			return;
+
+	while ((c = *p++) != 0) {
+		if (c == '\'') {
+			if (inquote) {
+				shf_scheck(3, shf);
+				shf_putc('\'', shf);
+				inquote = false;
+			}
+			shf_putc('\\', shf);
+		} else if (!inquote) {
+			shf_putc('\'', shf);
+			inquote = true;
 		}
+		shf_putc(c, shf);
+	}
+	if (inquote)
+		shf_putc('\'', shf);
+}
 
-		/* otherwise, quote nicely via state machine */
-		while ((c = *p++) != 0) {
-			if (c == '\'') {
+#define dollarq_Uctrl(c)	(!ctype((c), C_PRINT))
+#ifndef MKSH_SMALL
+#define dollarq_isctrlU(c)	dollarq_Uctrl(c)
+#else
+#define dollarq_isctrlU(c)	(UTFMODE ? dollarq_Uctrl(c) : ksh_isctrl8(c))
+#endif
+
+/* escape with $'...' (!MKSH_SMALL: in UTFMODE) */
+static unsigned int
+dollarqU(struct shf *shf, const unsigned char *s)
+{
+	unsigned char c;
+	unsigned int wc;
+	size_t n;
+	unsigned int rv = 0;
+
+	shf_putc('$', shf);
+	shf_putc('\'', shf);
+	while ((c = *s) != 0) {
+		if (
+#ifdef MKSH_SMALL
+		    UTFMODE &&
+#endif
+		    rtt2asc(c) >= 0xC2U && (n = utf_mbtowc(&wc,
+		    (const char *)s)) != (size_t)-1) {
+			/* valid UTF-8 multibyte character > 0x7F */
+			if ((wc ^ 0x80U) < 0x20U) {
+				/* C1 control character */
+				shf_fprintf(shf, "\\u%04X", wc);
+				rv = 2;
+				s += n;
+			} else {
 				/*
-				 * multiple single quotes or any of them
-				 * at the beginning of a string look nicer
-				 * this way than when simply substituting
+				 * print as-is; we assume the tty DTRT for
+				 * interlinear annotations, LTR/RTL mark,
+				 * U+2028, U+2029, U+2066..U+206F, etc.
 				 */
-				if (inquote) {
-					shf_putc('\'', shf);
-					inquote = false;
-				}
-				shf_putc('\\', shf);
-			} else if (!inquote) {
-				shf_putc('\'', shf);
-				inquote = true;
+				shf_wr_sm(s, n, shf);
 			}
-			shf_putc(c, shf);
+			continue;
 		}
-	} else {
-		unsigned int wc;
-		size_t n;
+		++s;
+		/* single octet */
+		rv |= ctype(c, C_QUOTE | C_SPC);
+		switch (c) {
+		/* see unbksl() in this file for comments */
+		case KSH_BEL:
+			c = 'a';
+			if (0)
+				/* FALLTHROUGH */
+		case '\b':
+			  c = 'b';
+			if (0)
+				/* FALLTHROUGH */
+		case '\f':
+			  c = 'f';
+			if (0)
+				/* FALLTHROUGH */
+		case '\n':
+			  c = 'n';
+			if (0)
+				/* FALLTHROUGH */
+		case '\r':
+			  c = 'r';
+			if (0)
+				/* FALLTHROUGH */
+		case '\t':
+			  c = 't';
+			if (0)
+				/* FALLTHROUGH */
+		case KSH_VTAB:
+			  c = 'v';
+			if (0)
+				/* FALLTHROUGH */
+		case KSH_ESC:
+			/* take E not e because \e is \ in *roff */
+			  c = 'E';
+			rv = 2;
+			/* FALLTHROUGH */
+		case '\\':
+			shf_putc('\\', shf);
 
-		/* use $'...' quote format */
-		shf_putc('$', shf);
-		shf_putc('\'', shf);
-		while ((c = *p) != 0) {
-#ifndef MKSH_EBCDIC
-			if (c >= 0xC2) {
-				n = utf_mbtowc(&wc, (const char *)p);
-				if (n != (size_t)-1) {
-					p += n;
-					shf_fprintf(shf, "\\u%04X", wc);
-					continue;
-				}
-			}
-#endif
-			++p;
-			switch (c) {
-			/* see unbksl() in this file for comments */
-			case KSH_BEL:
-				c = 'a';
-				if (0)
-					/* FALLTHROUGH */
-			case '\b':
-				  c = 'b';
-				if (0)
-					/* FALLTHROUGH */
-			case '\f':
-				  c = 'f';
-				if (0)
-					/* FALLTHROUGH */
-			case '\n':
-				  c = 'n';
-				if (0)
-					/* FALLTHROUGH */
-			case '\r':
-				  c = 'r';
-				if (0)
-					/* FALLTHROUGH */
-			case '\t':
-				  c = 't';
-				if (0)
-					/* FALLTHROUGH */
-			case KSH_VTAB:
-				  c = 'v';
-				if (0)
-					/* FALLTHROUGH */
-			case KSH_ESC:
-				/* take E not e because \e is \ in *roff */
-				  c = 'E';
+			if (0)
 				/* FALLTHROUGH */
-			case '\\':
-				shf_putc('\\', shf);
+		default:
+			  if (dollarq_isctrlU(c)) {
+				rv = 2;
+				/* FALLTHROUGH */
+		case '\'':
+				shf_fprintf(shf, "\\%03o", c);
+				break;
+			}
 
-				if (0)
-					/* FALLTHROUGH */
-			default:
-#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
-				  if (ksh_isctrl(c))
-#else
-				  if (!ctype(c, C_PRINT))
-#endif
-				    {
-					/* FALLTHROUGH */
-			case '\'':
-					shf_fprintf(shf, "\\%03o", c);
-					break;
-				}
+			shf_putc(c, shf);
+			break;
+		}
+	}
+	shf_putc('\'', shf);
+	return (rv);
+}
+
+#ifndef MKSH_SMALL
+/* escape with $'...' outside UTFMODE */
+static void
+dollarq8(struct shf *shf, const unsigned char *s)
+{
+	unsigned char c;
 
-				shf_putc(c, shf);
+	shf_putc('$', shf);
+	shf_putc('\'', shf);
+	while ((c = *s++) != 0) {
+		/* single octet */
+		switch (c) {
+		/* see unbksl() in this file for comments */
+		case KSH_BEL:
+			c = 'a';
+			if (0)
+				/* FALLTHROUGH */
+		case '\b':
+			  c = 'b';
+			if (0)
+				/* FALLTHROUGH */
+		case '\f':
+			  c = 'f';
+			if (0)
+				/* FALLTHROUGH */
+		case '\n':
+			  c = 'n';
+			if (0)
+				/* FALLTHROUGH */
+		case '\r':
+			  c = 'r';
+			if (0)
+				/* FALLTHROUGH */
+		case '\t':
+			  c = 't';
+			if (0)
+				/* FALLTHROUGH */
+		case KSH_VTAB:
+			  c = 'v';
+			if (0)
+				/* FALLTHROUGH */
+		case KSH_ESC:
+			/* take E not e because \e is \ in *roff */
+			  c = 'E';
+			/* FALLTHROUGH */
+		case '\\':
+			shf_putc('\\', shf);
+
+			if (0)
+				/* FALLTHROUGH */
+		default:
+			  if (ksh_isctrl8(c)) {
+				/* FALLTHROUGH */
+		case '\'':
+				shf_fprintf(shf, "\\%03o", c);
 				break;
 			}
+
+			shf_putc(c, shf);
+			break;
 		}
-		inquote = true;
 	}
-	if (inquote)
-		shf_putc('\'', shf);
+	shf_putc('\'', shf);
 }
+#endif
 
 /*
  * Print things in columns and rows - func() is called to format
@@ -1584,7 +1732,7 @@ print_columns(struct columnise_opts *opt
 	max_col = -max_col;
 	goto prcols_hard;
 	while (r < rows) {
-		shf_putchar(opts->linesep, opts->shf);
+		shf_putc(opts->linesep, opts->shf);
  prcols_hard:
 		for (c = 0; c < cols; c++) {
 			if ((i = c * rows + r) >= n)
@@ -1600,7 +1748,7 @@ print_columns(struct columnise_opts *opt
 	}
  out:
 	if (opts->do_last)
-		shf_putchar(opts->linesep, opts->shf);
+		shf_putc(opts->linesep, opts->shf);
 	afree(str, ATEMP);
 }
 
@@ -1678,14 +1826,18 @@ ksh_get_wd(void)
 	char *rv, *cp;
 
 	if ((cp = get_current_dir_name())) {
-		strdupx(rv, cp, ATEMP);
+		if (mksh_abspath(cp))
+			strdupx(rv, cp, ATEMP);
+		else
+			rv = NULL;
 		free_gnu_gcdn(cp);
 	} else
 		rv = NULL;
 #else
 	char *rv;
 
-	if (!getcwd((rv = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX)) {
+	if (!getcwd((rv = alloc(PATH_MAX + 1, ATEMP)), PATH_MAX) ||
+	    !mksh_abspath(rv)) {
 		afree(rv, ATEMP);
 		rv = NULL;
 	}
@@ -1704,15 +1856,17 @@ do_realpath(const char *upath)
 	char *xp, *ip, *tp, *ipath, *ldest = NULL;
 	XString xs;
 	size_t pos, len;
-	int llen;
+	ssize_t llen;
 	struct stat sb;
 #ifdef MKSH__NO_PATH_MAX
-	size_t ldestlen = 0;
-#define pathlen sb.st_size
-#define pathcnd (ldestlen < (pathlen + 1))
+	off_t ldestlen = 0;
+#define pathlen ((size_t)sb.st_size)
+#define pathcnd ((ldestlen < 1) || ((ldestlen - 1) < sb.st_size))
+#define ldestsz ((size_t)ldestlen)
 #else
-#define pathlen PATH_MAX
+#define pathlen ((size_t)PATH_MAX)
 #define pathcnd (!ldest)
+#define ldestsz (pathlen + 1U)
 #endif
 	/* max. recursion depth */
 	int symlinks = 32;
@@ -1730,7 +1884,7 @@ do_realpath(const char *upath)
 #endif
 	} else {
 		/* upath is a relative pathname, prepend cwd */
-		if ((tp = ksh_get_wd()) == NULL || !mksh_abspath(tp))
+		if ((tp = ksh_get_wd()) == NULL)
 			return (NULL);
 		strpathx(ipath, tp, upath, 1);
 		afree(tp, ATEMP);
@@ -1813,15 +1967,19 @@ do_realpath(const char *upath)
 			/* get symlink(7) target */
 			if (pathcnd) {
 #ifdef MKSH__NO_PATH_MAX
-				if (notoktoadd(pathlen, 1)) {
+				/* same as notoktoadd(pathlen, 1) but adapted */
+				if ((uintmax_t)sb.st_size >= (uintmax_t)SIZE_MAX) {
 					errno = ENAMETOOLONG;
 					goto notfound;
 				}
+				ldestlen = sb.st_size + 1; /* <= SIZE_MAX */
 #endif
-				ldest = aresize(ldest, pathlen + 1, ATEMP);
+				/* ldestsz == pathlen + 1 */
+				ldest = aresize(ldest, ldestsz, ATEMP);
 			}
-			llen = readlink(Xstring(xs, xp), ldest, pathlen);
-			if (llen < 0)
+			errno = ENAMETOOLONG; /* for > pathlen case */
+			llen = readlink(Xstring(xs, xp), ldest, ldestsz);
+			if (llen < 0 || (size_t)llen > pathlen)
 				/* oops... */
 				goto notfound;
 			ldest[llen] = '\0';
@@ -1910,11 +2068,11 @@ do_realpath(const char *upath)
 
  notfound:
 	/* save; freeing memory might trash it */
-	llen = errno;
+	symlinks = errno;
 	afree(ldest, ATEMP);
 	afree(ipath, ATEMP);
 	Xfree(xs, xp);
-	errno = llen;
+	errno = symlinks;
 	return (NULL);
 
 #undef pathlen
@@ -1949,8 +2107,12 @@ make_path(const char *cwd, const char *f
 	size_t len, plen = 0;
 	char *xp = Xstring(*xsp, xp);
 
-	if (!file)
+	if (!file) {
 		file = null;
+#ifdef DEBUG
+		assert(file[0] == '\0'); /* for Coverity */
+#endif
+	}
 
 	if (mksh_abspath(file)) {
 		*phys_pathp = 0;
@@ -2228,7 +2390,7 @@ c_cd(const char **wp)
 		 * substitution fails because the cd fails we could try to
 		 * find another substitution. For now, we don't.
 		 */
-		if ((cp = strstr(current_wd, wp[0])) == NULL) {
+		if ((cp = ucstrstr(current_wd, wp[0])) == NULL) {
 			bi_errorf(Tbadsubst);
 			return (2);
 		}
@@ -2341,7 +2503,6 @@ c_cd(const char **wp)
 	return (rv);
 }
 
-
 #ifdef KSH_CHVT_CODE
 extern void chvt_reinit(void);
 
@@ -2369,18 +2530,18 @@ chvt(const Getopt *go)
 				memmove(cp + 1, cp, /* /dev/tty */ 8);
 				dv = cp + 1;
 				if (stat(dv, &sb)) {
-					errorf(Tf_sD_sD_s, "chvt",
+					errorf(Tchvt2,
 					    "can't find tty", go->optarg);
 				}
 			}
 		}
-		if (!(sb.st_mode & S_IFCHR))
-			errorf(Tf_sD_sD_s, "chvt", "not a char device", dv);
+		if (!S_ISCHR(sb.st_mode))
+			errorf(Tchvt2, "not a char device", dv);
 #ifndef MKSH_DISABLE_REVOKE_WARNING
 #if HAVE_REVOKE
 		if (revoke(dv))
 #endif
-			warningf(false, Tf_sD_s_s, "chvt",
+			warningf(false, Tchvt2,
 			    "new shell is potentially insecure, can't revoke",
 			    dv);
 #endif
@@ -2389,13 +2550,14 @@ chvt(const Getopt *go)
 	if ((fd = binopen2(dv, O_RDWR)) < 0) {
 		sleep(1);
 		if ((fd = binopen2(dv, O_RDWR)) < 0) {
-			errorf(Tf_sD_s_s, "chvt", Tcant_open, dv);
+			errorf(Tchvt2, Topen, dv);
 		}
 	}
+	afree(cp, ATEMP);
 	if (go->optarg[0] != '!') {
 		switch (fork()) {
 		case -1:
-			errorf(Tf_sD_s_s, "chvt", "fork", "failed");
+			errorf(Tchvt_failed, "fork");
 		case 0:
 			break;
 		default:
@@ -2403,12 +2565,12 @@ chvt(const Getopt *go)
 		}
 	}
 	if (setsid() == -1)
-		errorf(Tf_sD_s_s, "chvt", "setsid", "failed");
+		errorf(Tchvt_failed, "setsid");
 	if (go->optarg[0] != '-') {
 		if (ioctl(fd, TIOCSCTTY, NULL) == -1)
-			errorf(Tf_sD_s_s, "chvt", "TIOCSCTTY", "failed");
+			errorf(Tchvt_failed, "TIOCSCTTY");
 		if (tcflush(fd, TCIOFLUSH))
-			errorf(Tf_sD_s_s, "chvt", "TCIOFLUSH", "failed");
+			errorf(Tchvt_failed, "TCIOFLUSH");
 	}
 	ksh_dup2(fd, 0, false);
 	ksh_dup2(fd, 1, false);
@@ -2420,38 +2582,6 @@ chvt(const Getopt *go)
 }
 #endif
 
-#ifdef DEBUG
-char *
-strchr(char *p, int ch)
-{
-	for (;; ++p) {
-		if (*p == ch)
-			return (p);
-		if (!*p)
-			return (NULL);
-	}
-	/* NOTREACHED */
-}
-
-char *
-strstr(char *b, const char *l)
-{
-	char first, c;
-	size_t n;
-
-	if ((first = *l++) == '\0')
-		return (b);
-	n = strlen(l);
- strstr_look:
-	while ((c = *b++) != first)
-		if (c == '\0')
-			return (NULL);
-	if (strncmp(b, l, n))
-		goto strstr_look;
-	return (b - 1);
-}
-#endif
-
 #if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
 char *
 strndup_i(const char *src, size_t len, Area *ap)
@@ -2480,10 +2610,13 @@ strdup_i(const char *src, Area *ap)
 } while (/* CONSTCOND */ 0)
 
 int
-getrusage(int what, struct rusage *ru)
+ksh_getrusage(int what, struct rusage *ru)
 {
 	struct tms tms;
 	clock_t u, s;
+#ifndef CLK_TCK
+	long CLK_TCK;
+#endif
 
 	if (/* ru == NULL || */ times(&tms) == (clock_t)-1)
 		return (-1);
@@ -2501,6 +2634,15 @@ getrusage(int what, struct rusage *ru)
 		errno = EINVAL;
 		return (-1);
 	}
+#ifndef CLK_TCK
+#ifdef ENOSYS
+	errno = ENOSYS;
+#else
+	errno = EINVAL;
+#endif
+	if ((CLK_TCK = sysconf(_SC_CLK_TCK)) == -1L)
+		internal_errorf("sysconf(_SC_CLK_TCK): %s", cstrerror(errno));
+#endif
 	INVTCK(ru->ru_utime, u);
 	INVTCK(ru->ru_stime, s);
 	return (0);
@@ -2532,7 +2674,7 @@ unbksl(bool cstyle, int (*fg)(void), voi
 		if (!cstyle)
 			goto unknown_escape;
 		c = (*fg)();
-		wc = ksh_toctrl(c);
+		wc = asc2rtt(ord(c) == ORD('?') ? 0x7F : rtt2asc(c) & 0x9F);
 		break;
 	case 'E':
 	case 'e':
@@ -2637,3 +2779,60 @@ unbksl(bool cstyle, int (*fg)(void), voi
 
 	return (wc);
 }
+
+#ifdef DEBUG
+#undef strchr
+char *
+ucstrchr(char *s, int c)
+{
+	return (strchr(s, c));
+}
+
+const char *
+cstrchr(const char *s, int c)
+{
+	return (strchr(s, c));
+}
+#endif
+
+#if !HAVE_STRSTR
+char *
+ucstrstr(char *big, const char *little)
+{
+	union mksh_cchack res;
+
+	res.ro = cstrstr(big, little);
+	return (res.rw);
+}
+
+const char *
+cstrstr(const char *big, const char *little)
+{
+	char first, c;
+	size_t n;
+
+	if ((first = *little++) == '\0')
+		return (big);
+	n = strlen(little);
+ strstr_look:
+	while ((c = *big++) != first)
+		if (c == '\0')
+			return (NULL);
+	if (strncmp(big, little, n))
+		goto strstr_look;
+	return (big - 1);
+}
+#elif defined(DEBUG)
+#undef strstr
+char *
+ucstrstr(char *big, const char *little)
+{
+	return (strstr(big, little));
+}
+
+const char *
+cstrstr(const char *big, const char *little)
+{
+	return (strstr(big, little));
+}
+#endif
--- mksh-59c.orig/mksh.1
+++ mksh-59c/mksh.1
@@ -1,9 +1,9 @@
-.\" $MirOS: src/bin/mksh/mksh.1,v 1.494 2020/10/01 22:39:57 tg Exp $
+.\" $MirOS: src/bin/mksh/mksh.1,v 1.525+locale-tracking 2021/10/10 21:33:55 tg Exp $
 .\" $OpenBSD: ksh.1,v 1.160 2015/07/04 13:27:04 feinerer Exp $
 .\"-
 .\" Copyright © 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
 .\"		2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017,
-.\"		2018, 2019, 2020
+.\"		2018, 2019, 2020, 2021
 .\"	mirabilos <m@mirbsd.org>
 .\"
 .\" Provided that these terms and disclaimer and all copyright notices
@@ -84,7 +84,7 @@
 .\" with -mandoc, it might implement .Mx itself, but we want to
 .\" use our own definition. And .Dd must come *first*, always.
 .\"
-.Dd $Mdocdate: October 1 2020 $
+.Dd $Mdocdate: October 10 2021 $
 .\"
 .\" Check which macro package we use, and do other -mdoc setup.
 .\"
@@ -309,31 +309,32 @@ files:
 .Pp
 .Bl -bullet -compact
 .It
-The
-.Ic cd
-.Po and Ic chdir Pc
-command is disabled.
-.It
-The
-.Ev SHELL ,
-.Ev ENV
-and
+Command names cannot be specified with pathnames, absolute or relative,
+nor using the
+.Fl p
+option of the
+.Ic command
+built-in utility; the
+.Ev ENV ,
 .Ev PATH
+and
+.Ev SHELL
 parameters cannot be changed.
 .It
-Command names can't be specified with absolute or relative paths.
-.It
-The
-.Fl p
-option of the built-in command
-.Ic command
-can't be used.
+The current location is fixed: the
+.Ic cd
+command and its alias
+.Ic chdir
+is disabled.
 .It
 Redirections that create files can't be used (i.e.\&
 .Dq Li \*(Gt ,
 .Dq Li \*(Gt\*(Ba ,
 .Dq Li \*(Gt\*(Gt ,
-.Dq Li \*(Lt\*(Gt ) .
+.Dq Li \*(Lt\*(Gt ) ,
+and the
+.Ev HISTFILE
+parameter cannot be changed.
 .El
 .It Fl s
 The shell reads commands from standard input; all non-option arguments
@@ -1227,27 +1228,31 @@ Parameter substitutions,
 which are described in detail in the next section, take the form
 .Pf $ Ns Ar name
 or
-.Pf ${ Ns Ar ... Ns } ;
-command substitutions take the form
+.Pf ${ Ns Ar name... Ns } ;
+arithmetic substitutions take the form
+.Pf $(( Ns Ar expression Ns )) ;
+and command substitutions take the form
 .Pf $( Ns Ar command Ns \&)
 or (deprecated)
 .Pf \` Ns Ar command Ns \`
 or (executed in the current environment)
 .Pf ${\ \& Ar command Ns \&;}
-and strip trailing newlines;
-and arithmetic substitutions take the form
-.Pf $(( Ns Ar expression Ns )) .
-Parsing the current-environment command substitution requires a space,
+and evaluate to the output of
+.Ar command
+with any trailing newlines stripped.
+The latter form requires a space,
 tab or newline after the opening brace and that the closing brace be
 recognised as a keyword (i.e. is preceded by a newline or semicolon).
-They are also called funsubs (function substitutions) and behave like
-functions in that
+They are also called funsubs (function substitutions) and behave
+similar to functions in that shell options are shared and
 .Ic local
 and
 .Ic return
-work, and in that
+work, though, in contrast to valsubs (see below),
 .Ic exit
-terminates the parent shell; shell options are shared.
+does not terminate the parent shell for compatibility with
+.At
+.Nm ksh93 .
 .Pp
 Another variant of substitution are the valsubs (value substitutions)
 .Pf ${\*(Ba\& Ns Ar command Ns \&;}
@@ -1256,7 +1261,8 @@ share their I/O with the parent; instead
 the, initially empty, expression-local variable
 .Ev REPLY
 is set to within the
-.Ar command Ns s .
+.Ar command Ns s ; Ic exit
+affects the parent like in a function call.
 .Pp
 If a substitution appears outside of double quotes, the results of the
 substitution are generally subject to word or field splitting according to
@@ -1316,7 +1322,7 @@ not
 .Dq Li D
 and
 .Dq Li E .
-This behavior is POSIX compliant, but incompatible with some other shell
+This behaviour is POSIX compliant but incompatible with some other shell
 implementations which do field splitting on the word which contained the
 substitution or use
 .Dv IFS
@@ -1325,15 +1331,17 @@ as a general whitespace delimiter.
 The results of substitution are, unless otherwise specified, also subject to
 brace expansion and file name expansion (see the relevant sections below).
 .Pp
-A command substitution is replaced by the output generated by the specified
-command which is run in a subshell.
+A command substitution of the regular (comsub), deprecated, funsub or valsub
+form is replaced by the output generated by the specified
+.Ar command
+which is run in a subshell except for the funsub and valsub types which run
+in the current execution environment.
 For
-.Pf $( Ns Ar command Ns \&)
+.Pf $( Ns Ar command Ns \&) ,
+.Pf ${\ \& Ar command Ns \&;}
 and
 .Pf ${\*(Ba\& Ns Ar command Ns \&;}
-and
-.Pf ${\ \& Ar command Ns \&;}
-substitutions, normal quoting rules are used when
+forms, normal quoting rules are used when
 .Ar command
 is parsed; however, for the deprecated
 .Pf \` Ns Ar command Ns \`
@@ -1347,16 +1355,18 @@ or
 is stripped (as is
 .Ql \&"
 when the substitution is part of a double-quoted string); a backslash
-.Ql \e
 followed by any other character is unchanged.
 As a special case in command substitutions, a command of the form
 .Pf \*(Lt Ar file
 is interpreted to mean substitute the contents of
-.Ar file .
-Note that
+.Ar file
+so that
 .Ic $(\*(Ltfoo)
-has the same effect as
-.Ic $(cat foo) .
+has the same effect, if
+.Pa foo
+is readable, as
+.Ic $(cat foo)
+but is much more performant.
 .Pp
 Note that some shells do not use a recursive parser for command substitutions,
 leading to failure for certain constructs; to be portable, use as workaround
@@ -1493,11 +1503,8 @@ the environment (see
 of commands run by the shell as
 .Ar name Ns = Ns Ar value
 pairs.
-The order in which parameters appear in the environment of a command is
-unspecified.
 When the shell starts up, it extracts parameters and their values
-from its environment and automatically sets the export attribute for those
-parameters.
+from its environment setting the export attribute for those.
 .Pp
 Modifiers can be applied to the
 .Pf ${ Ns Ar name Ns }
@@ -1757,6 +1764,15 @@ This is also used internally for the she
 A quoted expression safe for re-entry, whose value is the value of the
 .Ar name
 parameter, is substituted.
+.Pp
+.It Pf ${ Ns Ar name Ns @\*(ha}
+The value of
+.Ar name
+in extended caret notation, with both caret
+.Pq Ql \*(ha\&
+and backslash
+.Pq Ql \e\&
+backslash-escaped to avoid ambiguity.
 .El
 .Pp
 Note that
@@ -2316,14 +2332,21 @@ Ranges of octets can be specified by sep
 matches the letter
 .Ql a
 or any digit).
+Character classes can be specified by wrapping the name of the class between
+.Dq Li \&[:
+and
+.Dq Li \&:]
+(e.g.\&
+.Dq Li \&[[:alpha:][:digit:].]
+matches any ASCII letter or digit and the full stop).
+.Pp
 In order to represent itself, a
 .Ql \-
 must either be quoted or the first or last octet in the octet list.
-Similarly, a
+Similarly, if it is to represent itself instead of the end of the list, a
 .Ql \&]
-must be quoted or the first octet in the list if it is to represent itself
-instead of the end of the list.
-Also, a
+must be quoted or the first octet in the list.
+Also, an
 .Ql \&!
 appearing at the start of the list has special meaning (see below), so to
 represent itself it must be quoted or appear later in the list.
@@ -2394,6 +2417,114 @@ matches no strings; the pattern
 matches all strings (think about it).
 .El
 .Pp
+The following character classes are supported (note all
+.Tn POSIX
+references assume the
+.Dv C
+locale; EBCDIC systems use the bytes from the codepage
+that map to the named ASCII characters so e.g.\&
+.Dq Li \&[[:upper:]]
+is correct while
+.Dq Li \&[A\-Z]
+will contain probably-unwanted characters on EBCDIC systems):
+.Pp
+.Bl -tag -width sh_quote -offset indent -compact
+.It Ic \*(Lt
+.Pq Tn BSD
+the null string at the beginning of a word
+.It Ic \*(Gt
+.Pq Tn BSD
+the null string at the end of a word
+.It Ic alnum
+.Pq Tn POSIX
+alphanumerical
+.Pq Ic alpha No or Ic digit
+.It Ic alpha
+.Pq Tn POSIX
+alphabetical
+.Pq Ic upper No or Ic lower
+.It Ic ascii
+.Pq Tn GNU Nm bash
+any 7-bit
+.Tn ASCII
+character except
+.Dv NUL
+.It Ic blank
+.Pq Tn POSIX
+space or horizontal\ tab
+.It Ic cntrl
+.Pq Tn POSIX
+ASCII C0 control characters
+.Pq \ex00\*(en\ex1F
+or \ex7F
+.It Ic digit
+.Pq Tn POSIX
+ASCII decimal digits
+.Pq 0\*(en9
+.It Ic graph
+.Pq Tn POSIX
+.Ic alnum No or Ic punct
+.Pq !\*(en\*(TI
+.It Ic lower
+.Pq Tn POSIX
+ASCII lowercase letters
+.Pq a\*(enz
+.It Ic print
+.Pq Tn POSIX
+.No space or Ic graph
+.Pq \ex20\*(en\*(TI
+.It Ic punct
+.Pq Tn POSIX
+punctuation
+.Pq Ic graph No except Ic alnum :
+.Li \&!"#$%&\*(aq()*+,\-./:;\*(Lt=\*(Gt?@[\e\e]\*(ha_\`{\*(Ba}\*(TI
+.It Ic sh_alias
+.Pq Nm mksh
+valid in alias names:
+.Ic alnum
+or
+.Li \&!%+,\-.:@[]_
+.It Ic sh_edq
+.Pq Nm mksh
+quoted by tab completion:
+.Li \&"#$&\*(aq()*:;\*(Lt=\*(Gt?[\e\e\`{\*(Ba}\*(TI
+.It Ic sh_ifs
+.Pq Nm mksh
+IFS whitespace, IFS non-whitespace,
+.Dv NUL
+.Pq via Ev $IFS
+.It Ic sh_ifsws
+.Pq Nm mksh
+IFS WS candidates: space, horizontal\ tab, linefeed
+.It Ic sh_nl
+.Pq Nm mksh
+linefeed or (OS/2 TEXTMODE only) carriage\ return
+.It Ic sh_quote
+.Pq Nm mksh
+characters requiring quoting, minus space:
+.Li \&\ex09\ex0A"#$&\*(aq()*;\*(Lt=\*(Gt?[\e\e]\`{\*(Ba}\*(TI
+.It Ic space
+.Pq Tn POSIX
+horizontal\ tab, line\ feed, vertical\ tab, form\ feed,
+carriage\ return, space
+.Pq \ex09\*(en\ex0D\ex20
+.It Ic upper
+.Pq Tn POSIX
+ASCII uppercase letters
+.Pq A\*(enZ
+.It Ic word
+.Pq Tn GNU Nm bash
+alphanumerical
+.Pq Ic alnum
+or underscore
+.Pq Dq Li \&_
+.It Ic xdigit
+.Pq Tn POSIX
+hexadecimal digits
+.Pq 0\*(en9A\*(enFa\*(enf
+a.k.a. nybbles
+.El
+.Pp
 Note that complicated globbing, especially with alternatives,
 is slow; using separate comparisons may (or may not) be faster.
 .Pp
@@ -2624,7 +2755,9 @@ This also affects implicit conversion to
 .Ic let
 command.
 .Em Never
-use unchecked user input, e.g. from the environment, in an arithmetic context!
+use unchecked user input, e.g. from the environment (although the shell
+tracks import status and refuses to automatically coerce those), in
+arithmetic context!
 .Pp
 Expressions are calculated using signed arithmetic and the
 .Vt mksh_ari_t
@@ -2670,7 +2803,8 @@ Grouping operators:
 .Ed
 .Pp
 Integer constants and expressions are calculated using an exactly 32-bit
-wide, signed or unsigned, type with silent wraparound on integer overflow.
+wide, signed (two's complement) or unsigned, type with silent wraparound
+on integer overflow.
 Integer constants may be specified with arbitrary bases using the notation
 .Ar base Ns # Ns Ar number ,
 where
@@ -2678,7 +2812,7 @@ where
 is a decimal integer specifying the base (up to 36), and
 .Ar number
 is a number in the specified base.
-Additionally, base-16 integers may be specified by prefixing them with
+Additionally, base-16 integers may be specified by prefixing with
 .Dq Li 0x
 .Pq case-insensitive
 in all forms of arithmetic expressions, except as numeric arguments to the
@@ -2687,7 +2821,11 @@ built-in utility.
 Prefixing numbers with a sole digit zero
 .Pq Dq Li 0
 does not cause interpretation as octal (except in POSIX mode,
-as required by the standard), as that's unsafe to do.
+as required by the standard), as that's unsafe.
+Prefixing with
+.Dq Li 10#\&
+forces interpretation as decimal, even with leading zeros.
+An unset or empty parameter evaluates to 0 in integer context.
 .Pp
 As a special
 .Nm mksh
@@ -2705,7 +2843,6 @@ instead of
 .Dq Li 1#x
 is also supported.
 Note that NUL bytes (integral value of zero) cannot be used.
-An unset or empty parameter evaluates to 0 in integer context.
 If
 .Sq Li x
 isn't comprised of exactly one valid character, the behaviour is undefined
@@ -2716,6 +2853,12 @@ must validate the input first.
 See
 .Sx CAVEATS
 for UTF-8 mode handling.
+Base-1 integers don't work well with a number of other shell features,
+such as reentry-safe output; use
+.Ic print Fl A
+or
+.Ic read Fl a
+if possible.
 .Pp
 The operators are evaluated as follows:
 .Bl -tag -width Ds -offset indent
@@ -2999,6 +3142,8 @@ outside the function).
 .It
 Shell options
 .Pq Ic set Fl o
+except
+.Fl p Pq Fl o Ic privileged
 have local scope, i.e. changes inside a function are reset upon its exit.
 .El
 .Pp
@@ -3046,13 +3191,12 @@ commands keeping assignments:
 All other builtins are not special; these are at least:
 .Pp
 .Ic [\& , alias , bg , bind ,
-.Ic builtin , cat , cd , command ,
-.Ic echo , false , fc , fg ,
-.Ic getopts , jobs , kill , let ,
-.Ic print , pwd , read , realpath ,
-.Ic rename , sleep , suspend , test ,
-.Ic true , ulimit , umask , unalias ,
-.Ic wait , whence
+.Ic builtin , cd , command , echo ,
+.Ic false , fc , fg , getopts ,
+.Ic jobs , kill , let , print ,
+.Ic pwd , read , realpath , rename ,
+.Ic suspend , test , true , ulimit ,
+.Ic umask , unalias , wait , whence
 .Pp
 Once the type of command has been determined, any command-line parameter
 assignments are performed and exported for the duration of the command.
@@ -3114,7 +3258,7 @@ variable for your consumption.
 .It Ic Lstripcom Op Ar
 .Pq Li dot.mkshrc No function
 Same as
-.Ic cat
+.Xr cat 1
 but strips any empty lines and comments (from any
 .Sq #
 character onwards, no escapes)
@@ -3130,8 +3274,7 @@ See
 .Fl +x Oc
 .Op Fl p
 .Op Cm +
-.Oo Ar name
-.Op Ns = Ns Ar value
+.Oo Ar name Ns Op = Ns Ar value
 .Ar ... Oc
 .Xc
 .Pq regular
@@ -3251,14 +3394,28 @@ string, wherein prefix/control/tilde cha
 .Pq but not those mapped to other macros
 will be processed.
 .Pp
-Prefix and control characters may be written using caret notation, i.e.\&
+The entire argument may be written using extended caret notation:
 .No \*(ha Ns Li Z
 represents
-.No Ctrl- Ns Li Z .
-Use a backslash to escape the caret, an equals sign or another backslash.
+.No Ctrl- Ns Li Z ;
+.No \*(ha Ns Li +Z
+represents UTF-8
+.No Meta-Ctrl- Ns Li Z ,
+and both
+.No \*(ha Ns Li !Z
+and
+.No \ex Ns Li 9A
+represent ASCII
+.No Meta-Ctrl- Ns Li Z .
+Otherwise, a backslash escapes the next character,
+removing the special meaning from backslashes, carets and
+.Pq for the Ar string No part
+equals signs.
+.Pf ( Em These
+backslashes obviously must be quoted for the shell.)
 Note that, although only three prefix characters
 .Pq usually Esc, \*(haX and NUL
-are supported, some multi-character sequences can be supported.
+are usable, some multi-character sequences can be supported.
 .Pp
 .It Ic break Op Ar level
 .Pq keeps assignments , special
@@ -3297,26 +3454,6 @@ declaration utility (see
 is a declaration utility.
 .Pp
 .It Xo
-.Ic cat
-.Op Fl u
-.Op Ar
-.Xc
-.Pq defer with flags
-Copy files in command line order to standard output.
-If a
-.Ar file
-is a single dash
-.Pq Dq Li \-
-or absent, read from standard input.
-For direct builtin calls, the
-.Tn POSIX
-.Fl u
-option is supported as a no-op.
-For calls from shell, if any options are given, an external
-.Xr cat 1
-utility is preferred over the builtin.
-.Pp
-.It Xo
 .Ic cd
 .Op Fl L
 .Op Ar dir
@@ -3813,8 +3950,7 @@ Same as
 .It Xo
 .Ic integer
 .Op flags
-.Oo Ar name
-.Op Ns = Ns Ar value
+.Oo Ar name Ns Op = Ns Ar value
 .Ar ... Oc
 .Xc
 .Pq built-in alias
@@ -3893,8 +4029,7 @@ is syntactic sugar for:
 .It Xo
 .Ic local
 .Op flags
-.Oo Ar name
-.Op Ns = Ns Ar value
+.Oo Ar name Ns Op = Ns Ar value
 .Ar ... Oc
 .Xc
 .Pq built-in alias
@@ -3941,8 +4076,7 @@ however, distributors may have added thi
 .It Xo
 .Ic nameref
 .Op flags
-.Oo Ar name
-.Op Ns = Ns Ar value
+.Oo Ar name Ns Op = Ns Ar value
 .Ar ... Oc
 .Xc
 .Pq built-in alias
@@ -3990,13 +4124,14 @@ Empty
 .Ar argument Ns s
 separate input words.
 .It Fl c
-The output is printed columnised, line by line, similar to how the
-.Xr rs 1
-utility, tab completion, the
+The output is printed columnised, top to bottom then left to right,
+similar to how tab completion (control character escaping excepted), the
 .Ic kill Fl l
-built-in utility and the
+built-in utility, the
 .Ic select
-statement do.
+statement and the
+.Xr rs 1
+utility do.
 .It Fl e
 Restore backslash expansion after a previous
 .Fl r .
@@ -4213,8 +4348,7 @@ exits with a non-zero status.
 .It Xo
 .Ic readonly
 .Op Fl p
-.Oo Ar parameter
-.Op Ns = Ns Ar value
+.Oo Ar parameter Ns Op = Ns Ar value
 .Ar ... Oc
 .Xc
 .Pq keeps assignments , special, decl-util
@@ -4255,16 +4389,15 @@ resolving to an extant non-directory is
 .Op Fl \-
 .Ar from to
 .Xc
-.Pq defer always
+.Pq defer always , needs Xr rename 2
 Renames the file
 .Ar from
 to
 .Ar to .
-Both must be complete pathnames and on the same device.
+Both pathnames must be on the same device.
 Intended for emergency situations
 .Pq where Pa /bin/mv No becomes unusable ;
-directly calls
-.Xr rename 2 .
+thin syscall wrapper.
 .Pp
 .It Ic return Op Ar status
 .Pq keeps assignments , special
@@ -4460,10 +4593,9 @@ and at least one of these returns someth
 or
 .Dq utf8
 case-insensitively; for direct builtin calls depending on the
-aforementioned environment variables; or for stdin or scripts,
-if the input begins with a UTF-8 Byte Order Mark.
+aforementioned environment variables.
 .Pp
-In near future, locale tracking will be implemented, which means that
+This build of the shell implements baroque locale tracking, that is,
 .Ic set Fl +U
 is changed whenever one of the
 .Tn POSIX
@@ -4488,6 +4620,15 @@ during globbing.
 .It Fl x \*(Ba Fl o Ic xtrace
 Print commands when they are executed, preceded by
 .Ev PS4 .
+.It Fl o Ic asis
+When quoting output, if not in EBCDIC mode and
+.Ic utf8\-mode
+is disabled, show C1 control characters
+.Dq as is ,
+that is, do not escape them.
+Use with codepages where the range 0x80..0x9F contains printable
+characters (such as 437, 850, 1252, etc. but not the ISO\ 8859
+series, for example).
 .It Fl o Ic bgnice
 Background jobs are run with lower priority.
 .It Fl o Ic braceexpand
@@ -4574,9 +4715,7 @@ and
 this autodetection feature is compiled in.
 As a side effect, setting this flag turns off the
 .Ic braceexpand
-and
-.Ic utf8\-mode
-flags, which can be turned back on manually, and
+flag, which can be turned back on manually, and
 .Pq unless both are set in the same command
 .Ic sh
 mode.
@@ -4672,13 +4811,6 @@ etc.
 .Pq Ar number No defaults to 1
 are renamed to 1, 2, etc.
 .Pp
-.It Ic sleep Ar seconds
-.Pq regular , needs Xr select 2
-Suspends execution for a minimum of the
-.Ar seconds
-(specified as positive decimal value with an optional fractional part).
-Signal delivery may continue execution earlier.
-.Pp
 .It Ic smores Op Ar
 .Pq Li dot.mkshrc No function
 Simple pager:
@@ -5096,8 +5228,7 @@ would be interpreted as command.
 .No \*(Ba Fl R Ns Op Ar n
 .No \*(Ba Fl Z Ns Op Ar n Oc
 .Op Fl i Ns Op Ar n
-.Oo Ar name
-.Op Ns = Ns Ar value
+.Oo Ar name Ns Op = Ns Ar value
 .Ar ... Oc
 .Xc
 .It Xo
@@ -5405,6 +5536,12 @@ Limit the size of
 message queues to
 .Ar n
 bytes.
+.It Fl R Ar n
+.Pq Cm Linux
+Limit the CPU time slice a real-time process can use before
+performing a blocking syscall to
+.Ar n
+milliseconds.
 .It Fl r Ar n
 .Pq Cm AIX
 Limit the number of threads per process to
@@ -5907,21 +6044,28 @@ command.
 .Pp
 The following is a list of available editing commands.
 Each description starts with the name of the command,
-suffixed with a colon;
-an
+suffixed with a colon; a
 .Op Ar n
 (if the command can be prefixed with a count); and any keys the command is
 bound to by default, written using caret notation
-e.g. the ASCII Esc character is written as \*(ha[.
-These control sequences are not case sensitive.
+(e.g. the ASCII Esc character is written as
+.Li \*(ha[ )
+or terminal-specific indications.
 A count prefix for a command is entered using the sequence
 .Pf \*(ha[ Ns Ar n ,
 where
 .Ar n
-is a sequence of 1 or more digits.
+is one or more digits.
 Unless otherwise specified, if a count is
 omitted, it defaults to 1.
 .Pp
+Bigwords, as used below, are separated by spaces or tabs;
+words consist of alphanumerics, underscore
+.Pq Ql _
+or dollar sign
+.Pq Ql $
+characters.
+.Pp
 Note that editing command names are used only with the
 .Ic bind
 command.
@@ -5944,8 +6088,13 @@ Emacs key bindings:
 Abort the current command, save it to the history, empty the line buffer and
 set the exit state to interrupted.
 .It auto\-insert: Op Ar n
+.Pq Most ordinary characters are bound to this command.
 Simply causes the character to appear as literal input.
-Most ordinary characters are bound to this.
+.It Xo backward\-bigword:
+.Op Ar n
+.No \*(ha[B
+.Xc
+Moves the cursor backward to the beginning of the bigword.
 .It Xo backward\-char:
 .Op Ar n
 .No \*(haB , \*(haXD , ANSI-CurLeft , PC-CurLeft
@@ -5957,19 +6106,21 @@ characters.
 .Op Ar n
 .No \*(ha[b , ANSI-Ctrl-CurLeft , ANSI-Alt-CurLeft
 .Xc
-Moves the cursor backward to the beginning of the word; words consist of
-alphanumerics, underscore
-.Pq Ql _
-and dollar sign
-.Pq Ql $
-characters.
+Moves the cursor backward to the beginning of the word.
 .It beginning\-of\-history: \*(ha[\*(Lt
 Moves to the beginning of the history.
 .It beginning\-of\-line: \*(haA, ANSI-Home, PC-Home
 Moves the cursor to the beginning of the edited input line.
+.It Xo capitalise\-bigword:
+.Op Ar n
+.No \*(ha[C
+.Xc
+Uppercase the first character in the next
+.Ar n
+bigwords as below.
 .It Xo capitalise\-word:
 .Op Ar n
-.No \*(ha[C , \*(ha[c
+.No \*(ha[c
 .Xc
 Uppercase the first ASCII character in the next
 .Ar n
@@ -6013,6 +6164,20 @@ match as in the
 .Ic complete
 command above.
 Note that \*(haI is usually generated by the Tab (tabulator) key.
+.It Xo delete\-bigword\-backward:
+.Op Ar n
+.No \*(ha[H
+.Xc
+Deletes
+.Ar n
+bigwords before the cursor.
+.It Xo delete\-bigword\-forward:
+.Op Ar n
+.No \*(ha[D
+.Xc
+Deletes characters after the cursor up to the end of
+.Ar n
+bigwords.
 .It Xo delete\-char\-backward:
 .Op Ar n
 .No ERASE Pq \*(haH ,
@@ -6060,9 +6225,16 @@ is not useful until either
 or
 .Ic up\-history
 has been performed.
+.It Xo downcase\-bigword:
+.Op Ar n
+.No \*(ha[L
+.Xc
+Lowercases the next
+.Ar n
+bigwords.
 .It Xo downcase\-word:
 .Op Ar n
-.No \*(ha[L , \*(ha[l
+.No \*(ha[l
 .Xc
 Lowercases the next
 .Ar n
@@ -6113,6 +6285,13 @@ Appends a
 to the current word and replaces the word with the result of performing file
 globbing on the word.
 If no files match the pattern, the bell is rung.
+.It Xo forward\-bigword:
+.Op Ar n
+.No \*(ha[F
+.Xc
+Moves the cursor forward to the end of the
+.Ar n Ns th
+bigword.
 .It Xo forward\-char:
 .Op Ar n
 .No \*(haF , \*(haXC , ANSI-CurRight , PC-CurRight
@@ -6137,8 +6316,11 @@ Goes to history number
 .No KILL Pq \*(haU
 .Xc
 Deletes the entire input line.
-.It kill\-region: \*(haW
+.It kill\-region: \*(ha[\*(haW
 Deletes the input between the cursor and the mark.
+Note: this used to be bound to \*(haW like in Emacs, which is usually taken by
+.Dv WERASE
+though, so it was moved.
 .It Xo kill\-to\-eol:
 .Op Ar n
 .No \*(haK
@@ -6181,15 +6363,18 @@ This does nothing.
 Introduces a 2-character command sequence.
 .It prefix\-2: \*(haX , \*(ha[[ , \*(ha[O
 Introduces a multi-character command sequence.
-.It Xo prev\-hist\-word:
+.It prefix\-3: \*(ha@
+Introduces a PC keyboard scancode.
+.It Xo prev\-hist\-bigword:
 .Op Ar n
 .No \*(ha[. , \*(ha[_
 .Xc
-The last word or, if given, the
-.Ar n Ns th
-word (zero-based) of the previous (on repeated execution, second-last,
-third-last, etc.) command is inserted at the cursor.
-Use of this editing command trashes the mark.
+If no count is given, the last bigword, otherwise the
+.No ( Ar n Ns +1)th
+bigword of the previous line is inserted at the cursor,
+and the mark is set to the beginning of the inserted word.
+When invoked repeatedly, the inserted text is replaced by the corresponding
+bigword from the second-last, third-last, etc. line.
 .It quote: \*(ha\*(ha , \*(haV
 The following character is taken literally rather than as an editing command.
 .It quote\-region: \*(ha[Q
@@ -6219,7 +6404,7 @@ The internal history list is searched
 backwards for commands matching the input.
 An initial
 .Ql \*(ha
-in the search string anchors the search.
+in the search string anchors the search at the beginning of the line.
 The escape key will leave search mode.
 Other commands, including sequences of escape as
 .Ic prefix\-1
@@ -6227,31 +6412,33 @@ followed by a
 .Ic prefix\-1
 or
 .Ic prefix\-2
-key will be executed after leaving search mode.
+key, will be executed after leaving search mode.
 The
 .Ic abort Pq \*(haG
-command will restore the input line before search started.
+command will restore the input line from before search started.
 Successive
 .Ic search\-history
-commands continue searching backward to the next previous occurrence of the
-pattern.
+commands continue searching backward to the following previous occurrence
+of the pattern.
 The history buffer retains only a finite number of lines; the oldest
 are discarded as necessary.
-.It search\-history\-up: ANSI-PgUp, PC-PgUp
-Search backwards through the history buffer for commands whose beginning match
-the portion of the input line before the cursor.
-When used on an empty line, this has the same effect as
-.Ic up\-history .
 .It search\-history\-down: ANSI-PgDn, PC-PgDn
-Search forwards through the history buffer for commands whose beginning match
+Search forwards (this command is only useful after an
+.Ic up\-history ,
+.Ic search\-history\-up
+or
+.Ic search\-history )
+through the history buffer for commands whose beginning matches
 the portion of the input line before the cursor.
 When used on an empty line, this has the same effect as
 .Ic down\-history .
-This is only useful after an
-.Ic up\-history ,
-.Ic search\-history
-or
-.Ic search\-history\-up .
+.It search\-history\-up: ANSI-PgUp, PC-PgUp
+Search backwards through the history buffer for commands whose beginning
+matches the portion of the input line before the cursor.
+When used on an empty line, this has the same effect as
+.Ic up\-history .
+.It set\-arg: \*(ha[0 .. \*(ha[9
+Mapped to begin prefixing a count to a command.
 .It set\-mark\-command: \*(ha[ Ns Aq space
 Set the mark at the cursor position.
 .It transpose\-chars: \*(haT
@@ -6267,9 +6454,16 @@ character to the right.
 Scrolls the history buffer backward
 .Ar n
 lines (earlier).
+.It Xo upcase\-bigword:
+.Op Ar n
+.No \*(ha[U
+.Xc
+Uppercase the next
+.Ar n
+bigwords.
 .It Xo upcase\-word:
 .Op Ar n
-.No \*(ha[U , \*(ha[u
+.No \*(ha[u
 .Xc
 Uppercase the next
 .Ar n
@@ -6279,6 +6473,8 @@ Display the version of
 .Nm mksh .
 The current edit buffer is restored as soon as a key is pressed.
 The restoring keypress is processed, unless it is a space.
+.It vt100\-hack: \*(ha[[1
+Mapped to internally represent some longer key sequences.
 .It yank: \*(haY
 Inserts the most recently killed text string at the current cursor position.
 .It yank\-pop: \*(ha[y
@@ -6289,7 +6485,7 @@ replaces the inserted text string with t
 .Pp
 The tab completion escapes characters the same way as the following code:
 .Bd -literal
-print \-nr \-\- "${x@/[\e"\-\e$\e&\-*:\-?[\e\e\e`\e{\-\e}${IFS\-$\*(aq \et\en\*(aq}]/\e\e$KSH_MATCH}"
+print \-nr \-\- "${x@/[\e"\-\e$\e&\-*:\-?[\e\e\e\`\e{\-\e\*(TI${IFS\-$\*(aq \et\en\*(aq}]/\e\e$KSH_MATCH}"
 .Ed
 .Ss Vi editing mode
 .Em Note:
@@ -7064,8 +7260,10 @@ and wraparound defined, even (defying PO
 .Pp
 .Nm mksh
 currently uses OPTU-16 internally, which is the same as UTF-8 and CESU-8
-with 0000..FFFD being valid codepoints; raw octets are mapped into the
-PUA range EF80..EFFF, which is assigned by CSUR for this purpose.
+with 0000..FFFD being valid codepoints; raw octets map to U+EF80..U+EFFF
+for releases before R60, U-00200080..U-002000FF for R60 onwards.
+.Em Future compatibility note :
+there's work underway to use full 21-bit UTF-8 in mksh R60 or so.
 .Sh BUGS
 Suspending (using \*(haZ) pipelines like the one below will only suspend
 the currently running part of the pipeline; in this example,
@@ -7089,9 +7287,9 @@ for the in-memory portion of the history
 .Xr memmove 3 .
 .Pp
 This document attempts to describe
-.Nm mksh\ R59c
+.Nm mksh\ R59-CURRENT
 and up,
-.\" with vendor patches from insert-your-name-here,
+with vendor patches from Debian,
 compiled without any options impacting functionality, such as
 .Dv MKSH_SMALL ,
 when not called as
@@ -7107,13 +7305,7 @@ Please report bugs in
 .Nm
 to the public development mailing list at
 .Aq Mt miros\-mksh@mirbsd.org
-(please note the EU-DSGVO/GDPR notice on
-.Pa http://www.mirbsd.org/rss.htm#lists
-and in the SMTP banner!) or in the
+or, in the
 .Li \&#\&!/bin/mksh
-.Pq or Li \&#ksh
-IRC channel at
-.Pa irc.freenode.net
-.Pq Port 6697 SSL, 6667 unencrypted ,
-or at:
-.Pa https://launchpad.net/mksh
+channel, on IRC; for both, note the information at:
+.Pa http://www.mirbsd.org/mksh\-faq.htm#contact
--- mksh-59c.orig/mksh.faq
+++ mksh-59c/mksh.faq
@@ -1,4 +1,4 @@
-RCSID: $MirOS: src/bin/mksh/mksh.faq,v 1.10 2020/10/01 22:59:12 tg Exp $
+RCSID: $MirOS: src/bin/mksh/mksh.faq,v 1.28+locale-tracking 2021/10/03 23:38:13 tg Exp $
 ToC: spelling
 Title: How do you spell <tt>mksh</tt>? How do you pronounce it?
 
@@ -8,12 +8,15 @@ Title: How do you spell <tt>mksh</tt>? H
  initial lowercase letter</a>; this is important) or “MirBSD Korn Shell”,
  possibly with “the”.</p>
 <p>I usually pronounce it as “<span xml:lang="de-DE-1901">em-ka-es-ha</span>”,
- that is, the letters individually in my native German, or say “MirBSD Korn
- Shell”, although it is manageable, mostly for Slavic speakers, to actually
- say “mksh” as if it were a word ☺</p>
+ that is, the letters individually in my native German, emphasis on the
+ first syllable, or say “MirBSD Korn Shell”, although it is manageable,
+ mostly for Slavic speakers, to actually say “mksh” as if it were a word ☺</p>
 <p>Oh… I’ve run into this one, didn’t I? “MirBSD” is pronounced “<span
  xml:lang="de-DE-1901">Mir-Be-Es-De</span>” germanically, for anglophones
  “Mir-beas’tie” is fine.</p>
+<p>This translates well into other languages, such as <span
+ xml:lang="es">eme-ka-ese-ache</span> in Spanish, although English
+ speakers may still find “Mir-beastie korn shell” more palatable.</p>
 ----
 ToC: sowhatismksh
 Title: I’m a $OS (<i>Android, OS/2, …</i>) user, so what’s mksh?
@@ -98,8 +101,8 @@ Title: How does this relate to ksh or th
  getting close to, ksh88 compatibility.</p>
 <p>SKsh is an AmigaOS-specific Korn Shell-lookalike by Steve Koren.</p>
 <p>The <a href="@@RELPATH@@ksh-chan.htm">Homepage of the <tt>#ksh</tt>
- channel on Freenode IRC</a> contains more information about the Korn
- Shell in general and its flavours.</p>
+ channel on IRC</a> contains more information about the Korn Shell in
+ general and its flavours.</p>
 ----
 ToC: packaging
 Title: How should I package mksh? (common cases)
@@ -260,7 +263,7 @@ Title: My prompt is weird!
  (This was agreed upon as suggestion in a discussion between bash, zsh and
  Korn shell developers.) The feature set of different shells vastly differs
  and each shell should use its default PS1 or from its startup files.</li>
-<li><tt>$ENV</tt> <a href="#env">is set and/or <tt>export</tt>ed</a>.</li>
+<li><tt>$ENV</tt> <a href="#env">is set and probably <tt>export</tt>ed</a>.</li>
 <li>Your prompt is just “<tt># </tt>”: you’re entering a root shell, and
  <tt>$PS1</tt> does not contain the ‘#’ character, in which case the shell
  forces this prompt, making extra privileges obvious.</li>
@@ -284,7 +287,7 @@ Title: My prompt is weird!
 ToC: env
 Title: On startup files and <tt>$ENV</tt> across and detecting various shells
 
-Interactive shells look at <tt>~/.mkshrc</tt> (or <tt>/system/etc/mkshrc</tt>
+<p>Interactive shells look at <tt>~/.mkshrc</tt> (or <tt>/system/etc/mkshrc</tt>
 on Android and <tt>/etc/mkshrc</tt> on FreeWRT and OpenWrt) by default. This
 location can, however, be overridden by setting the <tt>ENV</tt> environment
 variable. (FreeBSD is rumoured to set it in their system profile.) It’s better
@@ -295,7 +298,30 @@ or “MIRBSD KSH” for mksh, “PD KSH
 for ksh93); <tt>$NETBSD_SHELL</tt> (NetBSD ash); <tt>POSH_VERSION</tt> (posh, a
 pdksh derivative); <tt>$SH_VERSION</tt> (“PD KSH” as sh), <tt>$YASH_VERSION</tt>
 (yash), <tt>$ZSH_VERSION</tt> (or if <tt>$VERSION</tt> begins with “zsh”); a <a
-href="@@RELPATH@@ksh-chan.htm#which-shell">list of more approaches</a> exists.
+href="@@RELPATH@@ksh-chan.htm#which-shell">list of more approaches</a> exists.</p>
+
+<p>Note that, in some scenarios, it might be very useful to actually set
+ <tt>$ENV</tt>: the regular interactive shell startup file lies in the
+ user’s home directory, relying on being copied from <tt>/etc/skel/</tt>
+ which normally is only done at user creation time. If mksh was installed
+ later, the user often won’t get it at all, and delivering updates is
+ challenging. One way of partially working around this is to ship an
+ <tt>/etc/skel/.mkshrc</tt> that reads <tt>/etc/mkshrc</tt> by default
+ (but the user can change it of course) and ship the <tt>dot.mkshrc</tt>
+ file as <tt>/etc/mkshrc</tt>, but that won’t fully help. This is where
+ <tt>$ENV</tt> comes into play:</p><ul>
+  <li>In <tt>/etc/profile</tt>, set <tt>ENV</tt> to a, say, <tt>shrc</tt>
+   file shipped in <tt>/etc/</tt> and export it.</li>
+  <li>In that new file, which must use only constructs compatible with
+   all shells, usually a subset of POSIX, read the various rc files
+   (<tt>.mkshrc</tt> for mksh, <tt>.kshrc</tt> for AT&amp;T ksh93, etc.)
+   from the user’s home if they exist, from <tt>/etc/skel/</tt> otherwise.</li>
+</ul><p>This may very well be <em>required</em> if the alternative would
+ be <a href="#ps1weird">to <del><tt>export PS1</tt></del>[sic!]</a>. <a
+  href="https://gitlab.alpinelinux.org/alpine/aports/-/issues/12398#note_146574"
+ >alpine Linux</a> encountered this very problem, and the linked post is
+ a (draft) solution using the <tt>$ENV</tt> method and looks at various
+ other shells’ startup file situation as well.</p>
 ----
 ToC: ctrl-x-e
 Title: Multiline command editing
@@ -320,6 +346,40 @@ Title: Multiline command editing
  nōn-zero (e.g. using jupp’s “abendjoe” command) to prevent execution.
  This is <em>really</em> useful to write ad-hōc scripts as well.</p>
 ----
+ToC: escaping
+Title: Some characters don’t display right
+
+<p>First, make sure that either you’re using a UTF-8 terminal and system
+ and the shell’s UTF-8 mode is on (<tt>set -U</tt>) or that you’re using
+ an 8-bit codepage/CCSID and the UTF-8 mode is off (<tt>set +U</tt>). If
+ you’re on an EBCDIC system ensure to pick a codepage that has a bijective
+ mapping to (Extended) ASCII and in which all necessary characters are
+ present, for example 1047. Furthermore ensure the compile-time and runtime
+ codepages match. (Other encoding schemes, e.g. DBCS or ISO-2022-JP, are
+ not supported.) This should already fix most relevant issues.</p>
+<p>If using an 8-bit coding system that (unlike e.g. ISO 8859 or EBCDIC)
+ does not assign control characters to “Extended ASCII” codepoints 0x80‥0x9F,
+ such as codepages 437, 850, 1252, … (usually on OS/2 or DOS-based systems),
+ enable the option <tt>set -o asis</tt> (new in R60); otherwise, they will
+ be escaped to avoid accidentally setting off terminal control sequences.</p>
+<p>Note that escaping of characters is, at runtime, dependent on whether the
+ shell was compiled for EBCDIC and/or <tt>utf8-mode</tt> and/or <tt>asis</tt>
+ are enabled, the latter being ignored if either of the former two are true
+ (in UTF-8 mode, UCS C1 codepoints are always escaped).</p>
+----
+ToC: carets
+Title: What’s with these ^Q, ^!Q and ^+Q (e.g. from tab completion)? \x80 too!
+
+The extended caret notation escapes characters that can be harmful for your
+terminal from being output as active control characters. This is dependent
+on the shell mode (see <a href="#escaping">above</a>. The caret (<tt>^</tt>)
+means Ctrl; <tt>^+</tt> is used to denote UTF-8 C1 control characters, while
+raw 8-bit C1 control characters use <tt>^!</tt>, and invalid UTF-8 sequences
+show up as <tt>\x</tt> in <tt>utf8-mode</tt>. The manpage also documents
+these (search for “caret”). Note that the <tt>bind</tt> utility and explicit
+parameter escaping also quote carets and backslashes with a backslash, while
+mere output (tab completion, input line editing) don’t.
+----
 ToC: ctrl-l-cls
 Title: ^L (Ctrl-L) does not clear the screen
 
@@ -329,9 +389,15 @@ Use ^[^L (Escape+Ctrl-L) or rebind it:<b
 ToC: ctrl-u-pico
 Title: ^U (Ctrl-U) clears the entire line
 
-If it should only delete the line up to the cursor, use:<br />
+If you want it to only delete the line up to the cursor, use:<br />
 <tt>bind -m ^U='^[0^K'</tt>
 ----
+ToC: ctrl-w-bash
+Title: ^W (Ctrl-W) deletes a word, not a bigword
+
+If you want it to delete more, with R60 you can use:<br />
+<tt>bind '^W=delete-bigword-backward'</tt>
+----
 ToC: cur-up-zsh
 Title: Cursor Up behaves differently from zsh
 
@@ -380,7 +446,7 @@ Title: What about programmable tab compl
 The shell itself provides static deterministic tab completion.
 However, you can use hooks like reprogramming the Tab key to a
 command line editor macro, and using the <tt>evaluate-region</tt>
-editor command (modulo a bugfix) together with <tt>quote-region</tt> and shell functions to
+editor command together with <tt>quote-region</tt> and shell functions to
 implement a programmable completion engine. Multiple people have
 been considering doing so in our IRC channel; we’ll hyperlink to
 these engines when they are available.
@@ -395,10 +461,22 @@ Title: How POSIX compliant is mksh? Also
  (<tt>set -o posix</tt>) explicitly, which also disables brace expansion upon
  being enabled (use <tt>set -o braceexpand</tt> to reenable if needed).</p>
 <p>For the purpose of POSIX, mksh supports only the <tt>C</tt> locale. mksh’s
- <tt>utf8-mode</tt> (which only supports the BMP (Basic Multilingual Plane) of
- UCS and maps raw octets into the U+EF80‥U+EFFF wide character range; see
- <tt>Arithmetic expressions</tt> in mksh(1) for details) <em>must</em> stay
- disabled in POSIX mode (it is disabled upon enabling POSIX mode in R56+).</p>
+ <tt>utf8-mode</tt> <em>must</em> stay disabled in POSIX mode (it was disabled
+ upon enabling POSIX mode in R56‥R59c but decoupled again with R59d).</p>
+<p>EBCDIC interacts with <tt>utf8-mode</tt> in a special way: UTF-EBCDIC is
+ not used by anyone, we cannot use UCS-2/4 in the shell, so “nega-UTF-8”, a
+ scheme in which UTF-8 calculations are done on the octets converted per the
+ current EBCDIC codepage to “extended ASCII”.</p>
+<p>The shell’s <tt>utf8-mode</tt> <em>before</em> mksh R60 supported only the
+ BMP (Basic Multilingual Plane) of UCS and mapped raw (extended ASCII) octets,
+ i.e. these which are not valid UTF-8 BMP codepoints) into the U+EF80‥U+EFFF
+ range, which is allocated at the CSUR for this purpose. (It otherwise lies in
+ the PUA; however, there is ambiguity if encountering those UTF-8-encoded, so
+ it changed for R60.) The <tt>Arithmetic expressions</tt> and <tt>CAVEATS</tt>
+ sections in mksh(1) contain more details about encoding and mapping.</p>
+<p>As of R60, <tt>utf8-mode</tt> maps “raw octets” to U-00200080‥U-002000FF,
+ which is outside the UCS and therefore collision-free. There’s work underway
+ to make the shell support the full 21-bit UCS range for R60.</p>
 <p class="boxhead">The following POSIX sh-compatible code toggles the
  <tt>utf8-mode</tt> option dependent on the current POSIX locale, for mksh
  to allow using the UTF-8 mode, within the constraints outlined above, in
@@ -413,8 +491,9 @@ Title: How POSIX compliant is mksh? Also
 		esac ;;
 	esac
  </pre>
-</div><p class="boxfoot">In near future, (UTF-8) locale tracking will
- be implemented, though.</p>
+</div><p class="boxfoot">This only applies to mksh before R60 without
+ locale tracking and is obsolete as of R60’s release, except for backwards
+ compatibility. <strong>This build of mksh already enables it.</strong></p>
 <p>The shell is pretty close to POSIX, when run as <tt>lksh -o posix</tt>
  under the "C" locale it is intended to match. It does not do everything
  like other POSIX-compatible or ‑compliant shells, though.</p>
@@ -532,6 +611,15 @@ This is because AT&amp;T ksh93 ships a p
 put this into your <tt>~/.mkshrc</tt>
 (note the space before the closing single quote)
 ----
+ToC: builtin-cat
+Title: Didn’t there used to be a cat(1) builtin?
+
+<p>Up to and including mksh R59c, we indeed shipped a built-in cat(1)
+ inside mksh; this was added originally because Android did not have
+ one <em>at all</em> (but they have since imported a BSD cat). While
+ it could speed up some sh scripts correct signal handling is hard to
+ get right, so (with regret) it was removed in 2021. 🙀</p>
+----
 ToC: builtin-rename
 Title: “rename” doesn’t work as expected!
 
@@ -539,6 +627,7 @@ Title: “rename” doesn’t work as ex
  thin wrapper around the rename(2) syscall. It receives two pathnames,
  source and destination where the first is then atomically renamed to
  the latter. It does not move, i.e. fails for different filesystems.</p>
+<p>The builtin may be absent if your OS doesn’t have rename(2), e.g. Xenix.</p>
 <p>The GNU package <tt>util-linux</tt> has a different <tt>rename</tt>
  command. If you wish to invoke an external utility (in favour over a
  builtin), you can use <tt>dot.mkshrc</tt>’s function <tt>enable</tt>
@@ -546,23 +635,39 @@ Title: “rename” doesn’t work as ex
 <pre>alias rename="$(whence -p rename)"</pre>
 ----
 ToC: builtin-sleep
-Title: “sleep” does not accept ‘m’ for minutes!
+Title: Didn’t there used to be a sleep(1) builtin?
 
-<p>mksh contains a <tt>sleep</tt> built-in utility, in order to be
- able to offer sub-second sleep to shell scripts for most platforms.
- (It does not exist if the platform lacks select(2) — which should
- be rare.)</p>
-<p>GNU coreutils contains a sleep implementation accepting suffixed
- numbers. If you wish to invoke an external utility (in favour over a
- builtin), you can use <tt>dot.mkshrc</tt>’s function <tt>enable</tt>
- or put something along the following lines into <tt>~/.mkshrc</tt>:</p>
-<pre>alias sleep="$(whence -p sleep)"</pre>
-<pre>timer() { sleep $(($1*60${2:++$2})); } # timer mins [secs]</pre>
-<pre>timer() {
-	local arg=${1/m/'*60+'}
-	[[ $arg = *+ ]] &amp;&amp; arg+=0
-	sleep $(($arg)
-}</pre>
+<p>Up to and including mksh R59c, we indeed shipped a subsecond-capable
+ select(2)-based built-in sleep(1). This got originally added because
+ too many platforms do not support sub-second sleep, which nowadays is
+ of less concern. It also led to users complaining about lack for system
+ *ahem* GNU extensions, but the cause of its demise is that getting signal
+ handling right, in a portable way and without too many syscalls (there’s
+ a threshold over which fork+exec is cheaper!), isn’t feasible if even at
+ all possible.</p>
+<p>The MirOS Project now ships <a href="@@RELPATH@@subprj.htm#sleep">a
+ portable sleep</a> which similarily is select(2)-based and capable of
+ subsecond sleep but in addition supports all GNU extensions related to
+ specifying the amount of time to sleep. It will work on <em>at least</em>
+ all platforms on which mksh had a builtin before. Please install this
+ if your operating system lacks a good enough sleep(1) utility.</p>
+<p>Note that, if your OS lacks select(2), you’ll lose out either way.
+ In that case, GNU coreutils’ sleep, which is built on older syscalls,
+ may work if the copyleft licence isn’t a showstopper for you.</p>
+----
+ToC: arith-import
+Title: Some integer variables are 0?
+
+<p class="boxhead">To mitigate potential exploits, variables imported
+ from the environment are not trusted in arithmetic context; that is…</p>
+<div class="boxtext">
+ <pre>
+	foo=1+1 mksh -c 'integer foo; print $foo'
+	foo=1+1 mksh -c 'integer foo=$foo; print $foo'
+ </pre>
+</div><p class="boxfoot">… will lose the value in the first line,
+ while the second line explicitly “untaints”, to use a Perl term,
+ the content. Purely numeric values will pass, though.</p>
 ----
 ToC: string-concat
 Title: “+=” behaves differently from other shells
@@ -635,18 +740,22 @@ Title: I use “set -eo pipefail” and
 ToC: faq
 Title: My question is not answered here!
 
-Do read the mksh(1) manual page. You might also wish to read the <a
- href="@@RELPATH@@ksh-chan.htm">homepage of the <tt>#ksh</tt> IRC channel
-on Freenode</a> which lists several resources for Korn or POSIX-compatible
-shells in general. Or, <a href="#contact">contact</a> us (developer and
-users), for example via IRC.
+Do read the mksh(1) and lksh(1) manual page. You might also wish to read the <a
+ href="@@RELPATH@@ksh-chan.htm">homepage of the <tt>#ksh</tt> IRC channel</a>
+which lists several resources for Korn or POSIX-compatible shells in general.
+Or, <a href="#contact">contact</a> us (developer and users).
 ----
 ToC: contact
-Title: How do I contact you (to say thanks)?
+Title: How do I contact you (to say thanks, for bugreports and questions)?
 
-You can say hi in the <tt>#!/bin/mksh</tt> channel on Freenode <a
- href="@@RELPATH@@irc.htm">IRC</a>, although a <a
- href="@@RELPATH@@danke.htm">donation</a> wouldn’t be amiss ☺ The <a
- href="http://www.mail-archive.com/miros-mksh@mirbsd.org/">mailing
-list</a> can also be used.
+<p>You can say hi in the <tt>#!/bin/mksh</tt> channel on <a
+ href="@@RELPATH@@irc.htm">IRC</a> (OFTC, for now), although… a
+ <a href="@@RELPATH@@danke.htm">donation</a> wouldn’t be amiss ☻
+<br />The <a href="@@RELPATH@@rss.htm#lists">mailing list</a> can also
+ be used for this. The <a href="#faq">extra resources</a> from the FAQ
+ entry just one above should also be considered ;-)</p>
+<p>If you insist on sending a bugreport, IRC and the mailing list are
+ great places for that; <a href="https://launchpad.net/mksh">Launchpad</a>,
+ an external gratis service provided by a company, can also be used if you
+ like web-based issue trackers better.</p>
 ----
--- mksh-59c.orig/os2.c
+++ mksh-59c/os2.c
@@ -32,7 +32,7 @@
 #include <unistd.h>
 #include <process.h>
 
-__RCSID("$MirOS: src/bin/mksh/os2.c,v 1.11 2020/10/01 21:13:45 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/os2.c,v 1.12 2021/07/30 02:58:07 tg Exp $");
 
 struct a_s_arg {
 	union {
@@ -113,7 +113,7 @@ response(int *argcp, const char ***argvp
 			line[0] = __KLIBC_ARG_NONZERO | __KLIBC_ARG_RESPONSE;
 			l = line + 1;
 			while (fgets(l, (filesize + 1) - (l - (line + 1)), f)) {
-				p = strchr(l, '\n');
+				p = ucstrchr(l, '\n');
 				if (p) {
 					/*
 					 * if a line ends with a backslash,
--- mksh-59c.orig/rlimits.opt
+++ mksh-59c/rlimits.opt
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 2013, 2015, 2019
+ * Copyright (c) 2013, 2015, 2019, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -21,7 +21,7 @@
  */
 
 @RLIMITS_DEFNS
-__RCSID("$MirOS: src/bin/mksh/rlimits.opt,v 1.5 2020/07/24 20:11:18 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/rlimits.opt,v 1.6 2021/01/10 18:44:06 tg Exp $");
 @RLIMITS_ITEMS
 #define FN(lname,lid,lfac,lopt) (const struct limits *)(&rlimits_ ## lid),
 @@
@@ -94,6 +94,9 @@ FN("threadsperprocess", RLIMIT_THREADS,
 >e|RLIMIT_NICE
 FN("maxnice", RLIMIT_NICE, 1
 
+>R|RLIMIT_RTTIME
+FN("rttime(ms)", RLIMIT_RTTIME, 1
+
 >r|RLIMIT_RTPRIO
 FN("maxrtprio", RLIMIT_RTPRIO, 1
 
--- mksh-59c.orig/sh.h
+++ mksh-59c/sh.h
@@ -11,7 +11,7 @@
 /*-
  * Copyright © 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *	       2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
- *	       2019, 2020
+ *	       2019, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -30,6 +30,12 @@
  * of said person’s immediate fault when using the work as intended.
  */
 
+#ifdef MKSH_USE_AUTOCONF_H
+/* things that “should” have been on the command line */
+#include "autoconf.h"
+#undef MKSH_USE_AUTOCONF_H
+#endif
+
 #ifdef __dietlibc__
 /* XXX imake style */
 #define _BSD_SOURCE	/* live, BSD, live❣ */
@@ -39,14 +45,17 @@
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
-#if HAVE_BOTH_TIME_H
+#if HAVE_BOTH_TIME_H && HAVE_SELECT_TIME_H
 #include <sys/time.h>
 #include <time.h>
-#elif HAVE_SYS_TIME_H
+#elif HAVE_SYS_TIME_H && HAVE_SELECT_TIME_H
 #include <sys/time.h>
 #elif HAVE_TIME_H
 #include <time.h>
 #endif
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
 #include <sys/ioctl.h>
 #if HAVE_SYS_SYSMACROS_H
 #include <sys/sysmacros.h>
@@ -62,6 +71,9 @@
 #endif
 #include <sys/stat.h>
 #include <sys/wait.h>
+#ifdef DEBUG
+#include <assert.h>
+#endif
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -193,9 +205,9 @@
 #endif
 
 #ifdef EXTERN
-__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.904 2020/10/31 03:53:06 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh.h,v 1.954 2021/10/11 22:35:23 tg Exp $");
 #endif
-#define MKSH_VERSION "R59 2020/10/31"
+#define MKSH_VERSION "R59 2021/10/15"
 
 /* arithmetic types: C implementation */
 #if !HAVE_CAN_INTTYPES
@@ -207,6 +219,16 @@ typedef u_int32_t uint32_t;
 #endif
 #endif
 
+/* shell types */
+typedef unsigned char kby;		/* byte */
+typedef unsigned int kui;		/* wchar; kby or EOF; etc. */
+typedef unsigned long kul;		/* long, arithmetic */
+typedef signed long ksl;		/* signed long, arithmetic */
+
+#define KBY(c)	((kby)(c))		/* byte, truncated if necessary */
+#define KBI(c)	((kui)(kby)(c))		/* byte as u_int, truncated */
+#define KUI(u)	((kui)(u))		/* int as u_int, not truncated */
+
 /* arithmetic types: shell arithmetics */
 #ifdef MKSH_LEGACY_MODE
 /*
@@ -238,15 +260,6 @@ typedef unsigned char mksh_bool;
 /* make any-type into bool or short */
 #define tobool(cond)	((cond) ? true : false)
 
-/* char (octet) type: C implementation */
-#if !HAVE_CAN_INT8TYPE
-#if !HAVE_CAN_UCBINT8
-typedef unsigned char uint8_t;
-#else
-typedef u_int8_t uint8_t;
-#endif
-#endif
-
 /* other standard types */
 
 #if !HAVE_SIG_T
@@ -278,12 +291,16 @@ typedef MKSH_TYPEDEF_SSIZE_T ssize_t;
 #undef PRINT		/* LynxOS defines that somewhere */
 #undef flock		/* SCO UnixWare defines that to flock64 but ENOENT */
 
-
 #ifndef MKSH_INCLUDES_ONLY
 
 /* compile-time assertions */
 #define cta(name,expr)	struct cta_ ## name { char t[(expr) ? 1 : -1]; }
 
+/* counts the value bits when given inttype_MAX as argument */
+#define IMAX_BITS(m) ((m) / ((m) % 255 + 1) / 255 % 255 * 8 + 7 - \
+	    86 / ((m) % 255 + 12))
+/* taken from comp.lang.c by Hallvard B Furuseth */
+
 /* EBCDIC fun */
 
 /* see the large comment in shf.c for an EBCDIC primer */
@@ -303,8 +320,8 @@ typedef MKSH_TYPEDEF_SSIZE_T ssize_t;
 
 /* extra types */
 
-/* getrusage does not exist on OS/2 kLIBC */
-#if !HAVE_GETRUSAGE && !defined(__OS2__)
+/* getrusage does not exist on OS/2 kLIBC and is stubbed on SerenityOS */
+#if !HAVE_GETRUSAGE
 #undef rusage
 #undef RUSAGE_SELF
 #undef RUSAGE_CHILDREN
@@ -316,6 +333,10 @@ struct rusage {
 	struct timeval ru_utime;
 	struct timeval ru_stime;
 };
+
+extern int ksh_getrusage(int, struct rusage *);
+#else
+#define ksh_getrusage getrusage
 #endif
 
 /* extra macros */
@@ -360,6 +381,7 @@ struct rusage {
 #endif
 #endif
 #endif
+
 #ifndef SIZE_MAX
 #ifdef SIZE_T_MAX
 #define SIZE_MAX	SIZE_T_MAX
@@ -367,6 +389,18 @@ struct rusage {
 #define SIZE_MAX	((size_t)-1)
 #endif
 #endif
+
+/* if this breaks, see sh.h,v 1.954 commit message and diff */
+#ifndef _POSIX_VDISABLE
+/* Linux klibc lacks this definition */
+#define _POSIX_VDISABLE 0xFFU /* unsigned (for cc_t) default (BSD) value */
+#endif
+#define KSH_ISVDIS(x,d)	((x) == _POSIX_VDISABLE ? (d) : KBI(x))
+#define KSH_DOVDIS(x)	(x) = _POSIX_VDISABLE
+
+#ifndef S_ISCHR
+#define S_ISCHR(m)	((m & 0170000) == 0020000)
+#endif
 #ifndef S_ISLNK
 #define S_ISLNK(m)	((m & 0170000) == 0120000)
 #endif
@@ -380,7 +414,6 @@ struct rusage {
 #define DEFFILEMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
 #endif
 
-
 /* determine ksh_NSIG: first, use the traditional definitions */
 #undef ksh_NSIG
 #if defined(NSIG)
@@ -427,6 +460,18 @@ struct rusage {
 
 #define ksh_sigmask(sig) (((sig) < 1 || (sig) > 127) ? 255 : 128 + (sig))
 
+#if HAVE_SIGACTION
+typedef struct sigaction ksh_sigsaved;
+#define ksh_sighandler(saved) (saved.sa_handler)
+void ksh_sigrestore(int, ksh_sigsaved *);
+#else
+typedef sig_t ksh_sigsaved;
+#define ksh_sighandler(saved) (saved)
+#define ksh_sigrestore(s,svp) ksh_sigset((s), *(svp), NULL)
+#endif
+
+/* contract: masks the signal, may restart, not oneshot */
+void ksh_sigset(int, sig_t, ksh_sigsaved *);
 
 /* OS-dependent additions (functions, variables, by OS) */
 
@@ -467,13 +512,10 @@ extern int flock(int, int);
 #define mksh_TIME(tv) gettimeofday(&(tv), NULL)
 #endif
 
-#if !HAVE_GETRUSAGE
-extern int getrusage(int, struct rusage *);
-#endif
-
 #if !HAVE_MEMMOVE
-/* we assume either memmove or bcopy exist, at the moment */
-#define memmove(dst,src,len)	bcopy((src), (dst), (len))
+#undef memmove
+#define memmove rpl_memmove
+void *rpl_memmove(void *, const void *, size_t);
 #endif
 
 #if !HAVE_REVOKE_DECL
@@ -553,7 +595,6 @@ extern int __cdecl setegid(gid_t);
 #define KSH_VTAB	11
 #endif
 
-
 /* some useful #defines */
 #ifdef EXTERN
 # define E_INIT(i) = i
@@ -565,6 +606,10 @@ extern int __cdecl setegid(gid_t);
 
 /* define bit in flag */
 #define BIT(i)		(1U << (i))
+/* check bit(s) */
+#define HAS(v,f)	(((v) & (f)) == (f))
+#define IS(v,f,t)	(((v) & (f)) == (t))
+/* array sizing */
 #define NELEM(a)	(sizeof(a) / sizeof((a)[0]))
 
 /*
@@ -621,44 +666,26 @@ union mksh_ccphack {
 	const char **ro;
 };
 
-/*
- * Evil hack since casting uint to sint is implementation-defined
- */
-typedef union {
-	mksh_ari_t i;
-	mksh_uari_t u;
-} mksh_ari_u;
-
 /* for const debugging */
-#if defined(DEBUG) && defined(__GNUC__) && !defined(__ICC) && \
-    !defined(__INTEL_COMPILER) && !defined(__SUNPRO_C)
+#if defined(DEBUG)
 char *ucstrchr(char *, int);
-char *ucstrstr(char *, const char *);
+const char *cstrchr(const char *, int);
 #undef strchr
-#define strchr ucstrchr
-#define strstr ucstrstr
-#define cstrchr(s,c) ({			\
-	union mksh_cchack in, out;	\
-					\
-	in.ro = (s);			\
-	out.rw = ucstrchr(in.rw, (c));	\
-	(out.ro);			\
-})
-#define cstrstr(b,l) ({			\
-	union mksh_cchack in, out;	\
-					\
-	in.ro = (b);			\
-	out.rw = ucstrstr(in.rw, (l));	\
-	(out.ro);			\
-})
-#define vstrchr(s,c)	(cstrchr((s), (c)) != NULL)
-#define vstrstr(b,l)	(cstrstr((b), (l)) != NULL)
-#else /* !DEBUG, !gcc */
+#define strchr		poisoned_strchr
+#else
+#define ucstrchr(s,c)	strchr((s), (c))
 #define cstrchr(s,c)	((const char *)strchr((s), (c)))
+#endif
+#define vstrchr(s,c)	(cstrchr((s), (c)) != NULL)
+#if defined(DEBUG) || !HAVE_STRSTR
+char *ucstrstr(char *, const char *);
+const char *cstrstr(const char *, const char *);
+#define strstr		poisoned_strstr
+#else
+#define ucstrstr(s,c)	strstr((s), (c))
 #define cstrstr(s,c)	((const char *)strstr((s), (c)))
-#define vstrchr(s,c)	(strchr((s), (c)) != NULL)
-#define vstrstr(b,l)	(strstr((b), (l)) != NULL)
 #endif
+#define vstrstr(b,l)	(cstrstr((b), (l)) != NULL)
 
 #if defined(DEBUG) || defined(__COVERITY__)
 #ifndef DEBUG_LEAKS
@@ -666,8 +693,8 @@ char *ucstrstr(char *, const char *);
 #endif
 #endif
 
-#if (!defined(MKSH_BUILDMAKEFILE4BSD) && !defined(MKSH_BUILDSH)) || (MKSH_BUILD_R != 593)
-#error Must run Build.sh to compile this.
+#if (!defined(MKSH_BUILDMEAT)) || (MKSH_BUILD_R != 599)
+#error Use the documented way to build this.
 extern void thiswillneverbedefinedIhope(void);
 int
 im_sorry_dave(void)
@@ -680,10 +707,6 @@ im_sorry_dave(void)
 /* use this ipv strchr(s, 0) but no side effects in s! */
 #define strnul(s)	((s) + strlen((const void *)s))
 
-#define utf_ptradjx(src,dst) do {					\
-	(dst) = (src) + utf_ptradj(src);				\
-} while (/* CONSTCOND */ 0)
-
 #if defined(MKSH_SMALL) && !defined(MKSH_SMALL_BUT_FAST)
 #define strdupx(d,s,ap) do {						\
 	(d) = strdup_i((s), (ap));					\
@@ -717,6 +740,19 @@ im_sorry_dave(void)
 	(d) = strdup_dst;						\
 } while (/* CONSTCOND */ 0)
 #endif
+#define strnbdupx(d,s,n,ap,b) do {					\
+	const char *strdup_src = (const void *)(s);			\
+	char *strdup_dst = NULL;					\
+									\
+	if (strdup_src != NULL) {					\
+		size_t strndup_len = (n);				\
+		strdup_dst = strndup_len < sizeof(b) ? (b) :		\
+		    alloc(strndup_len + 1, (ap));			\
+		memcpy(strdup_dst, strdup_src, strndup_len);		\
+		strdup_dst[strndup_len] = '\0';				\
+	}								\
+	(d) = strdup_dst;						\
+} while (/* CONSTCOND */ 0)
 #define strdup2x(d,s1,s2) do {						\
 	const char *strdup_src = (const void *)(s1);			\
 	const char *strdup_app = (const void *)(s2);			\
@@ -744,6 +780,7 @@ im_sorry_dave(void)
 	}								\
 	(d) = strdup_dst;						\
 } while (/* CONSTCOND */ 0)
+#define memstr(d,s) memcpy((d), (s), sizeof(s))
 
 #ifdef MKSH_SMALL
 #ifndef MKSH_NOPWNAM
@@ -762,14 +799,38 @@ im_sorry_dave(void)
 #define MKSH_UNEMPLOYED		1
 #endif
 
-#define NUFILE		32	/* Number of user-accessible files */
-#define FDBASE		10	/* First file usable by Shell */
+/* savedfd data type */
+typedef kby ksh_fdsave;
+/* savedfd “index is closed” mask */
+#define FDICLMASK	((ksh_fdsave)0x80U)
+/* savedfd “fd number” mask */
+#define FDNUMMASK	((ksh_fdsave)0x7FU)
+/* savedfd fd numbers are ≥ FDBASE */
+/* savedfd “not saved” number: 0 */
+/* savedfd “saved is closed” or savefd error indicator number */
+#define FDCLOSED	((ksh_fdsave)0x01U)
+/* savefd() to savedfd mapper */
+#define FDSAVE(i,sfd)	do {					\
+	int FDSAVEsavedfd = (sfd);				\
+	e->savedfd[i] = FDSAVEsavedfd < FDBASE ? FDCLOSED :	\
+	    /* ≤ FDMAXNUM checked in savefd() already */	\
+	    (ksh_fdsave)(FDSAVEsavedfd & FDNUMMASK);		\
+} while (/* CONSTCOND */ 0)
+/* savedfd to restfd mapper */
+#define FDSVNUM(ep,i)	((kui)((ep)->savedfd[i] & FDNUMMASK))
+#define SAVEDFD(ep,i)	(FDSVNUM(ep, i) == (kui)FDCLOSED ? \
+			    -1 : (int)FDSVNUM(ep, i))
+/* first fd number usable by the shell for its own purposes */
+#define FDBASE		10
+/* … and last one */
+#define FDMAXNUM	127 /* 0x7FU, cf. FDNUMMASK */
+/* number of user-accessible file descriptors */
+#define NUFILE		10
 
 /*
  * simple grouping allocator
  */
 
-
 /* 0. OS API: where to get memory from and how to free it (grouped) */
 
 /* malloc(3)/realloc(3) -> free(3) for use by the memory allocator */
@@ -792,7 +853,6 @@ im_sorry_dave(void)
 #define free_gnu_gcdn(p)	free(p)
 #endif
 
-
 /* 1. internal structure */
 struct lalloc_common {
 	struct lalloc_common *next;
@@ -818,7 +878,6 @@ struct lalloc_item {
 /* 3. group structure */
 typedef struct lalloc_common Area;
 
-
 EXTERN Area aperm;		/* permanent object space */
 #define APERM	&aperm
 #define ATEMP	&e->area
@@ -839,6 +898,8 @@ enum sh_flag {
  * parsing & execution environment
  *
  * note that kshlongjmp MUST NOT be passed 0 as second argument!
+ *
+ * kshsetjmp() is to *not* save (and kshlongjmp() to not restore) signals!
  */
 #ifdef MKSH_NO_SIGSETJMP
 #define kshjmp_buf	jmp_buf
@@ -861,13 +922,13 @@ extern struct env {
 	Area area;		/* temporary allocation area */
 	struct env *oenv;	/* link to previous environment */
 	struct block *loc;	/* local variables and functions */
-	short *savefd;		/* original redirected fds */
+	ksh_fdsave *savedfd;	/* original fds for redirected fds */
 	struct temp *temps;	/* temp files */
 	/* saved parser recursion state */
 	struct yyrecursive_state *yyrecursive_statep;
 	kshjmp_buf jbuf;	/* long jump back to env creator */
-	uint8_t type;		/* environment type - see below */
-	uint8_t flags;		/* EF_* */
+	kby type;		/* environment type - see below */
+	kby flags;		/* EF_* */
 } *e;
 
 /* struct env.type values */
@@ -912,9 +973,9 @@ EXTERN int exstat;		/* exit status */
 EXTERN int subst_exstat;	/* exit status of last $(..)/`..` */
 EXTERN struct tbl *vp_pipest;	/* global PIPESTATUS array */
 EXTERN short trap_exstat;	/* exit status before running a trap */
-EXTERN uint8_t trap_nested;	/* running nested traps */
-EXTERN uint8_t shell_flags[FNFLAGS];
-EXTERN uint8_t baseline_flags[FNFLAGS
+EXTERN kby trap_nested;		/* running nested traps */
+EXTERN kby shell_flags[FNFLAGS];
+EXTERN kby baseline_flags[FNFLAGS
 #if !defined(MKSH_SMALL) || defined(DEBUG)
     + 1
 #endif
@@ -939,7 +1000,6 @@ EXTERN struct {
 #define kshegid		rndsetupstate.kshegid_v
 #define kshppid		rndsetupstate.kshppid_v
 
-
 /* option processing */
 #define OF_CMDLINE	0x01	/* command line */
 #define OF_SET		0x02	/* set builtin */
@@ -970,7 +1030,6 @@ EXTERN char null[] E_INIT("");
 #endif
 
 #ifndef HAVE_STRING_POOLING /* helpers for pooled strings */
-EXTERN const char T4spaces[] E_INIT("    ");
 #define T1space (Treal_sp2 + 5)
 #define Tcolsp (Tf_sD_ + 2)
 #define TC_IFSWS (TinitIFS + 4)
@@ -985,8 +1044,8 @@ EXTERN const char Tbracket[] E_INIT("[")
 EXTERN const char Tbadnum[] E_INIT("bad number");
 #define Tbadsubst (Tfg_badsubst + 10)
 EXTERN const char Tbg[] E_INIT("bg");
-EXTERN const char Tbad_bsize[] E_INIT("bad shf/buf/bsize");
-#define Tbsize (Tbad_bsize + 12)
+EXTERN const char Tbad_buf[] E_INIT("%s: buf %zX len %zd");
+EXTERN const char Tbad_flags[] E_INIT("%s: flags 0x%08X");
 EXTERN const char Tbad_sig_ss[] E_INIT("%s: bad signal '%s'");
 #define Tbad_sig_s (Tbad_sig_ss + 4)
 EXTERN const char Tsgbreak[] E_INIT("*=break");
@@ -996,12 +1055,11 @@ EXTERN const char T__builtin[] E_INIT("-
 #define Tbuiltin (T__builtin + 2)
 EXTERN const char Toomem[] E_INIT("can't allocate %zu data bytes");
 EXTERN const char Tcant_cd[] E_INIT("restricted shell - can't cd");
-EXTERN const char Tcant_find[] E_INIT("can't find");
-EXTERN const char Tcant_open[] E_INIT("can't open");
-#define Tbytes (Toomem + 24)
-EXTERN const char Tbcat[] E_INIT("!cat");
-#define Tcat (Tbcat + 1)
+EXTERN const char Tcant_filesub[] E_INIT("can't open $(<...) file");
 #define Tcd (Tcant_cd + 25)
+EXTERN const char Tchvt2[] E_INIT("chvt: %s: %s");
+EXTERN const char Tchvt_failed[] E_INIT("chvt: %s failed");
+EXTERN const char Tcloexec_failed[] E_INIT("failed to %s close-on-exec flag for fd#%d: %s");
 #define T_command (T_funny_command + 9)
 #define Tcommand (T_funny_command + 10)
 EXTERN const char Tsgcontinue[] E_INIT("*=continue");
@@ -1018,8 +1076,7 @@ EXTERN const char Textproc[] E_INIT("ext
 EXTERN const char Tfalse[] E_INIT("false");
 EXTERN const char Tfg[] E_INIT("fg");
 EXTERN const char Tfg_badsubst[] E_INIT("fileglob: bad substitution");
-#define Tfile (Tfile_fd + 20)
-EXTERN const char Tfile_fd[] E_INIT("function definition file");
+#define Tfile (Tcant_filesub + 19)
 EXTERN const char TFPATH[] E_INIT("FPATH");
 EXTERN const char T_function[] E_INIT(" function");
 #define Tfunction (T_function + 1)
@@ -1040,11 +1097,12 @@ EXTERN const char Tnot_found_s[] E_INIT(
 #define Tnot_found (Tnot_found_s + 3)
 #define Tnot_started (Tjob_not_started + 4)
 #define TOLDPWD (Tno_OLDPWD + 3)
-#define Topen (Tcant_open + 6)
+EXTERN const char Topen[] E_INIT("open");
+EXTERN const char Ttooearly[] E_INIT("too early%s");
 EXTERN const char To_o_reset[] E_INIT(" -o .reset");
 #define To_reset (To_o_reset + 4)
 #define TPATH (TFPATH + 1)
-#define Tpo (Tset_po + 4)
+#define Tpo (T_set_po + 5)
 #define Tpv (TpVv + 1)
 EXTERN const char TpVv[] E_INIT("Vpv");
 #define TPWD (Tno_OLDPWD + 6)
@@ -1059,11 +1117,12 @@ EXTERN const char TREPLY[] E_INIT("REPLY
 EXTERN const char Treq_arg[] E_INIT("requires an argument");
 EXTERN const char Tselect[] E_INIT("select");
 #define Tset (Tf_parm + 18)
-EXTERN const char Tset_po[] E_INIT("set +o");
+#define Tset_po (T_set_po + 1)
+EXTERN const char T_set_po[] E_INIT(" set +o");
 EXTERN const char Tsghset[] E_INIT("*=#set");
 #define Tsh (Tmksh + 2)
 #define TSHELL (TEXECSHELL + 4)
-#define Tshell (Ttoo_many_files + 23)
+EXTERN const char Tshell[] E_INIT("shell");
 EXTERN const char Tshf_read[] E_INIT("shf_read");
 EXTERN const char Tshf_write[] E_INIT("shf_write");
 EXTERN const char Tgsource[] E_INIT("=source");
@@ -1073,10 +1132,8 @@ EXTERN const char Tj_suspend[] E_INIT("j
 EXTERN const char Tsynerr[] E_INIT("syntax error");
 EXTERN const char Ttime[] E_INIT("time");
 EXTERN const char Ttoo_many_args[] E_INIT("too many arguments");
-EXTERN const char Ttoo_many_files[] E_INIT("too many open files in shell");
+EXTERN const char Ttoo_many_files[] E_INIT("too many open files (%d -> %d): %s");
 EXTERN const char Ttrue[] E_INIT("true");
-EXTERN const char Ttty_fd_dupof[] E_INIT("dup of tty fd");
-#define Ttty_fd (Ttty_fd_dupof + 7)
 EXTERN const char Tdgtypeset[] E_INIT("^=typeset");
 #define Ttypeset (Tdgtypeset + 2)
 #define Tugo (Taugo + 1)
@@ -1088,10 +1145,9 @@ EXTERN const char Tunwind[] E_INIT("unwi
 #define Tuser_sp1 (Tuser_sp2 + 1)
 EXTERN const char Tuser_sp2[] E_INIT(" user ");
 #define Twrite (Tshf_write + 4)
+#define Thex32 (Tbad_flags + 12)
 EXTERN const char Tf__S[] E_INIT(" %S");
 #define Tf__d (Tunexpected_type + 22)
-#define Tf_ss (Tf__ss + 1)
-EXTERN const char Tf__ss[] E_INIT(" %s%s");
 #define Tf__sN (Tf_s_s_sN + 5)
 #define Tf_T (Tf_s_T + 3)
 EXTERN const char Tf_dN[] E_INIT("%d\n");
@@ -1101,9 +1157,9 @@ EXTERN const char Tf_s_s_sN[] E_INIT("%s
 #define Tf_s_s (Tf_sD_s_s + 4)
 #define Tf__s_s (Tf_sD_s_s + 3)
 #define Tf_s_sD_s (Tf_cant_ss_s + 6)
+#define Tf_optdcs (Tf_optfoo + 4)
 EXTERN const char Tf_optfoo[] E_INIT("%s%s-%c: %s");
 EXTERN const char Tf_sD_[] E_INIT("%s: ");
-EXTERN const char Tf_szs[] E_INIT("%s: %zd %s");
 EXTERN const char Tf_parm[] E_INIT("%s: parameter not set");
 EXTERN const char Tf_coproc[] E_INIT("-p: %s");
 EXTERN const char Tf_cant_s[] E_INIT("%s: can't %s");
@@ -1117,16 +1173,14 @@ EXTERN const char Tf_S_[] E_INIT("%S ");
 #define Tf_lu (Tf_toolarge + 17)
 EXTERN const char Tf_toolarge[] E_INIT("%s %s too large: %lu");
 EXTERN const char Tf_ldfailed[] E_INIT("%s %s(%d, %ld) failed: %s");
-EXTERN const char Tf_sD_s_sD_s[] E_INIT("%s: %s %s: %s");
 EXTERN const char Tf_toomany[] E_INIT("too many %ss");
 EXTERN const char Tf_sd[] E_INIT("%s %d");
-#define Tf_s (Tf_temp + 28)
+#define Tf_s (Tcloexec_failed + 43)
 EXTERN const char Tft_end[] E_INIT("%;");
 EXTERN const char Tft_R[] E_INIT("%R");
 #define Tf_d (Tunexpected_type + 23)
 EXTERN const char Tf_sD_s_qs[] E_INIT("%s: %s '%s'");
 EXTERN const char Tf_ro[] E_INIT("read-only: %s");
-EXTERN const char Tf_flags[] E_INIT("%s: flags 0x%X");
 EXTERN const char Tf_temp[] E_INIT("can't %s temporary file %s: %s");
 EXTERN const char Tf_ssfaileds[] E_INIT("%s: %s failed: %s");
 EXTERN const char Tf_sD_sD_s[] E_INIT("%s: %s: %s");
@@ -1136,7 +1190,6 @@ EXTERN const char Tf_sD_s_s[] E_INIT("%s
 #define Tf_sD_s (Tf_temp + 24)
 EXTERN const char T_devtty[] E_INIT("/dev/tty");
 #else /* helpers for string pooling */
-#define T4spaces "    "
 #define T1space " "
 #define Tcolsp ": "
 #define TC_IFSWS " \t\n"
@@ -1151,8 +1204,8 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tbadnum "bad number"
 #define Tbadsubst "bad substitution"
 #define Tbg "bg"
-#define Tbad_bsize "bad shf/buf/bsize"
-#define Tbsize "bsize"
+#define Tbad_buf "%s: buf %zX len %zd"
+#define Tbad_flags "%s: flags 0x%08X"
 #define Tbad_sig_ss "%s: bad signal '%s'"
 #define Tbad_sig_s "bad signal '%s'"
 #define Tsgbreak "*=break"
@@ -1162,12 +1215,11 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tbuiltin "builtin"
 #define Toomem "can't allocate %zu data bytes"
 #define Tcant_cd "restricted shell - can't cd"
-#define Tcant_find "can't find"
-#define Tcant_open "can't open"
-#define Tbytes "bytes"
-#define Tbcat "!cat"
-#define Tcat "cat"
+#define Tcant_filesub "can't open $(<...) file"
 #define Tcd "cd"
+#define Tchvt2 "chvt: %s: %s"
+#define Tchvt_failed "chvt: %s failed"
+#define Tcloexec_failed "failed to %s close-on-exec flag for fd#%d: %s"
 #define T_command "-command"
 #define Tcommand "command"
 #define Tsgcontinue "*=continue"
@@ -1185,7 +1237,6 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tfg "fg"
 #define Tfg_badsubst "fileglob: bad substitution"
 #define Tfile "file"
-#define Tfile_fd "function definition file"
 #define TFPATH "FPATH"
 #define T_function " function"
 #define Tfunction "function"
@@ -1207,6 +1258,7 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tnot_started "not started"
 #define TOLDPWD "OLDPWD"
 #define Topen "open"
+#define Ttooearly "too early%s"
 #define To_o_reset " -o .reset"
 #define To_reset ".reset"
 #define TPATH "PATH"
@@ -1226,6 +1278,7 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tselect "select"
 #define Tset "set"
 #define Tset_po "set +o"
+#define T_set_po " set +o"
 #define Tsghset "*=#set"
 #define Tsh "sh"
 #define TSHELL "SHELL"
@@ -1239,10 +1292,8 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tsynerr "syntax error"
 #define Ttime "time"
 #define Ttoo_many_args "too many arguments"
-#define Ttoo_many_files "too many open files in shell"
+#define Ttoo_many_files "too many open files (%d -> %d): %s"
 #define Ttrue "true"
-#define Ttty_fd_dupof "dup of tty fd"
-#define Ttty_fd "tty fd"
 #define Tdgtypeset "^=typeset"
 #define Ttypeset "typeset"
 #define Tugo "ugo"
@@ -1254,10 +1305,9 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tuser_sp1 "user "
 #define Tuser_sp2 " user "
 #define Twrite "write"
+#define Thex32 "%08X"
 #define Tf__S " %S"
 #define Tf__d " %d"
-#define Tf_ss "%s%s"
-#define Tf__ss " %s%s"
 #define Tf__sN " %s\n"
 #define Tf_T "%T"
 #define Tf_dN "%d\n"
@@ -1267,9 +1317,9 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tf_s_s "%s %s"
 #define Tf__s_s " %s %s"
 #define Tf_s_sD_s "%s %s: %s"
+#define Tf_optdcs "-%c: %s"
 #define Tf_optfoo "%s%s-%c: %s"
 #define Tf_sD_ "%s: "
-#define Tf_szs "%s: %zd %s"
 #define Tf_parm "%s: parameter not set"
 #define Tf_coproc "-p: %s"
 #define Tf_cant_s "%s: can't %s"
@@ -1283,7 +1333,6 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tf_lu "%lu"
 #define Tf_toolarge "%s %s too large: %lu"
 #define Tf_ldfailed "%s %s(%d, %ld) failed: %s"
-#define Tf_sD_s_sD_s "%s: %s %s: %s"
 #define Tf_toomany "too many %ss"
 #define Tf_sd "%s %d"
 #define Tf_s "%s"
@@ -1292,7 +1341,6 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define Tf_d "%d"
 #define Tf_sD_s_qs "%s: %s '%s'"
 #define Tf_ro "read-only: %s"
-#define Tf_flags "%s: flags 0x%X"
 #define Tf_temp "can't %s temporary file %s: %s"
 #define Tf_ssfaileds "%s: %s failed: %s"
 #define Tf_sD_sD_s "%s: %s: %s"
@@ -1303,7 +1351,7 @@ EXTERN const char T_devtty[] E_INIT("/de
 #define T_devtty "/dev/tty"
 #endif /* end of string pooling */
 
-typedef uint8_t Temp_type;
+typedef kby Temp_type;
 /* expanded heredoc */
 #define TT_HEREDOC_EXP	0
 /* temporary file used for history editing (fc -e) */
@@ -1415,9 +1463,9 @@ EXTERN bool really_exit;
 #define CiOCTAL	BIT(5)	/* 0‥7				*/
 #define CiQCL	BIT(6)	/* &();|			*/
 #define CiALIAS	BIT(7)	/* !,.@				*/
-#define CiQCX	BIT(8)	/* *[\\				*/
+#define CiQCX	BIT(8)	/* *[\\~			*/
 #define CiVAR1	BIT(9)	/* !*@				*/
-#define CiQCM	BIT(10)	/* /^~				*/
+#define CiQCM	BIT(10)	/* /^				*/
 #define CiDIGIT	BIT(11)	/* 89				*/
 #define CiQC	BIT(12)	/* "'				*/
 #define CiSPX	BIT(13)	/* \x0B\x0C			*/
@@ -1461,20 +1509,20 @@ EXTERN char ifs0;
 /* A‥Z_a‥z		alphabetical plus underscore (identifier lead) */
 #define C_ALPHX	(CiLOWER | CiUNDER | CiUPPER)
 /* \x01‥\x7F		7-bit ASCII except NUL */
-#define C_ASCII (CiALIAS | CiANGLE | CiBRACK | CiCNTRL | CiCOLON | CiCR | CiCURLY | CiDIGIT | CiEQUAL | CiGRAVE | CiHASH | CiLOWER | CiMINUS | CiNL | CiOCTAL | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSP | CiSPX | CiSS | CiTAB | CiUNDER | CiUPPER)
+#define C_ASCII	(C_GRAPH | CiCNTRL | CiCR | CiNL | CiSP | CiSPX | CiTAB)
 /* \x09\x20		tab and space */
 #define C_BLANK	(CiSP | CiTAB)
-/* \x09\x20"'		separator for completion */
-#define C_CFS	(CiQC | CiSP | CiTAB)
 /* \x00‥\x1F\x7F	POSIX control characters */
 #define C_CNTRL	(CiCNTRL | CiCR | CiNL | CiNUL | CiSPX | CiTAB)
 /* 0‥9			decimal digits */
 #define C_DIGIT	(CiDIGIT | CiOCTAL)
 /* &();`|			editor x_locate_word() command */
 #define C_EDCMD	(CiGRAVE | CiQCL)
+/* $*?[\\`~			escape for globbing */
+#define C_EDGLB	(CiGRAVE | CiQCX | CiQUEST | CiSS)
 /* \x09\x0A\x20"&'():;<=>`|	editor non-word characters */
 #define C_EDNWC	(CiANGLE | CiCOLON | CiEQUAL | CiGRAVE | CiNL | CiQC | CiQCL | CiSP | CiTAB)
-/* "#$&'()*:;<=>?[\\`{|}	editor quotes for tab completion */
+/* "#$&'()*:;<=>?[\\`{|}~	editor quotes for tab completion */
 #define C_EDQ	(CiANGLE | CiCOLON | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiQC | CiQCL | CiQCX | CiQUEST | CiSS)
 /* !‥~			POSIX graphical (alphanumerical plus punctuation) */
 #define C_GRAPH	(C_PUNCT | CiDIGIT | CiLOWER | CiOCTAL | CiUPPER)
@@ -1482,7 +1530,7 @@ EXTERN char ifs0;
 #define C_HEXLT	CiHEXLT
 /* \x00 + $IFS		IFS whitespace, IFS non-whitespace, NUL */
 #define C_IFS	(CiIFS | CiNUL)
-/* \x09\x0A\x20		IFS whitespace */
+/* \x09\x0A\x20		IFS whitespace candidates */
 #define C_IFSWS	(CiNL | CiSP | CiTAB)
 /* \x09\x0A\x20&();<>|	(for the lexer) */
 #define C_LEX1	(CiANGLE | CiNL | CiQCL | CiSP | CiTAB)
@@ -1498,8 +1546,8 @@ EXTERN char ifs0;
 #define C_PRINT	(C_GRAPH | CiSP)
 /* !"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~	POSIX punctuation */
 #define C_PUNCT	(CiALIAS | CiANGLE | CiBRACK | CiCOLON | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiMINUS | CiPERCT | CiPLUS | CiQC | CiQCL | CiQCM | CiQCX | CiQUEST | CiSS | CiUNDER)
-/* \x09\x0A"#$&'()*;<=>?[\\]`|	characters requiring quoting, minus space */
-#define C_QUOTE	(CiANGLE | CiBRACK | CiEQUAL | CiGRAVE | CiHASH | CiNL | CiQC | CiQCL | CiQCX | CiQUEST | CiSS | CiTAB)
+/* \x09\x0A"#$&'()*;<=>?[\\]`{|}~	characters requiring quoting, minus space */
+#define C_QUOTE	(CiANGLE | CiBRACK | CiCURLY | CiEQUAL | CiGRAVE | CiHASH | CiNL | CiQC | CiQCL | CiQCX | CiQUEST | CiSS | CiTAB)
 /* 0‥9A‥Fa‥f		hexadecimal digit */
 #define C_SEDEC	(CiDIGIT | CiHEXLT | CiOCTAL)
 /* \x09‥\x0D\x20	POSIX space class */
@@ -1524,9 +1572,9 @@ EXTERN char ifs0;
 #define C_LF	CiNL		/* \x0A	ASCII line feed */
 #define C_MINUS	CiMINUS		/* -	hyphen-minus */
 #ifdef MKSH_WITH_TEXTMODE
-#define C_NL	(CiNL | CiCR)	/* 	CR or LF under OS/2 TEXTMODE */
+#define C_NL	(CiNL | CiCR)	/*	CR or LF under OS/2 TEXTMODE */
 #else
-#define C_NL	CiNL		/* 	LF only like under Unix */
+#define C_NL	CiNL		/*	LF only like under Unix */
 #endif
 #define C_NUL	CiNUL		/* \x00	ASCII NUL */
 #define C_PLUS	CiPLUS		/* +	plus sign */
@@ -1539,22 +1587,21 @@ EXTERN char ifs0;
 /* identity transform of octet */
 #if defined(DEBUG) && defined(__GNUC__) && !defined(__ICC) && \
     !defined(__INTEL_COMPILER) && !defined(__SUNPRO_C)
-extern unsigned int eek_ord;
-#define ORD(c)	((size_t)(c) > 0xFF ? eek_ord : \
-		    ((unsigned int)(unsigned char)(c)))
+extern kui eek_ord;
+#define ORD(c)	((size_t)(c) > 0xFF ? eek_ord : KBI(c))
 #define ord(c)	__builtin_choose_expr(				\
     __builtin_types_compatible_p(__typeof__(c), char) ||	\
     __builtin_types_compatible_p(__typeof__(c), unsigned char),	\
-    ((unsigned int)(unsigned char)(c)), ({			\
+    KBI(c), ({							\
 	size_t ord_c = (c);					\
 								\
 	if (ord_c > (size_t)0xFFU)				\
 		internal_errorf("%s:%d:ord(%zX)",		\
 		    __FILE__, __LINE__, ord_c);			\
-	((unsigned int)(unsigned char)(ord_c));			\
+	(KBI(ord_c));						\
 }))
 #else
-#define ord(c)	((unsigned int)(unsigned char)(c))
+#define ord(c)	KBI(c)
 #define ORD(c)	ord(c) /* may evaluate arguments twice */
 #endif
 #if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
@@ -1563,28 +1610,31 @@ EXTERN unsigned char ebcdic_rtt_toascii[
 EXTERN unsigned char ebcdic_rtt_fromascii[256];
 extern void ebcdic_init(void);
 /* one-way to-ascii-or-high conversion, for POSIX locale ordering */
-#define asciibetical(c)	((unsigned int)ebcdic_map[(unsigned char)(c)])
+#define asciibetical(c)	KUI(ebcdic_map[ord(c)])
 /* two-way round-trip conversion, for general use */
-#define rtt2asc(c)	ebcdic_rtt_toascii[(unsigned char)(c)]
-#define asc2rtt(c)	ebcdic_rtt_fromascii[(unsigned char)(c)]
+#define rtt2asc(c)	ebcdic_rtt_toascii[KBY(c)]
+#define asc2rtt(c)	ebcdic_rtt_fromascii[KBY(c)]
 /* case-independent char comparison */
 #define ksh_eq(c,u,l)	(ord(c) == ord(u) || ord(c) == ord(l))
 #else
 #define asciibetical(c)	ord(c)
-#define rtt2asc(c)	((unsigned char)(c))
-#define asc2rtt(c)	((unsigned char)(c))
-#define ksh_eq(c,u,l)	((ord(c) | 0x20) == ord(l))
+#define rtt2asc(c)	KBY(c)
+#define asc2rtt(c)	KBY(c)
+#define ksh_eq(c,u,l)	((ord(c) | 0x20U) == ord(l))
 #endif
 /* control character foo */
 #ifdef MKSH_EBCDIC
-#define ksh_isctrl(c)	(ord(c) < 0x40 || ord(c) == 0xFF)
+#define ksh_isctrl(c)	(ord(c) < 0x40U || ord(c) == 0xFFU)
+#define ksh_isctrl8(c)	ksh_isctrl(c)
 #else
-#define ksh_isctrl(c)	((ord(c) & 0x7F) < 0x20 || ord(c) == 0x7F)
+#define ksh_isctrl(c)	((ord(c) & 0x7FU) < 0x20U || ord(c) == 0x7FU)
+#define ksh_asisctrl(c)	(ord(c) < 0x20U || ord(c) == 0x7FU)
+#define ksh_isctrl8(c)	(Flag(FASIS) ? ksh_asisctrl(c) : ksh_isctrl(c))
 #endif
 /* new fast character classes */
 #define ctype(c,t)	tobool(ksh_ctypes[ord(c)] & (t))
 #define cinttype(c,t)	((c) >= 0 && (c) <= 0xFF ? \
-			tobool(ksh_ctypes[(unsigned char)(c)] & (t)) : false)
+			tobool(ksh_ctypes[KBY(c)] & (t)) : false)
 /* helper functions */
 #define ksh_isdash(s)	tobool(ord((s)[0]) == '-' && ord((s)[1]) == '\0')
 /* invariant distance even in EBCDIC */
@@ -1594,8 +1644,6 @@ extern void ebcdic_init(void);
 #define ksh_numdig(c)	(ord(c) - ORD('0'))
 #define ksh_numuc(c)	(rtt2asc(c) - rtt2asc('A'))
 #define ksh_numlc(c)	(rtt2asc(c) - rtt2asc('a'))
-#define ksh_toctrl(c)	asc2rtt(ord(c) == ORD('?') ? 0x7F : rtt2asc(c) & 0x9F)
-#define ksh_unctrl(c)	asc2rtt(rtt2asc(c) ^ 0x40U)
 
 #ifdef MKSH_SMALL
 #define SMALLP(x)	/* nothing */
@@ -1670,7 +1718,6 @@ EXTERN char	*current_wd;
 EXTERN mksh_ari_t x_cols E_INIT(80);
 EXTERN mksh_ari_t x_lins E_INIT(24);
 
-
 /* Determine the location of the system (common) profile */
 
 #ifndef MKSH_DEFAULT_PROFILEDIR
@@ -1680,7 +1727,6 @@ EXTERN mksh_ari_t x_lins E_INIT(24);
 #define MKSH_SYSTEM_PROFILE	MKSH_DEFAULT_PROFILEDIR "/profile"
 #define MKSH_SUID_PROFILE	MKSH_DEFAULT_PROFILEDIR "/suid_profile"
 
-
 /* Used by v_evaluate() and setstr() to control action when error occurs */
 #define KSH_UNWIND_ERROR	0	/* unwind the stack (kshlongjmp) */
 #define KSH_RETURN_ERROR	1	/* return 1/0 for success/failure */
@@ -1697,8 +1743,23 @@ EXTERN mksh_ari_t x_lins E_INIT(24);
 				    (shf)->rnleft--, (int)ord(*(shf)->rp++) : \
 				    shf_getchar(shf))
 #define shf_putc_i(c,shf)	((shf)->wnleft == 0 ? \
-				    shf_putchar((uint8_t)(c), (shf)) : \
+				    shf_putchar((kby)(c), (shf)) : \
 				    ((shf)->wnleft--, *(shf)->wp++ = (c)))
+/*
+ * small strings (e.g. one multibyte character) only, atomically
+ * no side effects in arguments please; does s+=n; may do n=0
+ */
+#define shf_wr_sm(s,n,shf)	do {				\
+	if ((shf)->wnleft < (ssize_t)(n)) {			\
+		shf_scheck_grow((n), (shf));			\
+		shf_write((const void *)(s), (n), (shf));	\
+		(s) += (n);					\
+	} else {						\
+		(shf)->wnleft -= n;				\
+		while ((n)--)					\
+			*(shf)->wp++ = *(s)++;			\
+	}							\
+} while (/* CONSTCOND */ 0)
 #define shf_eof(shf)		((shf)->flags & SHF_EOF)
 #define shf_error(shf)		((shf)->flags & SHF_ERROR)
 #define shf_errno(shf)		((shf)->errnosv)
@@ -1725,7 +1786,6 @@ EXTERN mksh_ari_t x_lins E_INIT(24);
 #define SHF_READING	0x2000		/* currently reading: rnleft,rp valid */
 #define SHF_WRITING	0x4000		/* currently writing: wnleft,wp valid */
 
-
 struct shf {
 	Area *areap;		/* area shf/buf were allocated in */
 	unsigned char *rp;	/* read: current position in buffer */
@@ -1747,7 +1807,7 @@ struct table {
 	Area *areap;		/* area to allocate entries */
 	struct tbl **tbls;	/* hashed table items */
 	size_t nfree;		/* free table entries */
-	uint8_t tshift;		/* table size (2^tshift) */
+	kby tshift;		/* table size (2^tshift) */
 };
 
 /* table item */
@@ -1929,7 +1989,7 @@ EXTERN char *path;		/* copy of either PA
 EXTERN const char *def_path;	/* path to use if PATH not set */
 EXTERN char *tmpdir;		/* TMPDIR value */
 EXTERN const char *prompt;
-EXTERN uint8_t cur_prompt;	/* PS1 or PS2 */
+EXTERN kby cur_prompt;		/* PS1 or PS2 */
 EXTERN int current_lineno;	/* LINENO value */
 
 /*
@@ -2012,7 +2072,7 @@ struct ioword {
 	char *delim;		/* delimiter for <<, <<- */
 	char *heredoc;		/* content of heredoc */
 	unsigned short ioflag;	/* action (below) */
-	short unit;		/* unit (fd) affected */
+	signed char unit;	/* unit (fd) affected */
 };
 
 /* ioword.flag - type of redirection */
@@ -2386,7 +2446,6 @@ EXTERN struct timeval j_usrtime, j_systi
 		    '+', (size_t)(cnst));				\
 } while (/* CONSTCOND */ 0)
 
-
 /* lalloc.c */
 void ainit(Area *);
 void afreeall(Area *);
@@ -2409,7 +2468,7 @@ void x_init(void);
 #ifdef DEBUG_LEAKS
 void x_done(void);
 #endif
-int x_read(char *);
+char *x_read(char *);
 #endif
 void x_mkraw(int, mksh_ttyst *, bool);
 void x_initterm(const char *);
@@ -2440,12 +2499,20 @@ int herein(struct ioword *, char **);
 int evaluate(const char *, mksh_ari_t *, int, bool);
 int v_evaluate(struct tbl *, const char *, volatile int, bool);
 /* UTF-8 stuff */
+char *ez_bs(char *, char *);
 size_t utf_mbtowc(unsigned int *, const char *);
 size_t utf_wctomb(char *, unsigned int);
+#define OPTUISRAW(wc) IS(wc, 0xFFFFFF80U, 0x0000EF80U)
+#define OPTUMKRAW(ch) (ord(ch) | 0x0000EF00U)
+#if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
+size_t ez_mbtowc(unsigned int *, const char *);
+#else
+#define ez_mbtowc ez_mbtoc
+#endif
+size_t ez_mbtoc(unsigned int *, const char *);
+size_t ez_ctomb(char *, unsigned int);
 int utf_widthadj(const char *, const char **);
 size_t utf_mbswidth(const char *) MKSH_A_PURE;
-const char *utf_skipcols(const char *, int, int *);
-size_t utf_ptradj(const char *) MKSH_A_PURE;
 #ifdef MIRBSD_BOOTFLOPPY
 #define utf_wcwidth(i) wcwidth((wchar_t)(i))
 #else
@@ -2499,8 +2566,6 @@ int c_mknod(const char **);
 #endif
 int c_realpath(const char **);
 int c_rename(const char **);
-int c_cat(const char **);
-int c_sleep(const char **);
 /* histrap.c */
 void init_histvec(void);
 void hist_init(Source *);
@@ -2565,7 +2630,6 @@ pid_t j_async(void);
 int j_stopped_running(void);
 /* lex.c */
 int yylex(int);
-void yyskiputf8bom(void);
 void yyerror(const char *, ...)
     MKSH_A_NORETURN
     MKSH_A_FORMAT(__printf__, 1, 2);
@@ -2611,7 +2675,7 @@ int can_seek(int);
 void initio(void);
 void recheck_ctype(void);
 int ksh_dup2(int, int, bool);
-short savefd(int);
+int savefd(int);
 void restfd(int, int);
 void openpipe(int *);
 void closepipe(int *);
@@ -2623,7 +2687,7 @@ void coproc_write_close(int);
 int coproc_getfd(int, const char **);
 void coproc_cleanup(int);
 struct temp *maketemp(Area *, Temp_type, struct temp **);
-void ktinit(Area *, struct table *, uint8_t);
+void ktinit(Area *, struct table *, kby);
 struct tbl *ktscan(struct table *, const char *, uint32_t, struct tbl ***);
 /* table, name (key) to search for, hash(n) */
 #define ktsearch(tp,s,h) ktscan((tp), (s), (h), NULL)
@@ -2643,6 +2707,7 @@ void change_flag(enum sh_flag, int, bool
 void change_xtrace(unsigned char, bool);
 int parse_args(const char **, int, bool *);
 int getn(const char *, int *);
+int getpn(const char **, int *);
 int gmatchx(const char *, const char *, bool);
 bool has_globbing(const char *) MKSH_A_PURE;
 int ascstrcmp(const void *, const void *) MKSH_A_PURE;
@@ -2682,6 +2747,10 @@ struct shf *shf_open(const char *, int,
 struct shf *shf_fdopen(int, int, struct shf *);
 struct shf *shf_reopen(int, int, struct shf *);
 struct shf *shf_sopen(char *, ssize_t, int, struct shf *);
+struct shf *shf_sreopen(char *, ssize_t, Area *, struct shf *);
+int shf_scheck_grow(ssize_t, struct shf *);
+#define shf_scheck(n,shf)	(((shf)->wnleft < (ssize_t)(n)) ? \
+				    shf_scheck_grow((n), (shf)) : 0)
 int shf_close(struct shf *);
 int shf_fdclose(struct shf *);
 char *shf_sclose(struct shf *);
@@ -2712,7 +2781,7 @@ ssize_t shf_vfprintf(struct shf *, const
 void set_ifs(const char *);
 /* syn.c */
 void initkeywords(void);
-struct op *compile(Source *, bool, bool);
+struct op *compile(Source *, bool);
 bool parse_usec(const char *, struct timeval *);
 char *yyrecursive(int);
 void yyrecursive_pop(bool);
@@ -2725,12 +2794,20 @@ const char *wdscan(const char *, int);
 #define WDS_TPUTS	BIT(0)		/* tputS (dumpwdvar) mode */
 char *wdstrip(const char *, int);
 void tfree(struct op *, Area *);
-void dumpchar(struct shf *, unsigned char);
+#ifdef DEBUG
 void dumptree(struct shf *, struct op *);
 void dumpwdvar(struct shf *, const char *);
-void dumpioact(struct shf *shf, struct op *t);
-void vistree(char *, size_t, struct op *)
-    MKSH_A_BOUNDED(__string__, 1, 2);
+void dumpioact(struct shf *, struct op *);
+void dumphex(struct shf *, const void *, size_t)
+    MKSH_A_BOUNDED(__string__, 2, 3);
+#endif
+void uprntc(unsigned char, struct shf *);
+#ifndef MKSH_NO_CMDLINE_EDITING
+void uescmbT(unsigned char *, const char **)
+    MKSH_A_BOUNDED(__minbytes__, 1, 5);
+int uwidthmbT(char *, char **);
+#endif
+const char *uprntmbs(const char *, bool, struct shf *);
 void fpFUNCTf(struct shf *, int, bool, const char *, struct op *);
 /* var.c */
 void newblock(void);
@@ -2755,7 +2832,7 @@ struct tbl *arraysearch(struct tbl *, ui
 char **makenv(void);
 void change_winsz(void);
 size_t array_ref_len(const char *) MKSH_A_PURE;
-char *arrayname(const char *);
+struct tbl *arraybase(const char *);
 mksh_uari_t set_array(const char *, bool, const char **);
 uint32_t hash(const void *) MKSH_A_PURE;
 uint32_t chvt_rndsetup(const void *, size_t) MKSH_A_PURE;
@@ -2888,7 +2965,7 @@ int getdrvwd(char **, unsigned int);
 #else
 #define mksh_abspath(s)			(ord((s)[0]) == ORD('/'))
 #define mksh_cdirsep(c)			(ord(c) == ORD('/'))
-#define mksh_sdirsep(s)			strchr((s), '/')
+#define mksh_sdirsep(s)			ucstrchr((s), '/')
 #define mksh_vdirsep(s)			vstrchr((s), '/')
 #endif
 
--- mksh-59c.orig/sh_flags.opt
+++ mksh-59c/sh_flags.opt
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 2013, 2014, 2015, 2017
+ * Copyright (c) 2013, 2014, 2015, 2017, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -19,7 +19,7 @@
  */
 
 @SHFLAGS_DEFNS
-__RCSID("$MirOS: src/bin/mksh/sh_flags.opt,v 1.9 2020/05/16 22:38:25 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/sh_flags.opt,v 1.10 2021/05/30 04:17:56 tg Exp $");
 @SHFLAGS_ENUMS
 #define FN(sname,cname,flags,ochar)	cname,
 #define F0(sname,cname,flags,ochar)	cname = 0,
@@ -43,6 +43,10 @@ __RCSID("$MirOS: src/bin/mksh/sh_flags.o
 >a|
 F0("allexport", FEXPORT, OF_ANY
 
+/* ./.	when quoting, show C1 control characters as-is; +U only */
+>|
+FN("asis", FASIS, OF_ANY
+
 /* ./.	bgnice */
 >| HAVE_NICE
 FN("bgnice", FBGNICE, OF_ANY
--- mksh-59c.orig/shf.c
+++ mksh-59c/shf.c
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011,
- *		 2012, 2013, 2015, 2016, 2017, 2018, 2019
+ *		 2012, 2013, 2015, 2016, 2017, 2018, 2019, 2021
  *	mirabilos <m@mirbsd.org>
  * Copyright (c) 2015
  *	Daniel Richard G. <skunk@iSKUNK.ORG>
@@ -27,7 +27,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.102 2020/06/22 17:11:03 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/shf.c,v 1.120 2021/10/01 23:25:35 tg Exp $");
 
 /* flags to shf_emptybuf() */
 #define EB_READSW	0x01	/* about to switch to reading */
@@ -121,7 +121,7 @@ shf_open_hlp(int fd, int *sflagsp, const
 	}
 
 	if (!(sflags & (SHF_RD | SHF_WR)))
-		internal_errorf(Tf_sD_s, where, "missing read/write");
+		internal_errorf(Tbad_flags, where, sflags);
 }
 
 /* Set up the shf structure for a file descriptor. Doesn't fail. */
@@ -154,8 +154,9 @@ shf_fdopen(int fd, int sflags, struct sh
 	shf->flags = sflags;
 	shf->errnosv = 0;
 	shf->bsize = bsize;
-	if (sflags & SHF_CLEXEC)
-		fcntl(fd, F_SETFD, FD_CLOEXEC);
+	if ((sflags & SHF_CLEXEC) && fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
+		internal_warningf(Tcloexec_failed, "set", fd,
+		    cstrerror(errno));
 	return (shf);
 }
 
@@ -168,8 +169,9 @@ shf_reopen(int fd, int sflags, struct sh
 	    sflags & SHF_UNBUF ? (sflags & SHF_RD ? 1 : 0) : SHF_BSIZE;
 
 	shf_open_hlp(fd, &sflags, "shf_reopen");
-	if (!shf || !shf->buf || shf->bsize < bsize)
-		internal_errorf(Tf_sD_s, "shf_reopen", Tbad_bsize);
+	if (!shf->buf || shf->bsize < bsize)
+		internal_errorf(Tbad_buf, "shf_reopen",
+		    (size_t)shf->buf, shf->bsize);
 
 	/* assumes shf->buf and shf->bsize already set up */
 	shf->fd = fd;
@@ -180,8 +182,9 @@ shf_reopen(int fd, int sflags, struct sh
 	shf->wbsize = sflags & SHF_UNBUF ? 0 : bsize;
 	shf->flags = (shf->flags & (SHF_ALLOCS | SHF_ALLOCB)) | sflags;
 	shf->errnosv = 0;
-	if (sflags & SHF_CLEXEC)
-		fcntl(fd, F_SETFD, FD_CLOEXEC);
+	if ((sflags & SHF_CLEXEC) && fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
+		internal_warningf(Tcloexec_failed, "set", fd,
+		    cstrerror(errno));
 	return (shf);
 }
 
@@ -197,10 +200,8 @@ shf_reopen(int fd, int sflags, struct sh
 struct shf *
 shf_sopen(char *buf, ssize_t bsize, int sflags, struct shf *shf)
 {
-	/* can't have a read+write string */
-	if (!(!(sflags & SHF_RD) ^ !(sflags & SHF_WR)))
-		internal_errorf(Tf_flags, "shf_sopen",
-		    (unsigned int)sflags);
+	if (!((sflags & SHF_RD) ^ (sflags & SHF_WR)))
+		internal_errorf(Tbad_flags, "shf_sopen", sflags);
 
 	if (!shf) {
 		shf = alloc(sizeof(struct shf), ATEMP);
@@ -226,6 +227,43 @@ shf_sopen(char *buf, ssize_t bsize, int
 	return (shf);
 }
 
+/* Open a string for dynamic writing, using already-allocated buffer */
+struct shf *
+shf_sreopen(char *buf, ssize_t bsize, Area *ap, struct shf *oshf)
+{
+	struct shf *shf;
+
+	shf = shf_sopen(buf, bsize, SHF_WR | SHF_DYNAMIC, oshf);
+	shf->areap = ap;
+	shf->flags |= SHF_ALLOCB;
+	return (shf);
+}
+
+/* Check whether the string can grow to take n bytes, close it up otherwise */
+int
+shf_scheck_grow(ssize_t n, struct shf *shf)
+{
+	if (!(shf->flags & SHF_WR))
+		internal_errorf(Tbad_flags, "shf_scheck", shf->flags);
+
+	/* if n < 0 we lose in the macro already */
+
+	/* nōn-string can always grow flushing */
+	if (!(shf->flags & SHF_STRING))
+		return (0);
+
+	while (shf->wnleft < n)
+		if (shf_emptybuf(shf, EB_GROW) == -1)
+			break;
+
+	if (shf->wnleft < n) {
+		/* block subsequent writes as we truncate here */
+		shf->wnleft = 0;
+		return (1);
+	}
+	return (0);
+}
+
 /* Flush and close file descriptor, free the shf structure */
 int
 shf_close(struct shf *shf)
@@ -275,10 +313,8 @@ shf_sclose(struct shf *shf)
 	unsigned char *s = shf->buf;
 
 	/* NUL terminate */
-	if (shf->flags & SHF_WR) {
-		shf->wnleft++;
-		shf_putc('\0', shf);
-	}
+	if (shf->flags & SHF_WR)
+		*shf->wp = '\0';
 	if (shf->flags & SHF_ALLOCS)
 		afree(shf, shf->areap);
 	return ((char *)s);
@@ -383,6 +419,8 @@ shf_emptybuf(struct shf *shf, int flags)
 						memmove(shf->buf, buf,
 						    ntowrite);
 						shf->wp = shf->buf + ntowrite;
+						/* restore errno for caller */
+						errno = shf->errnosv;
 					}
 					return (-1);
 				}
@@ -457,11 +495,10 @@ shf_read(char *buf, ssize_t bsize, struc
 	ssize_t ncopy, orig_bsize = bsize;
 
 	if (!(shf->flags & SHF_RD))
-		internal_errorf(Tf_flags, Tshf_read,
-		    (unsigned int)shf->flags);
+		internal_errorf(Tbad_flags, Tshf_read, shf->flags);
 
 	if (bsize <= 0)
-		internal_errorf(Tf_szs, Tshf_read, bsize, Tbsize);
+		internal_errorf(Tbad_buf, Tshf_read, (size_t)buf, bsize);
 
 	while (bsize > 0) {
 		if (shf->rnleft == 0 &&
@@ -495,8 +532,7 @@ shf_getse(char *buf, ssize_t bsize, stru
 	char *orig_buf = buf;
 
 	if (!(shf->flags & SHF_RD))
-		internal_errorf(Tf_flags, "shf_getse",
-		    (unsigned int)shf->flags);
+		internal_errorf(Tbad_flags, "shf_getse", shf->flags);
 
 	if (bsize <= 0)
 		return (NULL);
@@ -549,8 +585,7 @@ int
 shf_getchar(struct shf *shf)
 {
 	if (!(shf->flags & SHF_RD))
-		internal_errorf(Tf_flags, "shf_getchar",
-		    (unsigned int)shf->flags);
+		internal_errorf(Tbad_flags, "shf_getchar", shf->flags);
 
 	if (shf->rnleft == 0 && (shf_fillbuf(shf) == -1 || shf->rnleft == 0))
 		return (-1);
@@ -566,8 +601,7 @@ int
 shf_ungetc(int c, struct shf *shf)
 {
 	if (!(shf->flags & SHF_RD))
-		internal_errorf(Tf_flags, "shf_ungetc",
-		    (unsigned int)shf->flags);
+		internal_errorf(Tbad_flags, "shf_ungetc", shf->flags);
 
 	if ((shf->flags & SHF_ERROR) || c == -1 ||
 	    (shf->rp == shf->buf && shf->rnleft))
@@ -604,8 +638,7 @@ int
 shf_putchar(int c, struct shf *shf)
 {
 	if (!(shf->flags & SHF_WR))
-		internal_errorf(Tf_flags, "shf_putchar",
-		    (unsigned int)shf->flags);
+		internal_errorf(Tbad_flags, "shf_putchar",shf->flags);
 
 	if (c == -1)
 		return (-1);
@@ -641,8 +674,8 @@ shf_putchar(int c, struct shf *shf)
 }
 
 /*
- * Write a string. Returns the length of the string if successful, -1
- * if the string could not be written.
+ * Write a string. Returns the length of the string if successful,
+ * less if truncated, and -1 if the string could not be written.
  */
 ssize_t
 shf_puts(const char *s, struct shf *shf)
@@ -653,18 +686,20 @@ shf_puts(const char *s, struct shf *shf)
 	return (shf_write(s, strlen(s), shf));
 }
 
-/* Write a buffer. Returns nbytes if successful, -1 if there is an error. */
+/*
+ * Write a buffer. Returns nbytes if successful, less if truncated
+ * (outputting to string only), and -1 if there is an error.
+ */
 ssize_t
 shf_write(const char *buf, ssize_t nbytes, struct shf *shf)
 {
 	ssize_t n, ncopy, orig_nbytes = nbytes;
 
 	if (!(shf->flags & SHF_WR))
-		internal_errorf(Tf_flags, Tshf_write,
-		    (unsigned int)shf->flags);
+		internal_errorf(Tbad_flags, Tshf_write, shf->flags);
 
 	if (nbytes < 0)
-		internal_errorf(Tf_szs, Tshf_write, nbytes, Tbytes);
+		internal_errorf(Tbad_buf, Tshf_write, (size_t)buf, nbytes);
 
 	/* don't buffer if buffer is empty and we're writing a large amount */
 	if ((ncopy = shf->wnleft) &&
@@ -681,8 +716,13 @@ shf_write(const char *buf, ssize_t nbyte
 		if (shf->flags & SHF_STRING) {
 			/* resize buffer until there's enough space left */
 			while (nbytes > shf->wnleft)
-				if (shf_emptybuf(shf, EB_GROW) == -1)
-					return (-1);
+				if (shf_emptybuf(shf, EB_GROW) == -1) {
+					/* truncate if possible */
+					if (shf->wnleft == 0)
+						return (-1);
+					nbytes = shf->wnleft;
+					break;
+				}
 			/* then write everything into the buffer */
 		} else {
 			/* flush deals with sticky errors */
@@ -747,8 +787,7 @@ shf_snprintf(char *buf, ssize_t bsize, c
 	ssize_t n;
 
 	if (!buf || bsize <= 0)
-		internal_errorf("shf_snprintf: buf %zX, bsize %zd",
-		    (size_t)buf, bsize);
+		internal_errorf(Tbad_buf, "shf_snprintf", (size_t)buf, bsize);
 
 	shf_sopen(buf, bsize, SHF_WR, &shf);
 	va_start(args, fmt);
@@ -798,6 +837,8 @@ shf_vfprintf(struct shf *shf, const char
 	char numbuf[(8 * sizeof(long) + 2) / 3 + 1 + /* NUL */ 1];
 	/* this stuff for dealing with the buffer */
 	ssize_t nwritten = 0;
+	/* for width determination */
+	const char *lp, *np;
 
 #define VA(type) va_arg(args, type)
 
@@ -878,17 +919,8 @@ shf_vfprintf(struct shf *shf, const char
 				continue;
 			}
 			if (ctype(c, C_DIGIT)) {
-				bool overflowed = false;
-
-				tmp = ksh_numdig(c);
-				while (ctype((c = *fmt++), C_DIGIT))
-					if (notok2mul(2147483647, tmp, 10))
-						overflowed = true;
-					else
-						tmp = tmp * 10 + ksh_numdig(c);
 				--fmt;
-				if (overflowed)
-					tmp = 0;
+				getpn((const char **)&fmt, &tmp);
 				if (flags & FL_DOT)
 					precision = (unsigned int)tmp;
 				else
@@ -1027,11 +1059,30 @@ shf_vfprintf(struct shf *shf, const char
 		 */
 		if (!(flags & FL_DOT) || len < precision)
 			precision = len;
+		/* determine whether we can indeed write precision columns */
+		len = 0;
+		lp = s;
+		while (*lp) {
+			int w = utf_widthadj(lp, &np);
+
+			if ((len + w) > precision)
+				break;
+			lp = np;
+			len += w;
+		}
+		/* trailing combining characters */
+		if (UTFMODE)
+			while (*lp && utf_widthadj(lp, &np) == 0)
+				lp = np;
+		/* how much we can actually output */
+		precision = len;
+
+		/* output leading padding */
 		if (field > precision) {
 			field -= precision;
 			if (!(flags & FL_RIGHT)) {
 				/* skip past sign or 0x when padding with 0 */
-				if ((flags & FL_ZERO) && (flags & FL_NUMBER)) {
+				if ((flags & (FL_ZERO | FL_NUMBER)) == (FL_ZERO | FL_NUMBER)) {
 					if (ctype(*s, C_SPC | C_PLUS | C_MINUS)) {
 						shf_putc(*s, shf);
 						s++;
@@ -1061,11 +1112,11 @@ shf_vfprintf(struct shf *shf, const char
 		} else
 			field = 0;
 
-		nwritten += precision;
-		precision = utf_skipcols(s, precision, &tmp) - s;
-		while (precision--)
-			shf_putc(*s++, shf);
+		/* output string */
+		nwritten += (lp - s);
+		shf_write(s, lp - s, shf);
 
+		/* output trailing padding */
 		nwritten += field;
 		while (field--)
 			shf_putc(c, shf);
@@ -1206,11 +1257,15 @@ const uint32_t tpl_ctypes[128] = {
 	CiLOWER,	CiLOWER,	CiLOWER,	CiLOWER,
 	CiLOWER,	CiLOWER,	CiLOWER,	CiLOWER,
 	CiLOWER,	CiLOWER,	CiLOWER,	CiCURLY,
-	CiQCL,		CiCURLY,	CiQCM,		CiCNTRL
+	CiQCL,		CiCURLY,	CiQCX,		CiCNTRL
 };
 
-void
-set_ifs(const char *s)
+#ifdef MKSH__DEBUG_CCLASSES
+static int debug_ccls(void);
+#endif
+
+static void
+set_ccls(void)
 {
 #if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
 	int i = 256;
@@ -1224,12 +1279,25 @@ set_ifs(const char *s)
 	memset((char *)ksh_ctypes + sizeof(tpl_ctypes), '\0',
 	    sizeof(ksh_ctypes) - sizeof(tpl_ctypes));
 #endif
+}
+
+void
+set_ifs(const char *s)
+{
+	set_ccls();
 	ifs0 = *s;
 	while (*s)
 		ksh_ctypes[ord(*s++)] |= CiIFS;
+#ifdef MKSH__DEBUG_CCLASSES
+	if (debug_ccls())
+		exit(254);
+#endif
 }
 
 #if defined(MKSH_EBCDIC) || defined(MKSH_FAUX_EBCDIC)
+#if !HAVE_SETLOCALE_CTYPE
+# error EBCDIC support requires use of the system locale
+#endif
 #include <locale.h>
 
 /*
@@ -1239,8 +1307,8 @@ set_ifs(const char *s)
  *    contain all (most?) of the characters in ASCII, and these
  *    usually tend to agree on the code points assigned to the ASCII
  *    subset. If you need a representative example, look at EBCDIC 1047,
- *    which is first among equals in the IBM MVS development
- *    environment: https://en.wikipedia.org/wiki/EBCDIC_1047
+ *    which is first among equals in the IBM MVS development environment:
+ * https://web.archive.org/web/20200810035140/https://en.wikipedia.org/wiki/EBCDIC_1047
  *    Unfortunately, the square brackets are not consistently mapped,
  *    and for certain reasons, we need an unambiguous bijective
  *    mapping between EBCDIC and "extended ASCII".
@@ -1262,6 +1330,13 @@ set_ifs(const char *s)
  *    mainframe systems, using the -qascii option to the XL C compiler.
  *    We can determine the build mode by looking at __CHARSET_LIB:
  *    0 == EBCDIC, 1 == ASCII
+ *
+ * UTF-8 is not used, nor is UTF-EBCDIC really. We solve this problem
+ * by treating it as "nega-UTF-8": on EBCDIC systems, the output is
+ * converted to the "extended ASCII" codepage from the current EBCDIC
+ * codepage always so we convert UTF-8 backwards so the conversion
+ * will result in valid UTF-8. This may introduce fun on the EBCDIC
+ * side, but as it's not really used anyway we decided to take the risk.
  */
 
 void
@@ -1318,5 +1393,595 @@ ebcdic_init(void)
 		write(2, "mksh: NUL not at position 0\n", 28);
 		exit(255);
 	}
+	/* ensure control characters, i.e. 0x00‥0x3F and 0xFF, map sanely */
+	for (i = 0x00; i < 0x20; ++i)
+		if (!ksh_isctrl(asc2rtt(i)))
+			goto ebcdic_ctrlmis;
+	for (i = 0x7F; i < 0xA0; ++i)
+		if (!ksh_isctrl(asc2rtt(i))) {
+ ebcdic_ctrlmis:
+			write(2, "mksh: control character mismapping\n", 35);
+			exit(255);
+		}
+	/* validate character literals used in the code */
+	if (rtt2asc('\n') != 0x0AU || rtt2asc('\r') != 0x0DU ||
+	    rtt2asc(' ') != 0x20U ||
+	    rtt2asc('!') != 0x21U ||
+	    rtt2asc('"') != 0x22U ||
+	    rtt2asc('#') != 0x23U ||
+	    rtt2asc('$') != 0x24U ||
+	    rtt2asc('%') != 0x25U ||
+	    rtt2asc('&') != 0x26U ||
+	    rtt2asc('\'') != 0x27U ||
+	    rtt2asc('(') != 0x28U ||
+	    rtt2asc(')') != 0x29U ||
+	    rtt2asc('*') != 0x2AU ||
+	    rtt2asc('+') != 0x2BU ||
+	    rtt2asc(',') != 0x2CU ||
+	    rtt2asc('-') != 0x2DU ||
+	    rtt2asc('.') != 0x2EU ||
+	    rtt2asc('/') != 0x2FU ||
+	    rtt2asc('0') != 0x30U ||
+	    rtt2asc(':') != 0x3AU ||
+	    rtt2asc(';') != 0x3BU ||
+	    rtt2asc('<') != 0x3CU ||
+	    rtt2asc('=') != 0x3DU ||
+	    rtt2asc('>') != 0x3EU ||
+	    rtt2asc('?') != 0x3FU ||
+	    rtt2asc('@') != 0x40U ||
+	    rtt2asc('A') != 0x41U ||
+	    rtt2asc('B') != 0x42U ||
+	    rtt2asc('C') != 0x43U ||
+	    rtt2asc('D') != 0x44U ||
+	    rtt2asc('E') != 0x45U ||
+	    rtt2asc('F') != 0x46U ||
+	    rtt2asc('G') != 0x47U ||
+	    rtt2asc('H') != 0x48U ||
+	    rtt2asc('I') != 0x49U ||
+	    rtt2asc('N') != 0x4EU ||
+	    rtt2asc('O') != 0x4FU ||
+	    rtt2asc('P') != 0x50U ||
+	    rtt2asc('Q') != 0x51U ||
+	    rtt2asc('R') != 0x52U ||
+	    rtt2asc('S') != 0x53U ||
+	    rtt2asc('T') != 0x54U ||
+	    rtt2asc('U') != 0x55U ||
+	    rtt2asc('W') != 0x57U ||
+	    rtt2asc('X') != 0x58U ||
+	    rtt2asc('Y') != 0x59U ||
+	    rtt2asc('[') != 0x5BU ||
+	    rtt2asc('\\') != 0x5CU ||
+	    rtt2asc(']') != 0x5DU ||
+	    rtt2asc('^') != 0x5EU ||
+	    rtt2asc('_') != 0x5FU ||
+	    rtt2asc('`') != 0x60U ||
+	    rtt2asc('a') != 0x61U ||
+	    rtt2asc('b') != 0x62U ||
+	    rtt2asc('c') != 0x63U ||
+	    rtt2asc('d') != 0x64U ||
+	    rtt2asc('e') != 0x65U ||
+	    rtt2asc('f') != 0x66U ||
+	    rtt2asc('g') != 0x67U ||
+	    rtt2asc('h') != 0x68U ||
+	    rtt2asc('i') != 0x69U ||
+	    rtt2asc('j') != 0x6AU ||
+	    rtt2asc('k') != 0x6BU ||
+	    rtt2asc('l') != 0x6CU ||
+	    rtt2asc('n') != 0x6EU ||
+	    rtt2asc('p') != 0x70U ||
+	    rtt2asc('r') != 0x72U ||
+	    rtt2asc('s') != 0x73U ||
+	    rtt2asc('t') != 0x74U ||
+	    rtt2asc('u') != 0x75U ||
+	    rtt2asc('v') != 0x76U ||
+	    rtt2asc('w') != 0x77U ||
+	    rtt2asc('x') != 0x78U ||
+	    rtt2asc('y') != 0x79U ||
+	    rtt2asc('{') != 0x7BU ||
+	    rtt2asc('|') != 0x7CU ||
+	    rtt2asc('}') != 0x7DU ||
+	    rtt2asc('~') != 0x7EU) {
+		write(2, "mksh: compiler vs. runtime codepage mismatch!\n", 46);
+		exit(255);
+	}
+	/* validate sh.h control character literals */
+	if (rtt2asc(CTRL_AT) != 0x00U ||
+	    rtt2asc(CTRL_A) != 0x01U ||
+	    rtt2asc(CTRL_B) != 0x02U ||
+	    rtt2asc(CTRL_C) != 0x03U ||
+	    rtt2asc(CTRL_D) != 0x04U ||
+	    rtt2asc(CTRL_E) != 0x05U ||
+	    rtt2asc(CTRL_F) != 0x06U ||
+	    rtt2asc(CTRL_G) != 0x07U ||
+	    rtt2asc(CTRL_H) != 0x08U ||
+	    rtt2asc(CTRL_I) != 0x09U ||
+	    rtt2asc(CTRL_J) != 0x0AU ||
+	    rtt2asc(CTRL_K) != 0x0BU ||
+	    rtt2asc(CTRL_L) != 0x0CU ||
+	    rtt2asc(CTRL_M) != 0x0DU ||
+	    rtt2asc(CTRL_N) != 0x0EU ||
+	    rtt2asc(CTRL_O) != 0x0FU ||
+	    rtt2asc(CTRL_P) != 0x10U ||
+	    rtt2asc(CTRL_Q) != 0x11U ||
+	    rtt2asc(CTRL_R) != 0x12U ||
+	    rtt2asc(CTRL_S) != 0x13U ||
+	    rtt2asc(CTRL_T) != 0x14U ||
+	    rtt2asc(CTRL_U) != 0x15U ||
+	    rtt2asc(CTRL_V) != 0x16U ||
+	    rtt2asc(CTRL_W) != 0x17U ||
+	    rtt2asc(CTRL_X) != 0x18U ||
+	    rtt2asc(CTRL_Y) != 0x19U ||
+	    rtt2asc(CTRL_Z) != 0x1AU ||
+	    rtt2asc(CTRL_BO) != 0x1BU ||
+	    rtt2asc(CTRL_BK) != 0x1CU ||
+	    rtt2asc(CTRL_BC) != 0x1DU ||
+	    rtt2asc(CTRL_CA) != 0x1EU ||
+	    rtt2asc(CTRL_US) != 0x1FU ||
+	    rtt2asc(CTRL_QM) != 0x7FU)
+		goto ebcdic_ctrlmis;
+}
+#endif
+
+#ifdef MKSH__DEBUG_CCLASSES
+/*
+ * This is developer debugging code. It makes no attempt
+ * at being performant, not redundant, have acceptable
+ * style, or anything really.
+ */
+
+static unsigned int
+v(unsigned int c)
+{
+	if (ord(c) == ORD('\\')) {
+		printf("\\\\");
+		return (2);
+	} else if (c < 0x21U || c > 0x7EU) {
+		printf("\\x%02X", c);
+		return (4);
+	} else {
+		putchar(c);
+		return (1);
+	}
+}
+
+#define tabto(len,to) do {		\
+	while (len < to) {		\
+		putchar('\t');		\
+		len = (len | 7) + 1;	\
+	}				\
+} while (/* CONSTCOND */ 0)
+
+static char vert[40][40];
+
+static struct ciname {
+	const char *name;
+	uint32_t val;
+	uint32_t bit;
+} ci[32], *cibit[32];
+
+static int
+cicomp(const void *a_, const void *b_)
+{
+	const struct ciname *a = a_;
+	const struct ciname *b = b_;
+	return (strcmp(a->name, b->name));
+}
+
+static int
+debug_ccls(void)
+{
+	unsigned int i, j, k, x, y, z;
+
+	printf("\t0               1               2               3               4               5               6               7            ->7\n");
+	printf("\t0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF\n");
+#define D(x) do { \
+	printf("%s\t", #x); \
+	for (i = 0; i <= 0x7F; ++i) \
+		putchar(tpl_ctypes[i] & x ? '#' : '-'); \
+	putchar('\n'); \
+} while (/* CONSTCOND */ 0)
+#define DCi() do {	\
+	D(CiIFS);	\
+	D(CiCNTRL);	\
+	D(CiUPPER);	\
+	D(CiLOWER);	\
+	D(CiHEXLT);	\
+	D(CiOCTAL);	\
+	D(CiQCL);	\
+	D(CiALIAS);	\
+	D(CiQCX);	\
+	D(CiVAR1);	\
+	D(CiQCM);	\
+	D(CiDIGIT);	\
+	D(CiQC);	\
+	D(CiSPX);	\
+	D(CiCURLY);	\
+	D(CiANGLE);	\
+	D(CiNUL);	\
+	D(CiTAB);	\
+	D(CiNL);	\
+	D(CiCR);	\
+	D(CiSP);	\
+	D(CiHASH);	\
+	D(CiSS);	\
+	D(CiPERCT);	\
+	D(CiPLUS);	\
+	D(CiMINUS);	\
+	D(CiCOLON);	\
+	D(CiEQUAL);	\
+	D(CiQUEST);	\
+	D(CiBRACK);	\
+	D(CiUNDER);	\
+	D(CiGRAVE);	\
+} while (/* CONSTCOND */ 0)
+	DCi();
+#undef D
+	putchar('\n');
+
+	printf("\t  i i i i i   i       i     i i               i   i i i i i i i\n");
+	printf("\tC C U L H O   A   i   D     C A           i   P i M C E Q B U G\n");
+	printf("\ti N P O E C i L i V i I   i U N i i       H   E P I O Q U R N R\n");
+	printf("\tI T P W X T Q I Q A Q G i S R G N T i i i A i R L N L U E A D A\n");
+	printf("\tF R E E L A C A C R C I Q P L L U A N C S S S C U U O A S C E V\n");
+	printf("\tS L R R T L L S X 1 M T C X Y E L B L R P H S T S S N L T K R E\n");
+	j = 0;
+#define D(x,i1,i2,i3) do { \
+	printf("%s\t", #x); \
+	for (i = 0; i <= 31; ++i) { \
+		printf(x & BIT(i) ? "**" : "- "); \
+		vert[i][j] = (x & BIT(i) ? '#' : '-'); \
+	} \
+	printf("\t%08X\n", x); \
+	++j; \
+} while (/* CONSTCOND */ 0)
+#define DC_() do {	\
+	D(C_ALIAS, 2, 24, "valid characters in alias names"); \
+	D(C_ALNUM, 1, 24, "alphanumerical"); \
+	D(C_ALNUX, 1, 24, "alphanumerical plus underscore (“word character”)"); \
+	D(C_ALPHA, 1, 24, "alphabetical (upper plus lower)"); \
+	D(C_ALPHX, 1, 24, "alphabetical plus underscore (identifier lead)"); \
+	D(C_ASCII, 1, 24, "7-bit ASCII except NUL"); \
+	D(C_BLANK, 0, 24, "tab and space"); \
+	D(C_CNTRL, 1, 24, "POSIX control characters"); \
+	D(C_DIGIT, 1, 24, "decimal digits"); \
+	D(C_EDCMD, 0, 32, "editor x_locate_word() command"); \
+	D(C_EDGLB, 0, 32, "escape for globbing"); \
+	D(C_EDNWC, 0, 32, "editor non-word characters"); \
+	D(C_EDQ, 0, 32, "editor quotes for tab completion"); \
+	D(C_GRAPH, 1, 24, "POSIX graphical (alphanumerical plus punctuation)"); \
+	D(C_HEXLT, 1, 24, "hex letter"); \
+	D(C_IFS, 0, 24, "IFS whitespace, IFS non-whitespace, NUL"); \
+	D(C_IFSWS, 0, 24, "IFS whitespace candidates"); \
+	D(C_LEX1, 0, 24, "(for the lexer)"); \
+	D(C_LOWER, 1, 24, "lowercase letters"); \
+	D(C_MFS, 3, 24, "separator for motion"); \
+	D(C_OCTAL, 1, 24, "octal digit"); \
+	D(C_PATMO, 0, 24, "pattern magical operator, except space"); \
+	D(C_PRINT, 1, 24, "POSIX printable characters (graph plus space)"); \
+	D(C_PUNCT, 0, 40, "POSIX punctuation"); \
+	D(C_QUOTE, 0, 40, "characters requiring quoting, minus space"); \
+	D(C_SEDEC, 1, 24, "hexadecimal digit"); \
+	D(C_SPACE, 1, 24, "POSIX space class"); \
+	D(C_SUB1, 0, 24, "substitution operations with word"); \
+	D(C_SUB2, 0, 24, "substitution operations with pattern"); \
+	D(C_UPPER, 1, 24, "uppercase letters"); \
+	D(C_VAR1, 0, 24, "substitution parameters, other than positional"); \
+} while (/* CONSTCOND */ 0)
+	DC_();
+#undef D
+	putchar('\n');
+
+	for (i = 0; i <= 31; ++i)
+		vert[i][j] = 0;
+	j = 0;
+#define D(x) do { \
+	printf("%s\t%s\n", #x, vert[j++]); \
+} while (/* CONSTCOND */ 0)
+	DCi();
+#undef D
+	putchar('\n');
+
+#define D(x) do {					\
+	y = 0;						\
+	while (BIT(y) != x)				\
+		if (y++ == 31) {			\
+			printf("E: %s=%X\n", #x, x);	\
+			exit(255);			\
+		}					\
+	ci[y].name = #x;				\
+	ci[y].val = x;				\
+	ci[y].bit = y;					\
+} while (/* CONSTCOND */ 0)
+	DCi();
+#undef D
+	qsort(ci, NELEM(ci), sizeof(struct ciname), &cicomp);
+	for (i = 0; i < NELEM(ci); ++i) {
+		cibit[ci[i].bit] = &ci[i];
+		printf("BIT(%d)\t%08X  %s\n", ci[i].bit, ci[i].val, ci[i].name);
+	}
+	putchar('\n');
+
+#define D(x) do { \
+	if (x != CiIFS && (ksh_ctypes[i] & x)) { \
+		if (z) { \
+			printf(" | "); \
+			z += 3; \
+		} \
+		printf("%s", #x); \
+		z += strlen(#x); \
+	} \
+} while (/* CONSTCOND */ 0)
+	printf("// shf.c {{{ begin\n/* fast character classes */\n");
+	printf("const uint32_t tpl_ctypes[128] = {\n");
+	x = 0, y = 0; /* fsck GCC */
+	for (i = 0; i <= 0x7F; ++i) {
+		if (!(i & 0x0F)) {
+			printf("\t/* 0x%02X */\n", i);
+			x = 1; /* did newline */
+		}
+		if (x) {
+			printf("\t");
+			x = 0;
+			y = 16;
+		}
+		z = 0;
+		DCi();
+		if (i != 0x7F) {
+			putchar(',');
+			++z;
+		}
+		if (((i & 0x03) == 0x03) || ((i & 0x59) == 0x41)) {
+			putchar('\n');
+			x = 1;
+		} else {
+			if ((i & 0x58) == 0x40)
+				y = 24;
+			tabto(z, y);
+			if (z > 16) {
+				y = 8;
+				tabto(z, 24);
+			}
+		}
+	}
+#undef D
+	printf("};\n// shf.c }}} end\n\n");
+
+#define putrangef(len,cond,count) do {			\
+	for (count = 0; count <= 0xFF; ++count)		\
+		if (ksh_ctypes[count] & cond)		\
+			len += v(count);		\
+} while (/* CONSTCOND */ 0)
+#define putranget(len,cond,count,hold,flag) do {	\
+	flag = 0;					\
+	count = -1;					\
+	while (1) {					\
+		++count;				\
+		if (!flag) {				\
+			if (count > 0xFF)		\
+				break;			\
+			if (ksh_ctypes[count] & cond) {	\
+				hold = count;		\
+				flag = 1;		\
+			}				\
+		} else if (count > 0xFF ||		\
+		    !(ksh_ctypes[count] & cond)) {	\
+			flag = count - 1;		\
+			len += v(hold);			\
+			if (flag == hold + 1) {		\
+				len += v(flag);		\
+			} else if (flag > hold) {	\
+				printf("‥");		\
+				len += 1 + v(flag);	\
+			}				\
+			if (count > 0xFF)		\
+				break;			\
+			flag = 0;			\
+		}					\
+	}						\
+} while (/* CONSTCOND */ 0)
+#define putrangea(len,cond,count,hold,flag) do {	\
+	flag = 0;					\
+	count = -1;					\
+	while (1) {					\
+		++count;				\
+		if (!flag) {				\
+			if (count > 0xFF)		\
+				break;			\
+			if (ksh_ctypes[count] & cond) {	\
+				len += v(count);	\
+				hold = count;		\
+				flag = count == '0' ||	\
+				    count == 'A' ||	\
+				    count == 'a';	\
+			}				\
+		} else if (count > 0xFF ||		\
+		    !(ksh_ctypes[count] & cond)) {	\
+			flag = count - 1;		\
+			if (flag == hold + 1) {		\
+				len += v(flag);		\
+			} else if (flag > hold) {	\
+				printf("‥");		\
+				len += 1 + v(flag);	\
+			}				\
+			if (count > 0xFF)		\
+				break;			\
+			flag = 0;			\
+		} else if ((count - 1) == '9' ||	\
+		    (count - 1) == 'Z' ||		\
+		    (count - 1) == 'z') {		\
+			flag = count - 1;		\
+			if (flag == hold + 1) {		\
+				len += v(flag);		\
+			} else if (flag > hold) {	\
+				printf("‥");		\
+				len += 1 + v(flag);	\
+			}				\
+			len += v(count);		\
+			flag = 0;			\
+		}					\
+	}						\
+} while (/* CONSTCOND */ 0)
+
+#define DD(n,x,ign) do {				\
+	y = 0;						\
+	while (BIT(y) != x)				\
+		if (y++ == 31) {			\
+			printf("E: %s=%X\n", n, x);	\
+			exit(255);			\
+		}					\
+	printf("#define %s\tBIT(%d)", n, y);		\
+	if (x != ign) {					\
+		printf("\t/* ");			\
+		y = 3;					\
+		switch (x) {				\
+		case CiCNTRL:				\
+		case CiUPPER: case CiLOWER:		\
+		case CiHEXLT: case CiOCTAL:		\
+			putranget(y, x, i, j, k);	\
+			break;				\
+		default:				\
+			putrangef(y, x, i);		\
+		}					\
+		tabto(y, 32);				\
+		printf("*/");				\
+	}						\
+	putchar('\n');					\
+} while (/* CONSTCOND */ 0)
+	DD("??IFS", CiIFS, CiCNTRL);
+
+	printf("// sh.h {{{ begin\n/*\n * fast character classes\n */\n\n");
+	printf("/* internal types, do not reference */\n\n");
+
+#define D(x) DD(#x, x, CiIFS)
+	printf("/* initially empty — filled at runtime from $IFS */\n");
+	DCi();
+#undef DD
+#undef D
+	printf("/* out of space, but one for *@ would make sense, possibly others */\n\n");
+
+	printf("/* compile-time initialised, ASCII only */\n"
+		"extern const uint32_t tpl_ctypes[128];\n"
+		"/* run-time, contains C_IFS as well, full 2⁸ octet range */\n"
+		"EXTERN uint32_t ksh_ctypes[256];\n"
+		"/* first octet of $IFS, for concatenating \"$*\" */\n"
+		"EXTERN char ifs0;\n"
+		"\n");
+
+#define expcond(cond,len,cnt,flg,fnd,cnd) do {		\
+	flg = 1;					\
+	for (cnt = 0; cnt < NELEM(ci); ++cnt)		\
+		if (cond == ci[cnt].val) {		\
+			len += printf("%s",		\
+			    ci[cnt].name);		\
+			flg = 0;			\
+			break;				\
+		}					\
+	if (flg) {					\
+		cnd = cond;				\
+		fnd = 0;				\
+		if (cnd != C_GRAPH &&			\
+		    (cnd & C_GRAPH) == C_GRAPH) {	\
+			len += printf("%s%s",		\
+			    fnd ? " | " : "(",		\
+			    "C_GRAPH");			\
+			fnd = 1;			\
+			cnd &= ~C_GRAPH;		\
+		}					\
+		if (cnd != C_PUNCT &&			\
+		    (cnd & C_PUNCT) == C_PUNCT) {	\
+			len += printf("%s%s",		\
+			    fnd ? " | " : "(",		\
+			    "C_PUNCT");			\
+			fnd = 1;			\
+			cnd &= ~C_PUNCT;		\
+		}					\
+		for (cnt = 0; cnt < NELEM(ci); ++cnt)	\
+		   if (cnd & ci[cnt].val) {		\
+			len += printf("%s%s",		\
+			    fnd ? " | " : "(",		\
+			    ci[cnt].name);		\
+			fnd = 1;			\
+		}					\
+		if (!fnd) {				\
+			printf("<ERR>\n");		\
+			exit(255);			\
+		}					\
+		putchar(')');				\
+		++len;					\
+	}						\
+} while (/* CONSTCOND */ 0)
+
+	set_ccls(); /* drop CiIFS from ksh_ctypes */
+#define D(cond,rng,tabstop,lbl) do {			\
+	printf("/* ");					\
+	y = 3;						\
+	switch (rng) {					\
+	case 0:						\
+		putrangef(y, cond, i);			\
+		break;					\
+	case 1:						\
+		putranget(y, cond, i, j, k);		\
+		break;					\
+	case 2:						\
+		putrangea(y, cond, i, j, k);		\
+		break;					\
+	case 3:						\
+		for (i = 0; i <= 0x7F; ++i) {		\
+			if (!!(ksh_ctypes[i] & cond) ^	\
+			    !!(ksh_ctypes[i] & (	\
+			    C_ALNUX | CiSS)))		\
+				continue;		\
+			printf("<ERR(%02X)>\n", i);	\
+			exit(255);			\
+		}					\
+		y += printf("not alnux or dollar");	\
+		break;					\
+	}						\
+	if (cond & CiIFS)				\
+		y += printf(" + $IFS");			\
+	tabto(y, tabstop);				\
+	printf("%s */\n#define %s\t", lbl, #cond);	\
+	expcond(cond, y, i, z, j, k);			\
+	putchar('\n');					\
+} while (/* CONSTCOND */ 0)
+	printf("/* external types */\n\n");
+	DC_();
+#undef D
+
+#define D(x,lbl) do {			\
+	y = printf("#define %s", #x);	\
+	tabto(y, 16);			\
+	expcond(x, y, i, z, j, k);	\
+	tabto(y, 32);			\
+	y += printf("/* ");		\
+	putrangef(y, x, i);		\
+	tabto(y, 40);			\
+	printf("%s */\n", lbl);		\
+} while (/* CONSTCOND */ 0)
+	printf("\n/* individual chars you might like */\n");
+	D(C_ANGLE, "angle brackets");
+	D(C_COLON, "colon");
+	D(C_CR, "ASCII carriage return");
+	D(C_DOLAR, "dollar sign");
+	D(C_EQUAL, "equals sign");
+	D(C_GRAVE, "accent gravis");
+	D(C_HASH, "hash sign");
+	D(C_LF, "ASCII line feed");
+	D(C_MINUS, "hyphen-minus");
+	printf("#ifdef MKSH_WITH_TEXTMODE\n"
+		"#define C_NL\t(CiNL | CiCR)\t/*\tCR or LF under OS/2 TEXTMODE */\n"
+		"#else\n"
+		"#define C_NL\tCiNL\t\t/*\tLF only like under Unix */\n"
+		"#endif\n");
+	D(C_NUL, "ASCII NUL");
+	D(C_PLUS, "plus sign");
+	D(C_QC, "quote characters");
+	D(C_QUEST, "question mark");
+	D(C_SPC, "ASCII space");
+	D(C_TAB, "ASCII horizontal tabulator");
+	D(C_UNDER, "underscore");
+
+	printf("// sh.h }}} end\n");
+	return (ksh_ctypes[0] == CiNUL);
 }
 #endif
--- mksh-59c.orig/syn.c
+++ mksh-59c/syn.c
@@ -3,7 +3,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017,
- *		 2018, 2020
+ *		 2018, 2020, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -24,7 +24,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.129 2020/10/31 01:21:58 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/syn.c,v 1.133 2021/10/10 21:36:54 tg Exp $");
 
 struct nesting_state {
 	int start_token;	/* token than began nesting (eg, FOR) */
@@ -74,8 +74,8 @@ static int symbol;			/* yylex value */
 
 #define REJECT		(reject = true)
 #define ACCEPT		(reject = false)
-#define token(cf)	((reject) ? (ACCEPT, symbol) : (symbol = yylex(cf)))
-#define tpeek(cf)	((reject) ? (symbol) : (REJECT, symbol = yylex(cf)))
+#define token(cf)	((reject ? 0 : (symbol = yylex(cf))), ACCEPT, symbol)
+#define tpeek(cf)	((reject ? 0 : (symbol = yylex(cf))), REJECT, symbol)
 #define musthave(c,cf)	do { 					\
 	if ((unsigned int)token(cf) != (unsigned int)(c))	\
 		syntaxerr(NULL);				\
@@ -221,7 +221,7 @@ synio(int cf)
 		nextiop = alloc(sizeof(*iop), ATEMP);
 		nextiop->ioname = cp = alloc(3, ATEMP);
 		*cp++ = CHAR;
-		*cp++ = digits_lc[iop->unit % 10];
+		*cp++ = digits_lc[iop->unit];
 		*cp = EOS;
 
 		iop->ioflag &= ~IOBASH;
@@ -924,14 +924,12 @@ newtp(int type)
 }
 
 struct op *
-compile(Source *s, bool skiputf8bom, bool doalias)
+compile(Source *s, bool doalias)
 {
 	nesting.start_token = 0;
 	nesting.start_line = 0;
 	herep = heres;
 	source = s;
-	if (skiputf8bom)
-		yyskiputf8bom();
 	yyparse(doalias);
 	return (outtree);
 }
@@ -948,7 +946,6 @@ inalias(struct source *s)
 	return (0);
 }
 
-
 /*
  * Order important - indexed by Test_meta values
  * Note that ||, &&, ( and ) can't appear in as unquoted strings
--- mksh-59c.orig/tree.c
+++ mksh-59c/tree.c
@@ -2,7 +2,7 @@
 
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
- *		 2011, 2012, 2013, 2015, 2016, 2017
+ *		 2011, 2012, 2013, 2015, 2016, 2017, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -23,7 +23,7 @@
 
 #include "sh.h"
 
-__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.100 2020/10/31 04:28:54 tg Exp $");
+__RCSID("$MirOS: src/bin/mksh/tree.c,v 1.111 2021/10/16 02:20:02 tg Exp $");
 
 #define INDENT	8
 
@@ -43,8 +43,12 @@ static bool ptree_hashere;
 static struct shf ptree_heredoc;
 #define ptree_outhere(shf) do {					\
 	if (ptree_hashere) {					\
-		shf_puts(shf_sclose(&ptree_heredoc), (shf));	\
+		char *ptree_thehere;				\
+								\
+		ptree_thehere = shf_sclose(&ptree_heredoc);	\
+		shf_puts(ptree_thehere, (shf));			\
 		shf_putc('\n', (shf));				\
+		afree(ptree_thehere, ATEMP);			\
 		ptree_hashere = false;				\
 		/*prevent_semicolon = true;*/			\
 	}							\
@@ -300,7 +304,8 @@ pioact(struct shf *shf, struct ioword *i
 		shf_puts("<>", shf);
 		break;
 	case IODUP:
-		shf_puts(flag & IORDUP ? "<&" : ">&", shf);
+		shf_putc(flag & IORDUP ? '<' : '>', shf);
+		shf_putc('&', shf);
 		break;
 	}
 	/* name is NULL for IOHERE or when printing syntax errors */
@@ -416,7 +421,8 @@ wdvarput(struct shf *shf, const char *wp
 			}
 			return (wp);
 		case OPAT:
-			shf_putchar(*wp++, shf);
+			c = *wp++;
+			shf_putc(c, shf);
 			shf_putc('(', shf);
 			break;
 		case SPAT:
@@ -473,10 +479,6 @@ vfptreef(struct shf *shf, int indent, co
 	while ((c = ord(*fmt++))) {
 		if (c == '%') {
 			switch ((c = ord(*fmt++))) {
-			case ORD('c'):
-				/* character (octet, probably) */
-				shf_putchar(va_arg(va, int), shf);
-				break;
 			case ORD('s'):
 				/* string */
 				shf_puts(va_arg(va, char *), shf);
@@ -523,6 +525,10 @@ vfptreef(struct shf *shf, int indent, co
 				/* I/O redirection */
 				pioact(shf, va_arg(va, struct ioword *));
 				break;
+			case ORD('c'):
+				/* character (octet, probably) */
+				c = va_arg(va, int);
+				/* FALLTHROUGH */
 			default:
 				shf_putc(c, shf);
 				break;
@@ -779,64 +785,300 @@ fpFUNCTf(struct shf *shf, int i, bool is
 		fptreef(shf, i, "%s() %T", k, v);
 }
 
-
-/* for jobs.c */
 void
-vistree(char *dst, size_t sz, struct op *t)
+uprntc(unsigned char c, struct shf *shf)
+{
+	unsigned char a;
+
+	if (ctype(c, C_PRINT)) {
+ doprnt:
+		shf_putc(c, shf);
+		return;
+	}
+
+	if (!UTFMODE) {
+		if (!ksh_isctrl8(c))
+			goto doprnt;
+		if ((a = rtt2asc(c)) >= 0x80U) {
+			shf_scheck(3, shf);
+			shf_putc('^', shf);
+			shf_putc('!', shf);
+			a &= 0x7FU;
+			goto unctrl;
+		}
+	} else if ((a = rtt2asc(c)) >= 0x80U) {
+		shf_scheck(4, shf);
+		shf_putc('\\', shf);
+		shf_putc('x', shf);
+		shf_putc(digits_uc[(a >> 4) & 0x0F], shf);
+		shf_putc(digits_uc[a & 0x0F], shf);
+		return;
+	}
+	shf_scheck(2, shf);
+	shf_putc('^', shf);
+ unctrl:
+	shf_putc(asc2rtt(a ^ 0x40U), shf);
+}
+
+#ifndef MKSH_NO_CMDLINE_EDITING
+/*
+ * For now, these are only used by the edit code, which requires
+ * a difference: tab is output as three spaces, not as control
+ * character in caret notation. If these will ever be used else‐
+ * where split them up.
+ */
+/*size_t*/ void
+uescmbT(unsigned char *dst, const char **cpp)
+{
+	unsigned char c;
+	unsigned int wc;
+	size_t n, dstsz = 0;
+	const char *cp = *cpp;
+
+	c = *cp++;
+	/* test cheap first (easiest) */
+	if (ctype(c, C_PRINT)) {
+ prntb:
+		dst[dstsz++] = c;
+		goto out;
+	}
+	/* differently from uprntc, note tab as three spaces */
+	if (ord(c) == CTRL_I) {
+		dst[dstsz++] = ' ';
+		dst[dstsz++] = ' ';
+		dst[dstsz++] = ' ';
+		goto out;
+	}
+
+	/* more specialised tests depend on shell state */
+	if (UTFMODE) {
+		/* wc = rtt2asc(c) except UTF-8 is decoded */
+		if ((n = utf_mbtowc(&wc, cp - 1)) == (size_t)-1) {
+			/* failed: invalid UTF-8 */
+			wc = rtt2asc(c);
+			dst[dstsz++] = '\\';
+			dst[dstsz++] = 'x';
+			dst[dstsz++] = digits_uc[(wc >> 4) & 0x0F];
+			dst[dstsz++] = digits_uc[wc & 0x0F];
+			goto out;
+		}
+		/*
+		 * printable as-is? U+0020‥U+007E already handled
+		 * above as they are C_PRINT, U+00A0 or higher are
+		 * not escaped either, anything in between is special
+		 */
+		if (wc >= 0xA0U) {
+			dst[dstsz++] = c;
+			switch (n) {
+#ifdef notyet
+			case 4:
+				dst[dstsz++] = *cp++;
+				/* FALLTHROUGH */
+#endif
+			case 3:
+				dst[dstsz++] = *cp++;
+				/* FALLTHROUGH */
+			default:
+				dst[dstsz++] = *cp++;
+				break;
+			}
+			goto out;
+		}
+		/* and encoded with either 1 or 2 octets */
+
+		/* C1 control character, UTF-8 encoded */
+		if (wc >= 0x80U) {
+			/* n == 2 so we miss one out */
+			++cp;
+
+			c = '+';
+			goto prntC1;
+		}
+		/* nope, must be C0 or DEL */
+		/* n == 1 so cp needs no adjustment */
+		goto prntC0;
+	}
+
+	/* not UTFMODE allows more but the test is more expensive */
+	if (!ksh_isctrl8(c))
+		goto prntb;
+	/* UTF-8 is not decoded, we just transfer an octet to ASCII */
+	wc = rtt2asc(c);
+	/* C1 control character octet? */
+	if (wc >= 0x80U) {
+		c = '!';
+ prntC1:
+		dst[dstsz++] = '^';
+		dst[dstsz++] = c;
+		wc &= 0x7FU;
+	} else {
+		/* nope, so C0 or DEL, anything else went to prntb */
+ prntC0:
+		dst[dstsz++] = '^';
+	}
+	dst[dstsz++] = asc2rtt(wc ^ 0x40U);
+
+ out:
+	*cpp = cp;
+	dst[dstsz] = '\0';
+#ifdef usedoutsideofedit
+	return (dstsz);
+#endif
+}
+
+int
+uwidthmbT(char *cp, char **dcp)
 {
-	unsigned int c;
-	char *cp, *buf;
+	unsigned char c;
+	unsigned int wc;
+	int w;
 	size_t n;
 
-	buf = alloc(sz + 16, ATEMP);
-	snptreef(buf, sz + 16, Tf_T, t);
-	cp = buf;
- vist_loop:
-	if (UTFMODE && (n = utf_mbtowc(&c, cp)) != (size_t)-1) {
-		if (c == 0 || n >= sz)
-			/* NUL or not enough free space */
-			goto vist_out;
-		/* copy multibyte char */
-		sz -= n;
-		while (n--)
-			*dst++ = *cp++;
-		goto vist_loop;
-	}
-	if (--sz == 0 || (c = ord(*cp++)) == 0)
-		/* NUL or not enough free space */
-		goto vist_out;
-	if (ksh_isctrl(c)) {
-		/* C0 or C1 control character or DEL */
-		if (--sz == 0)
-			/* not enough free space for two chars */
-			goto vist_out;
-		*dst++ = '^';
-		c = ksh_unctrl(c);
-	} else if (UTFMODE && rtt2asc(c) > 0x7F) {
-		/* better not try to display broken multibyte chars */
-		/* also go easy on the UCS: no U+FFFD here */
-		c = ORD('?');
-	}
-	*dst++ = c;
-	goto vist_loop;
-
- vist_out:
-	*dst = '\0';
-	afree(buf, ATEMP);
+	c = *cp++;
+	/* test cheap first (easiest) */
+	if (ctype(c, C_PRINT)) {
+ prntb:
+		w = 1;
+		goto out;
+	}
+	/* differently from uprntc, note tab as three spaces */
+	if (ord(c) == CTRL_I) {
+		w = 3;
+		goto out;
+	}
+
+	/* more specialised tests depend on shell state */
+	if (UTFMODE) {
+		/* wc = rtt2asc(c) except UTF-8 is decoded */
+		if ((n = utf_mbtowc(&wc, cp - 1)) == (size_t)-1) {
+			/* \x## */
+			w = 4;
+			goto out;
+		}
+		cp += n - 1;
+		/*
+		 * printable as-is? U+0020‥U+007E already handled
+		 * above as they are C_PRINT, U+00A0 or higher are
+		 * not escaped either, anything in between is special
+		 */
+		if (wc >= 0xA0U) {
+			w = utf_wcwidth(wc);
+			goto out;
+		}
+		/* and encoded with either 1 or 2 octets */
+
+		/* C1 control character, UTF-8 encoded */
+		if (wc >= 0x80U)
+			goto prntC1;
+		/* nope, must be C0 or DEL */
+		goto prntC0;
+	}
+
+	/* not UTFMODE allows more but the test is more expensive */
+	if (!ksh_isctrl8(c))
+		goto prntb;
+	/* UTF-8 is not decoded, we just transfer an octet to ASCII */
+	wc = rtt2asc(c);
+	/* C1 control character octet? */
+	if (wc >= 0x80U) {
+ prntC1:
+		w = 3;
+	} else {
+		/* nope, so C0 or DEL, anything else went to prntb */
+ prntC0:
+		w = 2;
+	}
+
+ out:
+	if (dcp)
+		*dcp = cp;
+	return (w);
 }
+#endif
 
-#ifdef DEBUG
-void
-dumpchar(struct shf *shf, unsigned char c)
+const char *
+uprntmbs(const char *cp, bool esc_caret, struct shf *shf)
 {
-	if (ksh_isctrl(c)) {
-		/* C0 or C1 control character or DEL */
-		shf_putc('^', shf);
-		c = ksh_unctrl(c);
+	unsigned char c;
+	unsigned int wc;
+	size_t n;
+
+	while ((c = *cp++) != 0) {
+		/* test cheap first (easiest) */
+		if (ctype(c, C_PRINT)) {
+			if (esc_caret && (c == ORD('\\') || c == ORD('^'))) {
+				shf_scheck(2, shf);
+				shf_putc('\\', shf);
+			}
+ prntb:
+			shf_putc(c, shf);
+			continue;
+		}
+
+		/* more specialised tests depend on shell state */
+		if (UTFMODE) {
+			/* wc = rtt2asc(c) except UTF-8 is decoded */
+			if ((n = utf_mbtowc(&wc, cp - 1)) == (size_t)-1) {
+				/* failed: invalid UTF-8 */
+				wc = rtt2asc(c);
+				shf_scheck(4, shf);
+				shf_putc('\\', shf);
+				shf_putc('x', shf);
+				shf_putc(digits_uc[(wc >> 4) & 0x0F], shf);
+				shf_putc(digits_uc[wc & 0x0F], shf);
+				continue;
+			}
+			/*
+			 * printable as-is? U+0020‥U+007E already handled
+			 * above as they are C_PRINT, U+00A0 or higher are
+			 * not escaped either, anything in between is special
+			 */
+			if (wc >= 0xA0U) {
+				--cp;
+				shf_wr_sm(cp, n, shf);
+				continue;
+			}
+			/* and encoded with either 1 or 2 octets */
+
+			/* C1 control character, UTF-8 encoded */
+			if (wc >= 0x80U) {
+				/* n == 2 so we miss one out */
+				++cp;
+
+				c = '+';
+				goto prntC1;
+			}
+			/* nope, must be C0 or DEL */
+			/* n == 1 so cp needs no adjustment */
+			goto prntC0;
+		}
+
+		/* not UTFMODE allows more but the test is more expensive */
+		if (!ksh_isctrl8(c))
+			goto prntb;
+		/* UTF-8 is not decoded, we just transfer an octet to ASCII */
+		wc = rtt2asc(c);
+		/* C1 control character octet? */
+		if (wc >= 0x80U) {
+			c = '!';
+ prntC1:
+			shf_scheck(3, shf);
+			shf_putc('^', shf);
+			shf_putc(c, shf);
+			wc &= 0x7FU;
+		} else {
+			/* nope, so C0 or DEL, anything else went to prntb */
+ prntC0:
+			shf_scheck(2, shf);
+			shf_putc('^', shf);
+		}
+		shf_putc(asc2rtt(wc ^ 0x40U), shf);
 	}
-	shf_putc(c, shf);
+	/* point to the trailing NUL for continuation */
+	return ((const void *)(cp - 1));
 }
 
+#ifdef DEBUG
 /* see: wdvarput */
 static const char *
 dumpwdvar_i(struct shf *shf, const char *wp, int quotelevel)
@@ -844,7 +1086,7 @@ dumpwdvar_i(struct shf *shf, const char
 	int c;
 
 	while (/* CONSTCOND */ 1) {
-		switch(*wp++) {
+		switch (*wp++) {
 		case EOS:
 			shf_puts("EOS", shf);
 			return (--wp);
@@ -858,7 +1100,7 @@ dumpwdvar_i(struct shf *shf, const char
 				/* FALLTHROUGH */
 		case CHAR:
 			  shf_puts("CHAR=", shf);
-			dumpchar(shf, *wp++);
+			uprntc(*wp++, shf);
 			break;
 		case QCHAR:
 			shf_puts("QCHAR<", shf);
@@ -866,7 +1108,7 @@ dumpwdvar_i(struct shf *shf, const char
 			if (quotelevel == 0 || c == ORD('"') ||
 			    c == ORD('\\') || ctype(c, C_DOLAR | C_GRAVE))
 				shf_putc('\\', shf);
-			dumpchar(shf, c);
+			uprntc(c, shf);
 			goto closeandout;
 		case COMASUB:
 			shf_puts("COMASUB<", shf);
@@ -874,8 +1116,7 @@ dumpwdvar_i(struct shf *shf, const char
 		case COMSUB:
 			shf_puts("COMSUB<", shf);
  dumpsub:
-			while ((c = *wp++) != 0)
-				dumpchar(shf, c);
+			wp = uprntmbs(wp, false, shf) + 1;
  closeandout:
 			shf_putc('>', shf);
 			break;
@@ -903,21 +1144,20 @@ dumpwdvar_i(struct shf *shf, const char
 			break;
 		case OSUBST:
 			shf_puts("OSUBST(", shf);
-			dumpchar(shf, *wp++);
+			uprntc(*wp++, shf);
 			shf_puts(")[", shf);
-			while ((c = *wp++) != 0)
-				dumpchar(shf, c);
+			wp = uprntmbs(wp, false, shf) + 1;
 			shf_putc('|', shf);
 			wp = dumpwdvar_i(shf, wp, 0);
 			break;
 		case CSUBST:
 			shf_puts("]CSUBST(", shf);
-			dumpchar(shf, *wp++);
+			uprntc(*wp++, shf);
 			shf_putc(')', shf);
 			return (wp);
 		case OPAT:
 			shf_puts("OPAT=", shf);
-			dumpchar(shf, *wp++);
+			uprntc(*wp++, shf);
 			break;
 		case SPAT:
 			shf_puts("SPAT", shf);
@@ -926,7 +1166,7 @@ dumpwdvar_i(struct shf *shf, const char
 			shf_puts("CPAT", shf);
 			break;
 		default:
-			shf_fprintf(shf, "INVAL<%u>", (uint8_t)wp[-1]);
+			shf_fprintf(shf, "INVAL<%u>", (kby)wp[-1]);
 			break;
 		}
 		shf_putc(' ', shf);
@@ -1179,4 +1419,47 @@ dumptree(struct shf *shf, struct op *t)
 	shf_fprintf(shf, /*{*/ " /%s}\n", name);
 	--nesting;
 }
+
+void
+dumphex(struct shf *shf, const void *buf, size_t len)
+{
+	const kby *s = buf;
+	size_t i = 0;
+
+	if (!len--) {
+		shf_puts("00000000  <\n", shf);
+		goto out;
+	}
+
+ loop:
+	if ((i & 0xFU) == 0x0U)
+		shf_fprintf(shf, "%08zX  ", i);
+	else if ((i & 0xFU) == 0x8U)
+		shf_puts("- ", shf);
+	shf_fprintf(shf, "%02X%c", ord(s[i]), i == len ? '<' : ' ');
+	if (i < len && (i & 0xFU) != 0xFU) {
+		++i;
+		goto loop;
+	}
+	while ((i & 0xFU) != 0xFU) {
+		++i;
+		if ((i & 0xFU) == 0x8U)
+			shf_puts("  ", shf);
+		shf_puts("   ", shf);
+	}
+	shf_puts(" |", shf);
+	i &= (size_t)~(size_t)0xFU;
+ visloop:
+	if (i <= len) {
+		shf_putc(ctype(s[i], C_PRINT) ? ord(s[i]) : '.', shf);
+		++i;
+		if ((i & 0xFU) != 0x0U)
+			goto visloop;
+	}
+	shf_puts("|\n", shf);
+	if (i <= len)
+		goto loop;
+ out:
+	shf_flush(shf);
+}
 #endif
--- mksh-59c.orig/var.c
+++ mksh-59c/var.c
@@ -3,7 +3,7 @@
 /*-
  * Copyright (c) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
  *		 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
- *		 2019
+ *		 2019, 2021
  *	mirabilos <m@mirbsd.org>
  *
  * Provided that these terms and disclaimer and all copyright notices
@@ -29,7 +29,14 @@
 #include <sys/sysctl.h>
 #endif
 
-__RCSID("$MirOS: src/bin/mksh/var.c,v 1.237 2020/06/22 17:11:03 tg Exp $");
+#if HAVE_SYS_PTEM_H
+/* prerequisite */
+#include <sys/stream.h>
+/* struct winsize */
+#include <sys/ptem.h>
+#endif
+
+__RCSID("$MirOS: src/bin/mksh/var.c,v 1.252 2021/09/30 03:20:12 tg Exp $");
 
 /*-
  * Variables
@@ -46,6 +53,14 @@ static uint32_t lcg_state = 5381, qh_sta
 /* may only be set by typeset() just before call to array_index_calc() */
 static enum namerefflag innermost_refflag = SRF_NOP;
 
+/*
+ * Evil hack since casting uint to sint is implementation-defined
+ */
+typedef union {
+	mksh_ari_t i;
+	mksh_uari_t u;
+} mksh_ari_u;
+
 static void c_typeset_vardump(struct tbl *, uint32_t, int, int, bool, bool);
 static void c_typeset_vardump_recursive(struct block *, uint32_t, int, bool,
     bool);
@@ -57,6 +72,7 @@ static void getspec(struct tbl *);
 static void setspec(struct tbl *);
 static void unsetspec(struct tbl *, bool);
 static int getint(struct tbl *, mksh_ari_u *, bool);
+static int getnum(const char *, mksh_ari_u *, bool, bool);
 static const char *array_index_calc(const char *, bool *, uint32_t *);
 static struct tbl *vtypeset(int *, const char *, uint32_t, uint32_t, int, int);
 
@@ -414,21 +430,17 @@ str_val(struct tbl *vp)
 			n = (vp->val.i < 0) ? -vp->val.u : vp->val.u;
 		base = (vp->type == 0) ? 10U : (unsigned int)vp->type;
 
-		if (base == 1 && n == 0)
-			base = 2;
 		if (base == 1) {
-			size_t sz = 1;
-
-			*(s = strbuf) = '1';
+			s = strbuf;
 			s[1] = '#';
-			if (!UTFMODE)
-				s[2] = (unsigned char)n;
-			else if ((n & 0xFF80) == 0xEF80)
-				/* OPTU-16 -> raw octet */
-				s[2] = asc2rtt(n & 0xFF);
-			else
-				sz = utf_wctomb(s + 2, n);
-			s[2 + sz] = '\0';
+			if (n == 0) {
+				s[0] = '2';
+				s[2] = '0';
+				s[3] = '\0';
+			} else {
+				s[0] = '1';
+				s[2 + ez_ctomb(s + 2, n)] = '\0';
+			}
 		} else {
 			*--s = '\0';
 			do {
@@ -494,6 +506,7 @@ setstr(struct tbl *vq, const char *s, in
 			vq->flag |= ALLOC;
 			vq->type = 0;
 		}
+		vq->flag &= ~IMPORT;
 		afree(salloc, ATEMP);
 	} else {
 		/* integer dest */
@@ -527,10 +540,6 @@ setint(struct tbl *vq, mksh_ari_t n)
 static int
 getint(struct tbl *vp, mksh_ari_u *nump, bool arith)
 {
-	mksh_uari_t c, num = 0, base = 10;
-	const char *s;
-	bool have_base = false, neg = false;
-
 	if (vp->flag & SPECIAL)
 		getspec(vp);
 	/* XXX is it possible for ISSET to be set and val.s to be NULL? */
@@ -540,7 +549,15 @@ getint(struct tbl *vp, mksh_ari_u *nump,
 		nump->i = vp->val.i;
 		return (vp->type);
 	}
-	s = vp->val.s + vp->type;
+	return (getnum(vp->val.s + vp->type, nump, arith,
+	    Flag(FPOSIX) && !(vp->flag & ZEROFIL)));
+}
+
+static int
+getnum(const char *s, mksh_ari_u *nump, bool arith, bool psxoctal)
+{
+	mksh_uari_t c, num = 0, base = 10;
+	bool have_base = false, neg = false;
 
 	do {
 		c = (unsigned char)*s++;
@@ -561,8 +578,7 @@ getint(struct tbl *vp, mksh_ari_u *nump,
 			base = 16;
 			++s;
 			goto getint_c_style_base;
-		} else if (Flag(FPOSIX) && ctype(s[0], C_DIGIT) &&
-		    !(vp->flag & ZEROFIL)) {
+		} else if (psxoctal && ctype(s[0], C_DIGIT)) {
 			/* interpret as octal (deprecated) */
 			base = 8;
  getint_c_style_base:
@@ -580,16 +596,7 @@ getint(struct tbl *vp, mksh_ari_u *nump,
 				/* mksh-specific extension */
 				unsigned int wc;
 
-				if (!UTFMODE)
-					wc = *(const unsigned char *)s;
-				else if (utf_mbtowc(&wc, s) == (size_t)-1)
-					/* OPTU-8 -> OPTU-16 */
-					/*
-					 * (with a twist: 1#\uEF80 converts
-					 * the same as 1#\x80 does, thus is
-					 * not round-tripping correctly XXX)
-					 */
-					wc = 0xEF00 + rtt2asc(*s);
+				ez_mbtoc(&wc, s);
 				nump->u = (mksh_uari_t)wc;
 				return (1);
 			} else if (base > 36)
@@ -641,10 +648,11 @@ setint_v(struct tbl *vq, struct tbl *vp,
 void
 setint_n(struct tbl *vq, mksh_ari_t num, int newbase)
 {
-	if (!(vq->flag & INTEGER) && (vq->flag & ALLOC)) {
-		vq->flag &= ~ALLOC;
+	if (!(vq->flag & INTEGER)) {
+		if (vq->flag & ALLOC)
+			afree(vq->val.s, vq->areap);
+		vq->flag &= ~(ALLOC | IMPORT);
 		vq->type = 0;
-		afree(vq->val.s, vq->areap);
 	}
 	vq->val.i = num;
 	if (newbase != 0)
@@ -679,14 +687,14 @@ formatstr(struct tbl *vp, const char *s)
 			const char *qq;
 			int n = 0;
 
-			qq = utf_skipcols(s, slen, &slen);
+			qq = s + strlen(s);
 
 			/* strip trailing spaces (AT&T uses qq[-1] == ' ') */
 			while (qq > s && ctype(qq[-1], C_SPACE)) {
 				--qq;
 				--slen;
 			}
-			if (vp->flag & ZEROFIL && vp->flag & INTEGER) {
+			if (HAS(vp->flag, ZEROFIL | INTEGER)) {
 				if (!s[0] || !s[1])
 					goto uhm_no;
 				if (s[1] == '#')
@@ -750,7 +758,7 @@ exportprep(struct tbl *vp, const char *v
 	vp->val.s = aresizeif(cursz, cp, vp->type + vallen, vp->areap);
 	memmove(vp->val.s + vp->type, val == cp ? vp->val.s : val, vallen);
 	memcpy(vp->val.s, vp->name, namelen);
-	vp->val.s[namelen] = '=';
+	((char *)(vp->val.s))[namelen] = '=';
 }
 
 /*
@@ -798,7 +806,7 @@ vtypeset(int *ep, const char *var, uint3
 			return (maybe_errorf(ep, 1, Tf_sD_s, var,
 			    "reference variable can't be an array"), NULL);
 		len = array_ref_len(val);
-		if (len == 0)
+		if (len < 3)
 			return (NULL);
 		/*
 		 * IMPORT is only used when the shell starts up and is
@@ -808,28 +816,30 @@ vtypeset(int *ep, const char *var, uint3
 		 * would be a major security hole.
 		 */
 		if (set & IMPORT) {
-			size_t i;
+			mksh_ari_u num;
 
-			for (i = 1; i < len - 1; i++)
-				if (!ctype(val[i], C_DIGIT))
-					return (NULL);
+			len -= 2;
+			strnbdupx(tvar, val + 1, len, ATEMP, tvarbuf);
+			if (getnum(tvar, &num, true, false) == -1)
+				len = 0;
+			if (tvar != tvarbuf)
+				afree(tvar, ATEMP);
+			if (!len)
+				return (NULL);
+			len += 2;
 		}
 		val += len;
 	}
 	if (ord(val[0]) == ORD('=')) {
 		len = val - var;
-		tvar = len < sizeof(tvarbuf) ? tvarbuf : alloc(len + 1, ATEMP);
-		memcpy(tvar, var, len);
-		tvar[len] = '\0';
+		strnbdupx(tvar, var, len, ATEMP, tvarbuf);
 		++val;
 	} else if (set & IMPORT) {
 		/* environment invalid variable name or no assignment */
 		return (NULL);
 	} else if (ord(val[0]) == ORD('+') && ord(val[1]) == ORD('=')) {
 		len = val - var;
-		tvar = len < sizeof(tvarbuf) ? tvarbuf : alloc(len + 1, ATEMP);
-		memcpy(tvar, var, len);
-		tvar[len] = '\0';
+		strnbdupx(tvar, var, len, ATEMP, tvarbuf);
 		val += 2;
 		vappend = true;
 	} else if (val[0] != '\0') {
@@ -838,9 +848,7 @@ vtypeset(int *ep, const char *var, uint3
 	} else {
 		/* just varname with no value part nor equals sign */
 		len = strlen(var);
-		tvar = len < sizeof(tvarbuf) ? tvarbuf : alloc(len + 1, ATEMP);
-		memcpy(tvar, var, len);
-		tvar[len] = '\0';
+		strnbdupx(tvar, var, len, ATEMP, tvarbuf);
 		val = NULL;
 		/* handle foo[*] => foo (whole array) mapping for R39b */
 		if (len > 3 && ord(tvar[len - 3]) == ORD('[') &&
@@ -916,6 +924,10 @@ vtypeset(int *ep, const char *var, uint3
 	innermost_refflag = new_refflag;
 	vp = (set & LOCAL) ? local(tvar, tobool(set & LOCAL_COPY)) :
 	    global(tvar);
+	/* when importing environment, resolve duplicates as first-wins */
+	/* the EXPORT check is to permit overwriting the default $PATH */
+	if ((set & IMPORT) && (vp->flag & (ISSET | EXPORT)) == (ISSET | EXPORT))
+		return (NULL);
 	if (new_refflag == SRF_DISABLE && (vp->flag & (ARRAY|ASSOC)) == ASSOC)
 		vp->flag &= ~ASSOC;
 	else if (new_refflag == SRF_ENABLE) {
@@ -938,7 +950,7 @@ vtypeset(int *ep, const char *var, uint3
 
 	set &= ~(LOCAL|LOCAL_COPY);
 
-	vpbase = (vp->flag & ARRAY) ? global(arrayname(tvar)) : vp;
+	vpbase = (vp->flag & ARRAY) ? arraybase(tvar) : vp;
 
 	/*
 	 * only allow export and readonly flag to be set; AT&T ksh
@@ -961,7 +973,7 @@ vtypeset(int *ep, const char *var, uint3
 		 */
 		for (t = vpbase; t; t = t->u.array) {
 			bool fake_assign;
-			char *s = NULL;
+			const char *s = NULL;
 			char *free_me = NULL;
 
 			fake_assign = (t->flag & ISSET) && (!val || t != vp) &&
@@ -983,13 +995,27 @@ vtypeset(int *ep, const char *var, uint3
 				t->type = 0;
 				t->flag &= ~ALLOC;
 			}
+			if (set & INTEGER) {
+				/*
+				 * Don't change base if assignment is to
+				 * be done, in case assignment fails.
+				 */
+				if (base > 0 && (!val || t != vp))
+					t->type = base;
+				/*
+				 * Do not permit content from the
+				 * environment to e.g. execute commands.
+				 */
+				if ((t->flag & IMPORT) && fake_assign) {
+					mksh_ari_u num;
+
+					if (getnum(s, &num, true,
+					    tobool(Flag(FPOSIX))) == -1)
+						s = "0";
+					clr |= IMPORT;
+				}
+			}
 			t->flag = (t->flag | set) & ~clr;
-			/*
-			 * Don't change base if assignment is to be
-			 * done, in case assignment fails.
-			 */
-			if ((set & INTEGER) && base > 0 && (!val || t != vp))
-				t->type = base;
 			if (set & (LJUST|RJUST|ZEROFIL))
 				t->u2.field = field;
 			if (fake_assign) {
@@ -1019,7 +1045,7 @@ vtypeset(int *ep, const char *var, uint3
 
 	if (vappend) {
 		size_t tlen;
-		if ((vp->flag & (ISSET|ALLOC|SPECIAL|INTEGER|UCASEV_AL|LCASEV|LJUST|RJUST)) != (ISSET|ALLOC)) {
+		if ((vp->flag & (ISSET|ALLOC|SPECIAL|INTEGER|UCASEV_AL|LCASEV|LJUST|RJUST|IMPORT)) != (ISSET|ALLOC)) {
 			/* cannot special-case this */
 			strdup2x(tvar, str_val(vp), val);
 			val = tvar;
@@ -1038,9 +1064,11 @@ vtypeset(int *ep, const char *var, uint3
 			/* done after assignment to override default */
 			if (base > 0)
 				vp->type = base;
-		} else
+		} else {
 			/* setstr can't fail (readonly check already done) */
 			setstr(vp, val, KSH_RETURN_ERROR | 0x4);
+			vp->flag |= (set & IMPORT);
+		}
 
 		/* came here from vappend? need to free temp val */
 		if (vappend)
@@ -1162,6 +1190,21 @@ is_wdvarassign(const char *s)
 	    (p[1] == '=' || (p[1] == '+' && p[2] == CHAR && p[3] == '=')));
 }
 
+/* don’t leak internal hash table order */
+static int
+envsort(const void *a, const void *b)
+{
+	const kby *cp1 = *(const kby * const *)a;
+	const kby *cp2 = *(const kby * const *)b;
+
+	while (*cp1 == *cp2) {
+		if (*cp1 == '=' || *cp1++ == '\0')
+			return (0);
+		++cp2;
+	}
+	return ((int)asciibetical(*cp1) - (int)asciibetical(*cp2));
+}
+
 /*
  * Make the exported environment from the exported names in the dictionary.
  */
@@ -1210,6 +1253,7 @@ makenv(void)
 		if (l->flags & BF_STOPENV)
 			break;
 	}
+	qsort(XPptrv(denv), XPsize(denv), sizeof(void *), envsort);
 	XPput(denv, NULL);
 	return ((char **)XPclose(denv));
 }
@@ -1610,19 +1654,23 @@ array_ref_len(const char *cp)
 }
 
 /*
- * Make a copy of the base of an array name
+ * same effect as global(copy of the base of an array name)
  */
-char *
-arrayname(const char *str)
+struct tbl *
+arraybase(const char *str)
 {
 	const char *p;
-	char *rv;
+	char *s, sbuf[32];
+	size_t n;
+	struct tbl *rv;
 
-	if (!(p = cstrchr(str, '[')))
-		/* Shouldn't happen, but why worry? */
-		strdupx(rv, str, ATEMP);
-	else
-		strndupx(rv, str, p - str, ATEMP);
+	n = strlen(str);
+	if ((p = memchr(str, '[', n)))
+		n = p - str;
+	strnbdupx(s, str, n, ATEMP, sbuf);
+	rv = global(s);
+	if (s != sbuf)
+		afree(s, ATEMP);
 
 	return (rv);
 }
@@ -2141,7 +2189,6 @@ c_typeset_vardump(struct tbl *vp, uint32
     bool pflag, bool istset)
 {
 	struct tbl *tvp;
-	char *s;
 
 	if (!vp)
 		return;
@@ -2173,6 +2220,8 @@ c_typeset_vardump(struct tbl *vp, uint32
 		/* optimise later conditionals */
 		any_set = 0;
 	do {
+		bool baseone = false;
+
 		/*
 		 * Ignore array elements that aren't set unless there
 		 * are no set elements, in which case the first is
@@ -2191,11 +2240,16 @@ c_typeset_vardump(struct tbl *vp, uint32
 			 * leftadj, zerofill, etc., but POSIX says must
 			 * be suitable for re-entry...
 			 */
-			shprintf(Tf_s_s, Ttypeset, "");
+			shprintf(Tf_s_, Ttypeset);
 			if (((vp->flag & (ARRAY | ASSOC)) == ASSOC))
 				shprintf(Tf__c_, 'n');
-			if ((vp->flag & INTEGER))
-				shprintf(Tf__c_, 'i');
+			if ((vp->flag & INTEGER)) {
+				if (vp->type == 1) {
+					baseone = true;
+					shf_puts("-i1 ", shl_stdout);
+				} else
+					shprintf(Tf__c_, 'i');
+			}
 			if ((vp->flag & EXPORT))
 				shprintf(Tf__c_, 'x');
 			if ((vp->flag & RDONLY))
@@ -2215,22 +2269,28 @@ c_typeset_vardump(struct tbl *vp, uint32
 			if ((vp->flag & INT_U))
 				shprintf(Tf__c_, 'U');
 		} else if (pflag) {
-			shprintf(Tf_s_s, istset ? Ttypeset :
-			    (flag & EXPORT) ? Texport : Treadonly, "");
+			shprintf(Tf_s_, istset ? Ttypeset :
+			    (flag & EXPORT) ? Texport : Treadonly);
 		}
+		shf_puts(vp->name, shl_stdout);
 		if (any_set)
-			shprintf("%s[%lu]", vp->name, arrayindex(vp));
-		else
-			shf_puts(vp->name, shl_stdout);
+			shprintf("[%lu]", arrayindex(vp));
 		if ((!thing && !flag && pflag) ||
 		    (thing == '-' && (vp->flag & ISSET))) {
-			s = str_val(vp);
 			shf_putc('=', shl_stdout);
-			/* AT&T ksh can't have justified integers... */
-			if ((vp->flag & (INTEGER | LJUST | RJUST)) == INTEGER)
-				shf_puts(s, shl_stdout);
-			else
-				print_value_quoted(shl_stdout, s);
+			if (baseone)
+				shprintf(vp->val.u > 0xFF ? "16#%04X" :
+				    "16#%02X", (unsigned int)vp->val.u);
+			else {
+				const char *s = str_val(vp);
+
+				/* AT&T ksh can't have justified integers... */
+				if (IS(vp->flag, INTEGER | LJUST | RJUST,
+				    INTEGER))
+					shf_puts(s, shl_stdout);
+				else
+					print_value_quoted(shl_stdout, s);
+			}
 		}
 		shf_putc('\n', shl_stdout);
 
